[{"title":"八年","date":"2020-02-13T06:53:40.000Z","path":"2020/02/13/八年/","text":"说在前面，我还记得那些快乐时光。 第一堂课叫遇见最后一堂课叫离别 一人戏一人陪两人戏互相随一人乏一人追两相交无处回 是以任性而不为，也惧人言可畏，骤醒眼角泪为谁？狼狈。 疫时也曾都无谓，但却孤赏景美，妄想伴卿迎春辉，不悔。","tags":[{"name":"随笔记","slug":"随笔记","permalink":"http://yangkunyi.com/tags/随笔记/"}]},{"title":"那一场即将醒来的梦","date":"2020-02-06T06:08:11.000Z","path":"2020/02/06/那一场即将醒来的梦/","text":"说在前面：这一年注定不凡，但却没想到不凡的开始带着如此多的意外。 猪年的结束，最后一天除夕终是回到家中……新年的爆竹不再响彻除夕拥挤的车厢没了笑颜团聚的话题变得沉重空荡的街道繁华的夜景孤自耀眼 鼠年的开始，第一天上班竟是在家中……没离开家的自己总是觉得假期还未结束，总是想着哪天醒来能接到通知:“今天所有员工必须回公司上班。”然后我背上行囊再次走上自己的路路上行人纷纷，打车还要排队幸然我抢到票，还有车送我到车站挤上早高峰一般拥挤的地铁…… 生肖到鼠，是一个轮回作为轮回的结束，平安喜乐作为轮回的开始，既然注定不凡那想必这一轮定然超乎所有人的预料黎明固然黑暗但也是离光最近的时刻到时影子都只能跑到你的身后还有何所惧呢？ 愿各自安好~愿平安喜乐~更愿无所畏~","tags":[{"name":"随笔记","slug":"随笔记","permalink":"http://yangkunyi.com/tags/随笔记/"}]},{"title":"Daily5","date":"2019-07-17T16:20:42.000Z","path":"2019/07/18/Daily5/","text":"说在前面：加班开的会还是挺有意思的，项目了解更多了，但是个人之后的定位，自己还是需要思考。 工作 学习了快一个周的投诉内容了，趁着这个机会将自己理解的投诉在梳理一番 首先要明白为什么会被投诉？ 服务问题 产品问题（包括业务） 客户误解 其次投诉的组成有哪些？ 对象 事件 诉求 个人对投诉的定义 用户的各种不满（包括有理和无理） 其实一个部门要优化，很多的需求都可以从投诉来寻找，因为正是客户投诉的点也正好是我们需要去优化的点。对投诉客户进行分类，分析诉求共同点，提出优化方案，一步一步完善流程和产品，这就是一条优化自身的道路。 学习SQL各种函数 Concat：连接字符串函数 Concat(vend_name,&#39;(&#39;,vend_country,&#39;)&#39;) RIRIM：去掉字段右边的空格 LIRIM：去掉字段左边的空格 IRIM：去掉字段左右两边的空格 RIRIM(vend_name) AS：赋予别名 RIRIM(vend_name)＋&#39;(&#39;＋RIRIM(vend_country)＋&#39;)&#39; AS vend_title Now()/CURRENT_DATE/CURDATE()/SYSDATE/GETDATE()/DATE()：返回当前时间 SUBSTR()/SUBSTRING()：提取字符串的组成部分 CAST()/CONVERT()：数据类型转换 LEFT()：返回字符串左边的字符 RIGHT()：返回字符串有变动的字符 LENGTH()：返回字符串长度 LOWER()：将字符串转换为小写 UPPER()：将字符串转换为大写 SOUNDEX()：返回字符串的SOUNDEX值","tags":[{"name":"日报","slug":"日报","permalink":"http://yangkunyi.com/tags/日报/"},{"name":"SQL","slug":"SQL","permalink":"http://yangkunyi.com/tags/SQL/"}]},{"title":"Daily4","date":"2019-07-15T14:44:58.000Z","path":"2019/07/15/Daily4/","text":"说在前面：今天上了一堂自己觉得十分有用的课，是来自于部门的经理的，很能感受到人与人的区别。 工作 学习投诉相关的流程和知识，可能跟天气有关，一天都感觉闷闷的，没什么精神，就跟同事说的那样，知识就是不进脑子，感觉一直在脑子外面徘徊。 分享（有效的职场“开启模式”） 你最满意今年完成的哪一项任务？ 你今年做的最有价值的一件事是什么？ 雇主的思维方式： 你的工作对部门产生了什么价值，有结果吗？有数据吗？你能创造什么价值？ 你的过去不错，但未来还有多少价值可言挖掘呢？ 个人：学习思维&amp;职场思维影响晋升的三个角色： 评估者（HR） 决策者（BOSS） 影响者（COLLEAGUE） 影响因素： 职场“能见度” 职场领导力 工作能力 一、学会聪明的工作（做一个靠谱的人） 前言：①工作来了不能直接拒绝 ②三思而后行 ③行必果（反馈） （1）做“正确”的事 目标管理 掌握重点 及时反馈 （2）正确的做事 不重新造轮子 成为改进者 学会复盘 （3）做一个靠谱的人 结论先行，强有力的数据支撑，例证强化大家的印象，重申论点 善用逻辑树，把难题拆成很多小问题，一个一个解决 不断超越对方的预期，合理地作出承诺，一旦承诺就要完成 （4）如何摆脱无意义的事情 真正重要的事情： 影响时间长 影响范围广 二、领导力的自我养成（1）方向感 大局观（阳台理论） 阳台理论：当你站在十字路口看到的东西是什么？“退一步”当你站在30楼的阳台上，你又看到了什么？ 更深一层思考 （2）能量感 赞美（并不是一个好就可以概括的） 驱动 （3）信任感 一味退让不可取（根据事情的性质来判断） 好合作，有原则，感反击 （4）OKR OKR（Objectives and Key Results）全称「目标和关键成果」，是一套明确和跟踪目标及其完成情况的管理工具和方法。 三、提升职场“能见度” 给自己贴正面标签 做跨部门合作项目 找到职场导师 穿得更高级一点 “营销”自己的业绩（结果） 利用外部曝光度 四、开放的职场心态 “巧者劳，智者忧，无能者，无所求，饱食而遨游。 ——庄子” 流程：平庸层——&gt;潜力层——&gt;奋斗层——&gt;精英层（四象限原则） “变”： 摆脱职业发展线性思维（如：只要…就…） 做好职场隐形晋升 这个世界上唯一不变的就是变化 分享待跟进事项 建立自己的“优势银行” 微信文案","tags":[{"name":"日报","slug":"日报","permalink":"http://yangkunyi.com/tags/日报/"},{"name":"分享","slug":"分享","permalink":"http://yangkunyi.com/tags/分享/"}]},{"title":"WeeklyMind-10","date":"2019-07-14T14:47:35.000Z","path":"2019/07/14/WeeklyMind-10/","text":"说在前面：前天看了一个数据提取的sql，发现自己的差距还很大呀，所以这个周末会继续学习。 工作 保证自己的心态没有问题就好了，一切都在开始慢慢步入正轨，跟同事的第一次聚餐也结束了，大家这两个月的实习生活也十分的精彩，希望在每个小伙伴在接下来的工作里都能有所成长和发展。 收到一个可以写点东西的消息，这个周末会思考一下，如果能有所展现也是不错的。 学习一、何为战略设计思维（看书）二、SQL组合WHERE子句123456789101112131415161718192021222324252627282930313233//AND 操操作符SELECT prod_name,prod_price,prod_idFROM ProductsWHERE vend_id＝&apos;DLL01&apos; AND prod_price&lt;＝4;//OR 操作符SELECT prod_name,prod_price,prod_idFROM ProductsWHERE vend_id＝&apos;DLL01&apos; OR vend_id＝&apos;BRS01&apos;;//求值顺序（AND先于OR）SELECT prod_name,prod_price,prod_idFROM ProductsWHERE (vend_id＝&apos;DLL01&apos; OR vend_id＝&apos;BRS01&apos;) AND prod_price&gt;＝10;//IN操作符SELECT prod_name,prod_price,prod_idFROM ProductsWHERE vend_id IN (&apos;DLL01&apos;,&apos;BRS01&apos;)ORDER BY prod_name;//同上功能SELECT prod_name,prod_price,prod_idFROM ProductsWHERE vend_id ＝ &apos;DLL01&apos; OR vend_id ＝ &apos;BRS01&apos;ORDER BY prod_name;//NOT操作符(等通于不等于的功能)SELECT prod_nameFROM ProductsWHERE NOT vend_id ＝ &apos;DLL01&apos;ORDER BY prod_name; 为什么要用IN操作符？ 在很多合法选项时，IN操作符的语法更清晰，更直观 在与其他AND和OR操作符组合使用IN的时候，求值顺序更加容易管理 IN操作符一般比一组OR操作符执行得更快 IN最大的优点是可以包含其他SELECT语句，能够更动态地建立WHERE子句 用通配符进行过滤123456789101112131415161718192021222324252627282930//LIKE操作符// % 表示任何字符出现任意次数SELECT prod_name,prod_idFROM ProductsWHERE prod_name LIKE &apos;Fish%&apos;;SELECT prod_name,prod_idFROM ProductsWHERE prod_name LIKE &apos;%bean bag%&apos;;SELECT prod_name,prod_idFROM ProductsWHERE prod_name LIKE &apos;F%y&apos;;// _ 与 % 类似，但只匹配单个字符SELECT prod_name,prod_idFROM ProductsWHERE prod_name LIKE &apos;__ inch teddy bear&apos;;// [] 用来指定一个字符集SELECT cust_contactFROM CustomersWHERE cust_contact LIKE &apos;[JM]%&apos;ORDER BY cust_contact;// 反义用^来表示(或者用NOT来表示)SELECT cust_contactFROM CustomersWHERE cust_contact LIKE &apos;[^JM]%&apos;ORDER BY cust_contact; 使用通配符的技巧： 不要过度使用通配符 在确实需要使用通配符的时候，也尽量不要把它用在搜索模式的开始处。将通配符放在开始，搜索是最慢的。 仔细注意通配符的位置。","tags":[{"name":"SQL","slug":"SQL","permalink":"http://yangkunyi.com/tags/SQL/"},{"name":"周报","slug":"周报","permalink":"http://yangkunyi.com/tags/周报/"}]},{"title":"Daily3","date":"2019-07-11T14:54:57.000Z","path":"2019/07/11/Daily3/","text":"写在前面：人啊，总是对自己求而不得的东西有着无比的向往，一旦得到了又会是怎么样呢？ 工作比较轻松的一天，工作是自己喜欢又沉浸其中的，我很高兴自己还保持着那样一颗平常心，尽管周遭事物与人都在改变。 学习筛选数据123456789101112131415161718192021222324//相等检验，使用WHERE子句SELECT prod_name,prod_priceFROM ProductsWHERE prod_price＝3.49;//检查单个值SELECT prod_name,prod_priceFROM ProductsWHERE prod_price&lt;10;//不匹配检查SELECT vend_id,prod_nameFROM ProductsWHERE vend_id&lt;&gt;&apos;DLL01&apos;;(or !＝)//范围值检查SELECT prod_name,prod_priceFROM ProductsWHERE prod_price BETWEEN 5 AND 10;//空值检查SELECT cust_nameFROM CustomersWHERE cust_email IS MULL;","tags":[{"name":"日报","slug":"日报","permalink":"http://yangkunyi.com/tags/日报/"},{"name":"SQL","slug":"SQL","permalink":"http://yangkunyi.com/tags/SQL/"}]},{"title":"Daily2","date":"2019-07-09T15:25:16.000Z","path":"2019/07/09/Daily2/","text":"说在前面，社会主义的一块砖，哪里需要哪里搬 工作今日份工作接线支撑，中间抽空了解了线下工作。无异常 小组瞎聊 累了之后脑袋一片空白 接快了之后觉得自己就是一个机器 智能知识库暂时毫无作用 不要太刻意的去模仿，遇到事情多想想就好了 措施：人力调度；增加话术（没有及时更新新的话术，场景已经变化了，但是还是只有一个话术）；时时关注现状；培养一线的能力，就是为了解决这种问题；线下工单情况，工作强度强了很多。 学习排序检索数据12345678910111213141516171819202122232425//按照产品名称排序SELECT prod_nameFROM ProductsORDER BY prod_name;(一定要放到最后)//按多个排序SELECT prod_name,prod_id,prod_priceFROM ProductsORDER BY prod_price,prod_name;//按列位置排序SELECT prod_name,prod_id,prod_priceFROM ProductsORDER BY 2,3;//指定排序方向//(升序ASC或者ASCENDING是默认的，降序是DESC或者DESCENDING)SELECT prod_name,prod_id,prod_priceFROM ProductsORDER BY prod_price DESC;//多个列排序SELECT prod_name,prod_id,prod_priceFROM ProductsORDER BY prod_price DESC,prod_name;","tags":[{"name":"日报","slug":"日报","permalink":"http://yangkunyi.com/tags/日报/"},{"name":"SQL","slug":"SQL","permalink":"http://yangkunyi.com/tags/SQL/"}]},{"title":"Daily1","date":"2019-07-08T14:44:09.000Z","path":"2019/07/08/Daily1/","text":"说在前面，今天雨，我希望我们在一起。 工作 今天结束了在线的工作，总的来说在线的工作其实没有热线那么累，热线自己还会将嗓子说哑了，但是在线就是开心的在聊天，不能解决也还有疑难可以提，嘿嘿。 项目的话，只能说自己考虑的方面还是不够全面，能想的确实是想了，但是能做到却不一定能做，但是自己只要把自己能做的做到就可以了。 这个月就有一个述职了，所以要开始准备了。 其他好像没什么了吧，就是自己接触到行业的知识还不够吧。 学习SQL检索数据(SELECT语句)12345678910111213141516171819202122232425262728293031323334353637//检索单个列表SELECT prod_nameFROM Products;//检索多个列表SELECT prod_name,prod_id，prod_priceFROM Products;//检索所有列SELECT *FROM Products;//检索不同的值SELECT DISTINCT vend_idFROM Products;//限制结果(SQL\\Access)SELECT top 5 prod_nameFROM Products;(DB2)SELECT prod_nameFROM ProductsFETCH FIRST 5 ROWS ONLY;(Oracle)SELECT prod_nameFROM ProductWHERE ROWNUM &lt;＝5（MySQL\\MariaDB\\PostgreSQL\\SQLite）SELECT prod_nameFROM ProductsLIMIT 5;//为了得到后五行数据SELECT prod_nameFROM ProductsLIMIT 5 OFFSET 5;","tags":[{"name":"日报","slug":"日报","permalink":"http://yangkunyi.com/tags/日报/"},{"name":"SQL","slug":"SQL","permalink":"http://yangkunyi.com/tags/SQL/"}]},{"title":"WeeklyMind-9","date":"2019-07-07T14:58:01.000Z","path":"2019/07/07/WeeklyMind-9/","text":"说在前面：这个周开始，自己就正式开始了上班的生活，上个周还在和各位同学依依不舍，这个周一切都切换到了不同的轨道，就简单说一下这个周发生的事情吧。 工作总之，一切都还是那么生疏，但是自己在开始慢慢转变自己的观念了，从一个在学校只有输入的学生（或许有少量的输出），慢慢转变为一个需要每天都有输出的工作者。 生活刚刚搬到这个地方，住了大概两个周了吧，周边环境还是很不错，现状唯一的不好就是还没有锅，不能自己做东西吃，这是很不方便的，所以先定下个月去购买厨房用品，这个月先坚持过去。 随心自己除了工作以外的时间安排还不够合理，没有主动的push自己，不管是心理上还是身体上，都不是自己理想中的工作生活，尽管现在可能是累了一点，但是学习这个事情，还是不能放到玩耍的前面，所以接下来这个周，自己要开始慢慢调整。 调整待跟进事项 每天简单的更新自己的微博（工作和学习内容），有机会要更新自己的微信公众号（想法和当下情感）。 每天看至少二十页的书，需要给自己充电。 马上教师资格证就要开始考试了，自己要开始准备，既然答应了就要做到。 英语不应该放下，自己每天应抽出半个小时，看看英语。","tags":[{"name":"周记","slug":"周记","permalink":"http://yangkunyi.com/tags/周记/"},{"name":"工作","slug":"工作","permalink":"http://yangkunyi.com/tags/工作/"}]},{"title":"VIDEO IDER","date":"2019-06-15T14:51:39.000Z","path":"2019/06/15/VIDEO-IDER/","text":"写在前面：公司四周年运营部需要拍摄视频，以下是自己和小伙伴们的想法。 运营人的一天表达主题 客户至上 团队协作 团队陪伴 坚持 视频框架 背景：一位本月生日的客服小伙伴，生日仍然在工作。 您好，请问有什么可以帮您？（获取用户需求） 遇到困难时，有组长支撑（组长是一位准妈妈） 以需求为导向对接各个部门（解决用户问题过程） 中午吃饭，心情不太好（担心客户的问题没有解决） 下午参与生日会（之前的某一个客户问题解决了，生日会来送锦旗） 需要拍摄的场景 客服接到电话收到需求的场景 组长帮助的场景 各部门解决问题的场景 吃饭的场景 下午生日会的场景（包括锦旗） 之前客户的回忆场景","tags":[{"name":"视频","slug":"视频","permalink":"http://yangkunyi.com/tags/视频/"},{"name":"想法","slug":"想法","permalink":"http://yangkunyi.com/tags/想法/"}]},{"title":"微信历史文章（持续更新）","date":"2019-02-25T02:19:04.000Z","path":"2019/02/25/微信历史文章（持续更新）/","text":"自己将所写的微信文章以及排版的微信文章都整理到这里，以便查看。 学院公众号 （【新媒体一岁啦】幸会，有你~） （你的端午已到，请查收） （放假了小视频） （达康书记给你发了一张“三下乡”体验卡，快来领取） （经济管理学院积极开展“学习总书记讲话 做合格共青团员”系列活动） （“不忘初心跟党走”入团仪式篇） （【PK赢大奖】1000元大奖！团体赛、个人赛！这个主题网络活动这么嗨） （【重邮征集令】现代邮政学院LOGO、经管学院吉祥物征集） （经管RADIO第十期|我们的圣诞礼） （经管小奥运之奥运小达人评选开始啦！） （【投票】曲艺大赛参赛节目微信投票） （【经济管理学院十佳科技之星线上票选】） （主曲艺新声绝代 持经管至尚风华） （科创理想浩瀚 科技之星璀璨） （支教第四课：带不走的支教情怀） （经管法学专场报告人先进事迹简介） （【活动报名】曲艺大赛终极夜主持人线上海选） （经管小奥运开始报名啦！！！） （新起点，新征程—记经济管理学院“团学工作一体化”运营启动大会） （【经管RADIO第五期】从你的全重庆路过） （蓝瘦，香菇！为什么我那么忙！） （铲屎官带你看可爱又迷人的汪星人） （生活服务中心成立暨第一期培训大会，我们拭目以待） （重邮经管今日速报） （经济管理学院学生事务管理体系介绍） （情系重邮 相约经管） （微微一笑，在经管遇见那个Ta） （重庆邮电大学丨经济管理学院欢迎你） （青春三下乡 美丽中国行||三下乡回顾—“助V邮我”实践服务队） （青春三下乡 美丽中国行||三下乡回顾—小平的后“忆”国情观察团） （青春三下乡 美丽中国行||三下乡回顾—e行·益童） （青春三下乡 美丽中国行||三下乡回顾—闪闪红星） （【青春三下乡，美丽中国行】“共系柚乡情”向你扔来一个柚子，快接住） （【青春三下乡，美丽中国行】“闪闪红星”体验敬老院日常，发挥专业特长） （【青春三下乡，美丽中国行】追寻小平足迹，调研红色经济） （军训汇演预热丨小编带你抢先看） （如果你跟着追风筝的人团队，那么你将体验…….） （【夜读】你的问题主要在于想的太多） （青春三下乡，美丽中国行） （2015级军训，我们来了！） （经济管理学院2016年 第二专业招生简章） （带上诚信，共赴考场） （毕业季丨经济管理学院2016届毕业典礼暨授位仪式） （万晓榆院长在毕业典礼上的讲话） （在大学，期末备考给你带来了哪些折磨……） （经管RADIO第四期|火车旅行） （【六一投稿】还记得你小时候的样子吗？……） 以下文章来自自己的公众号 （做朋友是不可能的） （旅行首长 | | 台湾花莲） （所有热爱的事情都要不留余力） （一路回望，继续前行【第二篇】） （一路回望，继续前行【第一篇】） （初来乍到） （懒癌晚期的老杨终于推文了）","tags":[{"name":"新媒体","slug":"新媒体","permalink":"http://yangkunyi.com/tags/新媒体/"},{"name":"微信公众号","slug":"微信公众号","permalink":"http://yangkunyi.com/tags/微信公众号/"}]},{"title":"英语阅读技巧","date":"2018-09-27T04:35:41.000Z","path":"2018/09/27/英语阅读技巧/","text":"这是根据老师上课整理的，一天的课程其实有很多的东西都需要在后续的练习中去体会，毕竟这是老师根据自己的经验总结的，自己只能作为参考，需要总结的是自己的经验，我这才是最后能把题做对的方法。 Day1 Reading SkillsTopic（主题）: 内容：2-3 key words (对象，话题) 位置：1st+2nd (开局) 特点： 1.一篇文章的主题有且仅有一个(Only One) 2.复现频率高 英语为了避免重复，总是用隐形再现，以下是隐形再现的方式。 ①同一置换Eg: animalscreaturesspeciesindividualscommunity ②主题省略Eg: the (height) trend in sports (NBA) may obscure an unrecognized reality. ③暗喻借代（逆向思维） ④逻辑暗示A.change(改变):比如时间的改变B.impact(影响)C.relationship(关系) Thesis statement(主旨) 内容：One sentence(主旨句) 位置：1st+2nd 寻找步骤与方式： 1.第二段的开头是否有转折标志。 2.若没有则看第一段最后是否有总结句。 3.若没有则自行总结。（合二为一） 特点：它是全文的中心思想，是全文的话题、观点、看法、结论。 Topic sentence (每一段的主旨句) 特点： 1.与Topic相关（key words） 2.支持主旨句 3.有着语篇标志 4.拥有三个标准 5.拥有三种逻辑结构 六种语篇标志(一) 三种转承连词/副词 1) 转折对比 2) 因果总结 3) 强调排他 (二) 表达观点/结论(三) 特殊标点 1) ： 2) —— 3) ”“ 4) () (四) 情态动词（2.5个） 1) Must 2) Should 3) Need(当应该的时候) (五) 特殊结构句型(六) 平铺直叙（首末句，以第一句为主） 三个标准(一) 关联法：主题、主旨、上段主题句(二) 数量法：标志的数量(三) 顺序法：最后一次转承连词出现，标志级别的顺序 三种逻辑结构(一) 重叠性(二) 对立性(三) 互补性 阅读文章的四大框架(一) 描述现象+分析现象+得出结论(二) 提出对象+支持观点or反驳观点or讨论观点+归纳总结(三) 提出问题+分析问题（原因+后果）+解决问题（提出建议方法）(四) 对比对照+分项对比+总体结论 做题步骤(一) 通读开局，把握文章主题主旨（2分钟以内）(二) 浏览题干（选项），文中定位（1-2分钟之间）(三) 程序答题，辨析干扰（15分钟） Day2 Selecting Skills六大题型Testing items(选择题目)(一) 步骤 1.定位有匹配，定位段落 2.查看中心句 3.关联主旨 4.匹配选项 (二) 步骤 1.定位无匹配，定位段落 2.关联上段中心句 3.寻找下段有无指示代词 4.理解匹配选项 (三) 问以下何者正确 1.第一题：定位在1st+2nd 2.不是第一题：上题答案之后便是本题出处。 (四) 作者观点态度 1.无人认领的观点即为作者的观点 2.must/should 3.连词/副词/介词短语观点句子 4.形式主语的形容词色彩 (五) 文章大意主旨 1.主旨句 2.各段中心句 3.利用十字交叉法 4.注意主语宾语 (六) 定位查找 1.本题考查词汇量 2.上下句推理 3.定位在哪一句答案就在哪一句 四大干扰选项辨析(一) 偷换概念 1.与原文信息高度相似 2.替换词或句导致意思变异 3.增加或减少词句导致意思变异 4.颠倒因果/条件导致逻辑变异 排除步骤： 1) why？与原文相似 2) where different？ 3) how？变异× 一致√ (二) 主次混淆 1.与原文完全一致（照抄原文） 2.但是只是detail 不是point (三) 观念错误 1.对象不对 (四) 过度推理 1.选项中包含比较级或者最高级 2.极端排他词（only/unless/no one/no one else…） Day3 Reading Tips/Strategies给标题匹配段落 1.通读文章开局，把握文章主题背景 2.关联文章主题，准确理解标题 3.归纳各段的中心，比对选取标题 段落排序 1.交叉阅读，把握文章主题和背景 两段复现率Topic 2.段落标志/功能，进行大致定位 3.六种关联证据，段落精准排序 1) 在哪找？a) 90%首尾关联b) 10%首首关联平行段落 2) 找什么关联？a) 指代关联b) 词义关联c) 转承关联d) 数字关联e) 时地关联f) 专有名词关联 3) 怎么找？a) 指代（指示代词）b) 词义：上下文，同根，同义，原词c) 转承：逻辑d) 数字：计算，顺序e) 时地：点对点，日对日，月对月，年对年，地点归属…f) 专有名词：专有名词是否指的同一对象 信息补全题 1.通读文章开局，把握文章的主旨背景 2.上下文推理，确定文中缺失信息的大意 1) 归纳中心 2) 上下句推理 3.关联证据，确定答案","tags":[{"name":"英语","slug":"英语","permalink":"http://yangkunyi.com/tags/英语/"}]},{"title":"排序（数据结构）","date":"2018-08-23T02:22:23.000Z","path":"2018/08/23/排序（数据结构）/","text":"同样是复习总结。 基本概念 概念：就是重新排列列表中的元素，使表中的元素满足按关键字递增或递减的过程。 算法的稳定性：简单来说就是原本列表中的两个相同元素经过排序算法后，如果没有发生位置变化，则称该算法是稳定的；反之则不稳定。 注： 1.算法是否具有稳定性并不能衡量一个算法的优劣，它主要是对算法的性质进行描述。 2.对于不稳定的排序算法，只需举出一组关键字的实例，说明它的不稳定性即可。 排序根据数据元素是否完全在内存中，可分为内部排序和外部排序。 内部排序：在排序期间元素全部存放在内存中的排序。 外部排序：在排序期间元素无法全部同时存放在内存中，必须在排序过程中根据要求不断地在内、外存之间移动的排序。 在今天只是对内部排序进行复习。 内部排序的操作：比较和移动。（并不是所有的内部排序算法都要基于比较，例如：基数排序） 内部排序算法的性能却决于算法的时间复杂度和空间复杂度，而时间复杂度一般是由移动的次数来决定的。 直接插入排序（插入排序）算法12345678910111213//直接插入排序void InsertSort(ElemType A[],int n)&#123; int i,j; for(i=2;i&lt;=n;i++)&#123; //依次将A[2]~A[n]插入到前面已排序序列 if(A[i].key&lt;A[i-1].key)&#123; //若A[i]的关键码小于其前驱，需将A[i]插入有序表 A[0]=A[i]; //复制为哨兵，A[0]不存放元素 for(j=i-1;A[0].key&lt;A[j].key;--j)&#123; //从后往前查找待插入位置 A[j+1]=A[j]; //向后挪位 &#125; A[j+1]=A[0]; //复制到插入位置 &#125; &#125;&#125; 性能分析 空间效率：O(1) 时间效率：O(n²) 稳定性：稳定 适用性：顺序储存和链式储存 折半插入排序（插入排序）算法1234567891011121314151617181920//折半插入排序void InsertSort(ElemType A[],int n)&#123; int i,j,low,high,mid; for(i=2;i&lt;=n;i++)&#123; //依次将A[2]~A[n]插入到前面已排序序列 A[0] = A[i]; //将A[i]暂存到A[0] low = 1; high = i - 1; //设置折半查找的范围 while(low&lt;=high)&#123; //折半查找（默认递增序列） mid = (low + high) / 2; //取中间点 if(A[mid].key&gt;A[0].key)&#123; //查找左半子表 high = mid - 1; &#125; else low = mid + 1; //查找右半子表 &#125; for(j=i-1;j&gt;=high+1;--i)&#123; A[j+1]=A[j]; //统一后移元素，空出插入位置 &#125; A[high+1] = A[0]; //插入操作 &#125;&#125; 性能分析 空间效率：O(1) 时间效率：O(n²) 稳定性：稳定 适用性：顺序储存 希尔排序（插入排序）算法1234567891011121314151617//希尔排序void ShellSort(ElemType A[],int n)&#123; //对顺序表作写入插入排序，本算法和直接插入排序相比，做了以下修改： //1.券后记录位置的增量是dk，不是1 //2.r[0]只是暂存单元，不是哨兵，当j&lt;=0时，插入位置已到 for(dk=n/2;dk&gt;=1;dk=dk/2)&#123; //步长变化 for(i=dk+1;i&lt;=n;kd=dk/2)&#123; if(A[i].key&lt;A[i-dk].key)&#123; //需将A[i]插入有序增量子表 A[0] = A[i]; //暂存在A[0] for(j=i-dk;j&gt;0&amp;&amp;A[0].key&lt;A[j].key;j-=dk)&#123; A[j+dk] = A[j]; &#125; A[j+dk] = A[j]; &#125;//if &#125; &#125;&#125; 性能分析 空间效率：O(1) 时间效率：O(n²) 稳定性：不稳定 适用性：顺序储存 冒泡排序（交换排序）算法123456789101112131415//冒泡排序void BubbleSort(ElemType A[],int n)&#123; for(i=0;i&lt;n-1;i++)&#123; flag = false; for(j=n-1;j&gt;i;j--)&#123; if(A[j-1].key&gt;A[j].key)&#123; swap(A[j-1],A[j]); flag = true; &#125; &#125; if(flag==false)&#123; return; &#125; &#125;&#125; 性能分析 空间效率：O(1) 时间效率：O(n²) 稳定性：稳定 适用性：顺序储存 特点：每一趟排序都会将一个元素放置到其最终的位置上。 快速排序（交换排序）算法1234567891011121314151617181920212223242526//快速排序void QuickSort(Element A[],int low;int high)&#123; if(low&lt;high)&#123; int pivotpos = Partition(A,low,high); //划分 QuickSort(A,low,pivotpos-1); //依次对两个子表进行递归排序 QuickSort(A,pivotpos-1,high); &#125;&#125;//快速排序中的一分二为操作int Partition(ElemType A[],int low,int high)&#123; //一趟排序过程 ElemType pivot = A[low]; //将当前表中第一个元素设为枢轴值，对表进行划分 while(low&lt;high)&#123; //跳出循环 while(low&lt;high&amp;&amp;A[high]&gt;=pivot)&#123; --high; &#125; A[low] = A[high]; //将比枢轴值小的元素移动到左边 while(low&lt;high&amp;&amp;A[low]&lt;=pivot)&#123; ++low; &#125; A[high] = A[low]; //将比枢轴值大的元素移动到右边 &#125; A[low] = pivot; //枢轴值元素存放到最终位置 return low; //返回存放数轴的最终位置&#125; 性能分析 空间效率：最坏情况O(n)；平均情况O(log2n) 时间效率：O(n²) 稳定性：不稳定 适用性：顺序储存 特点：每一趟排序都会将一个元素放置到其最终的位置上。 简单选择排序（选择排序）算法123456789101112//简单选择排序void SelectSort(ElemType A[],int n)&#123; //对表A作简单选择排序，A[]从0开始存放元素 For(i=0,i&lt;n-1;i++)&#123; //一共进行n-1趟 min = i; //记录最小元素位置 for(j=i+1;j&lt;n;j++) //在A[1···n-1]中选择最小的元素 if(A[j]&lt;A[min]) min = j; if(min!=i) swap(A[i],A[min]); &#125;&#125; 性能分析 空间效率：O(1) 时间效率：O(n²) 稳定性：不稳定 适用性：顺序储存 堆排序（选择排序） 这是一种树形选择排序方法，特点：子啊排序过程中，将L[1…n]看成是一棵完全二叉树的顺序储存结构，利用完全二叉树中双亲结点和孩子节点之间的内在关系，在当前无序区中选择关键字最大（或最小）的元素。 小根堆（小定堆） 大根堆（大定堆） 建立大根堆的算法123456//建立大根堆void BuildMaxHeap(ElemType A[],int len)&#123; for(int i=len/2;i&gt;0;i--)&#123; //从i=[n/2]~1,反复调整堆 AdjustDown(A,i,len); &#125;&#125; 向下调整算法123456789101112131415//向下调整算法void AdjustDown(ElemType A[],int k,int len)&#123; A[0] = A[k]; //A[0]暂存 for(i=2*k;i&lt;=len;i*=2)&#123; //沿key较大的子结点向下筛选 if(i&lt;len&amp;&amp;A[i]&lt;A[i+1]) i++; //取key值较大的子结点的下标 if(A[0]&gt;=A[i]) break; //筛选结束 else&#123; A[k] = A[i]; //将A[i]调整到双亲结点上 k = i; //修改k值，以便继续向下筛选 &#125; &#125;//for A[k] = A[0]; //被筛选结点的值放入最终位置&#125; 向上调整算法1234567891011//向上调整算法void AdjustUp(ElemType A[],int k)&#123; A[0] = A[k]; int i = k/2; //若结点值大于双亲结点，则将双亲结点向下调，并继续向上比较 while(i&gt;0&amp;&amp;A[i]&lt;A[0])&#123; //循环跳出条件 A[k] = A[i]; //双亲结点下调 k = i; i = k/2; //继续向上比较 &#125;//while A[k] = A[0]; //复制到最终位置&#125; 堆排序的算法12345678// 堆排序算法void HeapSort(ElemType A[],int len)&#123; BuildMaxHeap(A,len); //初始创建 for(i=len;i&gt;1;i--)&#123; //n-1趟的交换和建堆过程 swap(A[i],A[1]); //输出堆顶元素（和堆低元素交换） AdjustDown(A,1,i-1); //整理，把剩余的i-1个元素整理成堆 &#125;//for&#125; 性能分析 空间效率：O(1) 时间效率：O(nlog2n) 稳定性：不稳定 适用性：顺序储存 归并排序Merge算法123456789101112131415161718//Merge函数ElemType *B = (ElemType *)malloc((n + 1) * sizeof(ElemType)); //辅助数组Bvoid Merge(ElemType A[],int low,int mid,int high)&#123; //表A的两段各自有序，将它们合成一个有序表 for(int k=low;k&lt;=high;k++)&#123; B[k] = A[k]; //将A中所有元素复制到B中 &#125; for(i=low,j=mid+1,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)&#123; if(B[i]&lt;=b[j]) //比较B的左右两段中的元素 A[k] = B[i++]; //将较小值复制到A中 else A[k] = B[j++]; &#125;//for while(j&lt;=mid) A[k++] = B[i++]; //若第一个表未检测完，复制 while(j&lt;=high) A[k++] = B[j++]; //若第二个表未检测完，复制&#125;//注：这里最后的两个while循环只有一个会执行 排序算法123456789//排序算法（2路）void MergeSort(ElemType A[],int low,int high)&#123; if(low&lt;high)&#123; int mid = (low + high)/2; //从中间划分两个子序列 MergeSort(A,low,high); //对左侧子序列进行递归排序 MergeSort(A,mid+1,high); //对右侧子序列进行递归排序 Merge(A,low,mig,high); //归并 &#125;&#125; 性能分析 空间效率：O(n) 时间效率：O(nlog2n) 稳定性：稳定 适用性：顺序储存 基数排序性能分析 空间效率：O(r)（r是队列的个数） 时间效率：O(d(n+r))（特点：跟序列的初始状态无关） 稳定性：稳定 适用性：顺序储存 各种排序的比较及应用各种排序算法的性质 算法种类 时间复杂度 空间复杂度 是否稳定 最好情况 平均情况 最坏情况 直接插入排序 O(n) O(n²) O(n²) O(1) 是 冒泡排序 O(n) O(n²) O(n²) O(1) 是 简单选择排序 O(n²) O(n²) O(n²) O(1) 否 希尔排序 O(n²) O(n²) O(n²) O(1) 否 快速排序 O(nlog2n) O(nlog2n) O(n²) O(log2n) 否 堆排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 否 2-路归并排序 O(nlog2n) O(nlog2n) O(nlog2n) O(n) 是 基数排序 O(d(n+r)) O(d(n+r)) O(d(n+r)) O(r) 是 排序算法的应用（1）选取排序方法需要考虑的因素： 待排序的元素数目n 元素本身信息量的大小 关键自结构及其分布情况 稳定性的要求 语言工具的条件，存储结构及辅助空间的大小 （2）排序算法小结： 若n（n&lt;=50）较小，则可以采用直接插入排序和简单选择排序。当记录本身信息量较大的时候，用简单选择排序较好。 若文件的初始状态已关键字基本有序，则选用直接插入或冒泡排序为宜。 若n较大，则采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序、归并排序。 快速排序被认为是目前基于比骄傲的每部排序法中最好的方法。（不稳定） 堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。（稳定） 当追求稳定时，可以采用归并排序。但通常不提倡2-路归并，而是将它和直接插入排序结合在一起使用。直接插入排序是稳定的，因此改进后的归并排序仍是稳定的。 当文件的n个关键字随机分布时，任何借助“比较”的排序算法，至少需要O(nlog2n)的时间。 当n很大，记录的关键字位数较少且可以分解时，采用基数排序较好。 当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结构。","tags":[{"name":"复习","slug":"复习","permalink":"http://yangkunyi.com/tags/复习/"},{"name":"博客","slug":"博客","permalink":"http://yangkunyi.com/tags/博客/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yangkunyi.com/tags/数据结构/"}]},{"title":"查找（数据结构）","date":"2018-08-21T08:27:36.000Z","path":"2018/08/21/查找（数据结构）/","text":"今天数据结构复习到查找部分，正好将这一部分初步整理出来，以便之后学习的时候参考复习。 基本概念 查找：在数据集合中寻找满足某种条件的数据元素的过程。 查找结果： 查找成功 查找失败 查找表：用于查找数据集合。查找表的操作： 1.查找是否存在某个特定元素（静态） 2.检索满足条件的某个特定元素的属性（静态） 3.在查找表中删除一个数据元素（动态） 4.在查找表中插入一个数据元素（动态） 动态：二叉排序树的查找；散列查找； 静态：顺序查找；折半查找；散列查找； 关键字：数据元素中唯一标识该元素的某个数据项的值。 平均查找长度：是衡量查找算法效率的最主要指标。 1.顺序查找（线性查找）1）一般线性表的顺序查找（无序） 算法： 1234567891011// 顺序查找typedef struct&#123; //查找表的顺序结构 ElemType *elem; //元素储存空间地址，建表时按实际长度分配，0号单元留空（哨兵） int TableLen; //表的长度&#125;SSTable;int Search_seq(SSTable ST,ElemType key)&#123; //在顺序表ST中顺序查找关键字为key的元素，若找到则返回元素在表中的位置 ST.elem[0] = key; //&quot;哨兵&quot; for(i=ST.TableLen;ST.elem[i]!=key;i--) ; //从后往前找 return i; //若表中不存在关键字为key的元素，将查找到i为0时退出for循环&#125; 缺点：当n较大的时，平均查找长度较大，效率低； 优点：对数据元素的存储没有要求，顺序存储或链式存储皆可；对表中记录的有序性也没有要求，无论记录是否按照关键码有序均可应用。 平均查找长度：(n+1)/2 注意：对线性的链表只能进行顺序查找。 2）有序表的顺序查找 查找失败可以不再找到表的另一端，能降低顺序查找失败的平均查找长度。 查找平均长度： 成功：(n+1)/2 失败：n/2+n/(n+1) 2.折半查找（二分查找） 算法： 123456789101112131415//二分查找int Binary_Search(SeqList L,ElemType key)&#123; //在有序表L中查找关键字为key的元素，若存在则返回其位置，不存在则返回-1 int low = 0,hight = L.TableLen-1,mid; while(low&lt;=high)&#123; mid = (low + high)/2; //取中间位置 if(L.elem[mid] == key) return mid; //查找成功则返回所在位置 else if(L.elem[mid]&gt;key) high = mid - 1; //从前半部分继续查找 else low = mid + 1; //从后半部分继续查找 &#125; return -1;&#125; 判定树（计算成功和不成功的平查找长度） 3.分块查找（索引顺序查找） 块内的元素可以无序，但块之间是有序的。 步骤： 1.在索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表 2.在块内顺序查找 散列表 散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr。（的地址可以是数组下标、索引、或内存地址等） 冲突：散列函数可能会把两个以上的不同关键字映射到同一地址 同义词：发生冲突的不同关键字 散列表：是根据关键字而直接进行访问的数据结构 对散列表进行查找的时间复杂度为O(1) 散列函数的构造方法 注意: 1.散列函数的定义域必须包含全部需要储存的关键字，而值域的范围则依赖于散列函数表的大小或地址范围 2.散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间，从而减少冲突的发生 3.散列函数应尽量简单，能够在较短的时间内就计算出任一关键字对应的散列地址 4.实际的选择中，采用何种构造散列函数的方法取决于关键字集合的情况，但是目标是为了使产生的冲突的可能性尽量的降低 （1）直接定址法 直接取关键字的某个函数值为散列地址，散列函数为：H(key)=a×key+b。这种方法计算简单，并且不会产生冲突。 它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，将造成储存空间的浪费。 （2）除留余数法 这是一种最简单、最常用的方法，假定散列表表长为m，出下一个不大于m但最接近或等于m的质数p，利用H(key)=key%p的公式把关键字转换成散列地址。 该方法关键的是选好p，使得每一个关键字通过函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性。 （3）数字分析法 设关键字是r进制数（如十进制），而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几处数码经常出现，则应选数码分布较为均匀的若干位作为散列地址。 这种方法适合于已知的关键字集合，如果更换了关键字，就需要重新构造新的散列函数。 （4）平方取中法 顾名思义，取关键字的平方值的中间几位作为散列地址。具体多少位要看实际情况而定。这种方法取到的散列地址和关键字的每一位都有关系，使得散列地址分布布较均匀。 适用于关键字的每一位取值都不够均匀或均小于散列地址所需的函数。 ####（5）折叠法 将关键字分割成位数相同的及部分（最后一部分的位数可以短一些），然后取这几部分的折叠和作为散列地址。 关键字位数很多，而且关键字中每一位上数字分布大致均匀时，可以采用折叠法得到散列地址。 ####（6）随机数法 选择一随机函数，取关键字的随机值作为散列地址。 通常用于关键字长度不同的场合。 处理冲突的方法 任何设计出来的散列函数都不可能绝对地避免冲突，为此，必须考虑在发生冲突时应该如何进行处理，即为产生冲突的关键字寻找下一个“空”的Hash地址。 （1）开放定址法 可存放新表项的空闲地址既向它的同义词表现开放，又向它的非同义词表项开放。 A.线性探测法 冲突发生时，顺序表查看表中下一个单元（当探测到表尾m-1时，下一个探测地址是表首地址0），直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。 缺点：可能时第i个散列地址的同义词存入第i+1个散列地址，这样本应存入第i+1个散列地址的元素就争夺第i+2个散列地址的元素的地址……，从而在成大量元素的响铃的散列地址上“聚集”（或堆积）起来，大大降低了查找效率。 B.平方探测法（二次探测法） 这是一种较好的处理冲突的方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少探测到一半的单元。 C.再散列法（双散列法） 需要两个散列函数，当通过第一个散列函数H(key)得到的地址发生冲突时，则利用第二个散列函数Hash2(key)=&gt;[H=(H(key)+i*Hash2(key))%m]计算该关键字的地址增量。 D.伪随机序列法 利用伪随机数序列 （2）拉链法 为了避免非同义词发生冲突，可以把所有的同义词储存在一个线性链表中，这个线性链表由其散列地址唯一标识。 适用于经常进行插入和删除的情况。 散列的查找和性能分析 查找与构造方式基本一致。 散列表的查找效率取决于三个因素：散列函数、处理冲突的方式和填装因子。 填装因子：α=表中记录数n/散列表长度m","tags":[{"name":"复习","slug":"复习","permalink":"http://yangkunyi.com/tags/复习/"},{"name":"博客","slug":"博客","permalink":"http://yangkunyi.com/tags/博客/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yangkunyi.com/tags/数据结构/"}]},{"title":"斐波那契数列学习","date":"2018-07-25T13:50:38.000Z","path":"2018/07/25/斐波那契数列学习/","text":"复习过程中涉及到计算算法的时间复杂度，课后例题中的“计算斐波那契数列时间复杂度”引起了自己的思考，通过学习，总结出好集中不同的方式。 斐波那契数列简介 斐波那契数列（意大利语：Successione di Fibonacci），又译为菲波拿契数列、菲波那西数列、斐波那契数列、黄金分割数列。在数学上，费波那契数列是以递归的方法来定义： F[0] = 0 F[1] = 0 F[n] = F[n-1] + Fn-2 用文字来说，就是费波那契数列由0和1开始，之后的费波那契系数就是由之前的两数相加而得出。首几个费波那契系数是： 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233…… 特别指出：0不是第一项，而是第零项。 计算方法递归法递归计算斐波那契数列的JavaScript如下： 1234567function Fibonacci1(n)&#123; if(n==0) return 0; if(n==1) return 1; return Fibonacci1(n-1) + Fibonacci1(n-2);&#125; 递归的方法很简单，但是显然十分显然存在大量的重复运算，效率低下很低，还会占用大量的内存。 时间复杂度：T(n) = O(2^n) 递推法为了避免递归的低效率，我们可以采取累加的方式，一项一项的计算，JavaScript代码如下： 123456789101112function Fibonacci2(n)&#123; a = 0; b = 1; if(n==0) return a; for(i = 1;i &lt;= n;i++)&#123; c = a + b; a = b; b = c; &#125; return c;&#125; 时间复杂度：T(n) = O(n) 空间复杂度：O(n) 公式法 以下是斐波那契数列的常见递推公式： $$ F_{n}=\\dfrac {1}{\\sqrt {5}}\\times \\left[ \\left( \\dfrac {1+\\sqrt {5}}{2}\\right) ^{n}-\\left( \\dfrac {1-\\sqrt {5}}{2}\\right) ^{n}\\right] $$ 公式法的JavaScript代码如下： 12345678910function Fibonacci3(n)&#123; root_five = sqrt(5); f1=f2=1; for(i=1;i&lt;=n;i++)&#123; f1 *= (1+root_five)/2; f2 *= (1-root_five)/2; &#125; result = (f1 - f2)/root_five; return int(result);&#125; 虽然公式看起来不是很复杂，但是当中有很多的浮点运算，返回的结果也会因为n越来越大而不断产生更大的误差，因此并不可靠。 矩阵法$$ \\begin{bmatrix} F{n} \\ F{n-1} \\end{bmatrix}=\\begin{bmatrix} F{n-1}+F{n-2} \\ F{n-1} \\end{bmatrix}=\\begin{bmatrix} 1\\times f{n-1}+1\\times F{n}-2 \\ 1\\times f{n-1}+0\\times F_{n-2} \\end{bmatrix}=\\begin{bmatrix}1 &amp; 1 \\1 &amp; 0\\end{bmatrix} $$ 由此可推得： $$ \\begin{bmatrix} F{n} \\ F{n-1} \\end{bmatrix}=\\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \\end{bmatrix}^{n-1}\\times \\begin{bmatrix} F{1} \\ F{0} \\end{bmatrix}=\\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \\end{bmatrix}^{n-1}\\times \\begin{bmatrix} 1 \\ 0 \\end{bmatrix} $$ 那这里就把问题转换为了求矩阵的n-1次幂，利用快速幂的方式来计算： $$ a_{n}=\\begin{cases}a^{\\dfrac {n}{2}}a^{\\dfrac {n}{2}},ifniseven\\ a^{\\dfrac {n-1}{2}}a^{\\dfrac {n-1}{2}}a,ifnisodd\\end{cases} $$ 以上方法的JavaScript代码如下： 123456789101112131415161718192021222324252627282930// 矩阵乘法function multiMatrix(int[][] m1,int[][] m2) &#123;//参数判断什么的就不给了，如果矩阵是n*m和m*p,那结果是n*p int[][] res = new int[m1.length][m2[0].length]; for (int i = 0; i &lt; m1.length; i++) &#123; for (int j = 0; j &lt; m2[0].length; j++) &#123; for (int k = 0; k &lt; m2.length; k++) &#123; res[i][j] += m1[i][k] * m2[k][j]; &#125; &#125; &#125; return res;&#125;// 矩阵快速幂function Fibonacci4(int n) &#123; if (n &lt; 1) &#123; return 0; &#125; if (n == 1 || n == 2) &#123; return 1; &#125; //底 int[][] base = &#123;&#123;1,1&#125;, &#123;1,0&#125;&#125;; //求底为base矩阵的n-2次幂 int[][] res = matrixPower(base, n - 2); //根据[f(n),f(n-1)] = [1,1] * &#123;[1,1],[1,0]&#125;^(n-2)，f(n)就是 //1*res[0][0] + 1*res[1][0] return res[0][0] + res[1][0];&#125; 时间复杂度：T(n) = O(log(n)) 今天的学习过程中并不是全部都理解透彻了，关于时间复杂度也还有更长的路去学习，本文仅关于一道课后题延伸出这些内容。未完待续~~~","tags":[{"name":"学习","slug":"学习","permalink":"http://yangkunyi.com/tags/学习/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yangkunyi.com/tags/数据结构/"}]},{"title":"NodePPT","date":"2018-04-11T06:38:20.000Z","path":"2018/04/11/NodePPT/","text":"用了好几次这个ppt，自己确实觉得这是用过的ppt中最简洁，B格最高的ppt，但是每次做都要去看原文档，十分的不方便，因此自己写一篇文章，将经常使用的一些命令和参数记录下来。例子：https://yangkunyi.com/Share/ppt.html原文：https://github.com/ksky521/nodeppt 简介 这是一款网页ppt库，只需要编辑相应的md文档就可以做出演示ppt，支持markdown,html,css,js等不同的语言，十分的方便。 常用命令本地跑md文档12// port是端口号nodeppt start -p &lt;port&gt; 生成html文档12// 默认生成publish文件夹nodeppt generate filename -a 常用主题和动画主题colors-moon-blue-dark-green-light 翻页动画 kontext vkontext circle earthquake cards glue stick move newspaper slide slide2 slide3 horizontal3d horizontal vertical3d zoomin zoomout pulse 单页动画语法 {:&amp;.动画} 因为自己又经常将ppt放到GitHub上去，所以也顺便记一下git的常用指令 git常用指令从本地上传到仓库的步骤 git init git add . git commit -m &#39;备注&#39; git remote origin add 仓库地址 git pull //当仓库不为空的时候需要做的工作 git push git status //查询状态","tags":[{"name":"nodeppt","slug":"nodeppt","permalink":"http://yangkunyi.com/tags/nodeppt/"},{"name":"学习","slug":"学习","permalink":"http://yangkunyi.com/tags/学习/"}]},{"title":"Day-1","date":"2018-03-12T15:37:15.000Z","path":"2018/03/12/Day-1/","text":"这是自己游戏开始的第一天。 今日游戏进度 完成英语的记忆 今天因为课程和学分的事情，未完成数学的学习，明天除了代课以外，应该能够完成自己定的计划。 今日完成事项 通信课程学分认定 课表课程 再次思考学校（电子科技大学 VS 四川大学） 明日安排 代课 待更进事项 思想报告（2016年11月-2018年3月） 微信订阅号 博客更新","tags":[{"name":"游戏攻略","slug":"游戏攻略","permalink":"http://yangkunyi.com/tags/游戏攻略/"},{"name":"日记","slug":"日记","permalink":"http://yangkunyi.com/tags/日记/"}]},{"title":"WeeklyMind-8","date":"2018-03-11T15:36:44.000Z","path":"2018/03/11/WeeklyMind-8/","text":"这是开学第一周，经过一个寒假的思考，自己选择了和之前不同的决定，那就是考研。 寒假小结“锦城之行” 过程中虽然我和室长都没有提起这项人生大事，但从室长的言语中，我感受到了她心中的那份宁静，也不愿再去打破，如果这是她愿意的，也接受的，并且感受到了快乐，那接受又有什么不好呢。而自己可能还是有点不甘心吧，不想就这样过了，大学的生活过了一大半，找个工作，然后挣钱，生活，大半辈子就这样过去了，我怕到时候自己会后悔，我还想学习，其中也有一点点小小的逃避，我也不否认，所以我想再为自己努力一下吧，反正就一年，拿来学习，我相信自己还是可以的，毕竟也是经历过这样子考试的了，为了自己想要过的生活，自己也需要在上一层楼。这些都是自己想的，也不知道你怎么想的。两天的行程很短，但很精彩，真的很放松，在那边和室友一起出去玩的时候就经常想着有机会一定要和你出门玩一次，我们一起看逛了想逛的地方，吃了想吃的东西，这次经历我会一直记得。不过还是要说室长真的缺乏锻炼啊，我是一个喜欢散步得人，而你好像并不是很喜欢走路啊，老是走走就累了。 三三（家兔，已亡）和十七（安哥拉兔） 说起来可能不信，现在十七就在我脚下，还在闹腾呢，突然有一点理解室长有了它们之后为什么得忧虑症，突然除了自己的命以外，身上又背上了一条命，然后我也快忧虑了。 过年 过年最不一样的可能就是除夕了吧，因为今年的除夕没有在家里过，而是和朋友在外面看烟花过的，总的来说感觉还是不错的。然后就是每家的过年饭啊，只是人慢慢长大了，大家都开始有自己的圈子了，可能是观点上的偏差吧，开始有点疏远了。今年过年是真的累，没有一天懒觉不说，自己还心系两门缓考，初六就来了学校。这些都是上学期的后遗症啊。 缓考 一节课没上，用一个周时间复习两门课，然后考试，能及格都是奇迹啦！ 考研准备 既然选择了，就要好好的开始准备，自己小金库都拿去报了班，然后还买了ipad，希望更方便看复习资料和视频等，不负青春不负自己。 基本信息 专业：计算机科学与技术 类型：工学 学校：四川大学 VS 电子科技大学 所需分数：380分以上 英语：70 数学：120 政治：70 专业：120 考试内容101思想政治理论 记忆内容放到后两个月再复习，做题。 201英语一（本学期重点学习） 词汇量 阅读能力 写作能力 301数学一（本学期重点学习） 高等数学 56% 线性代数 22% 概率论与数理统计 22% 874 or 820计算机科学专业基础综合 这三本书都学过，这学期再过一遍，做做练习题。PS：九月出考试大纲，根据大纲再复习。 数据结构（严蔚敏c语言版） 操作系统（汤子瀛） 计算机网络（谢希仁） 时间大纲8：00 起床 洗漱 早饭 9：00之前 到图书馆 每日英语 专业课复习 12：00 ~ 14：00 午饭 午休 14：00之后 每日数学 专业课复习 18：00 ~ 19：00 晚饭 散步（回忆今天所复习的内容） 19：00 ~ 21：30 自由学习时间 日记 21：40 ~ 跑步 洗漱 睡觉 一天的学习量 这里的量会灵活机动一点，而不是所谓的一定，自己之所以做这个计划，是希望自己知道什么时候该做什么，而不是有时候无所事事。 英语：根据单词书，每天定量完成。 数学：一个月至少完成一本书！一天就大概是三节到四节的内容（可根据难易程度调整）。 专业：根绝英语和数学的量，适当看书做练习，做到对专业知识的敏感和熟悉，为后面的复习打下基础。","tags":[{"name":"周记","slug":"周记","permalink":"http://yangkunyi.com/tags/周记/"}]},{"title":"电子商务案例分析——博客来","date":"2018-02-22T07:50:50.000Z","path":"2018/02/22/电子商务案例分析——博客来/","text":"本次分析主要从博客来的团队，经营理念，市场定位，营销策略，竞争优势，网站特色，APP架构，成功原因等方面分析。 一、前言动机 根据蹇洁老师对本学期自己无法在本学期完成电子商务案例分析课程的要求，自己在台湾选择两所电子商务公司做为案例，进行案例分析；再次根据自己的了解，自己选择博客来作为其中一所电子商务企业作为一个案例来分析，自己有尝试联系位于台北的总部，希望可以到总公司进行参访，但是官方拒绝了自己的申请，所以下面的分析来自与自己查阅的资料，以及使用博客来的一些亲身体验。 目的 以博客来为例完成电子商务案例分析。 分析经营策略 分析竞争优势 分析官网 分析App 浅谈成功原因 浅谈未来发展 二、博客来简介创业背景 于 1995 年创立，迄今已成为台湾最大的网络书店。 创立起因于总经理张天立于八年多前刚回台湾之际，看到台湾整个书籍信息传递多是透过宣传单张、目录或传真的方式，无法有效而迅速地传达书讯给读者以及无法有效地整合全国的书籍信息，抱着内心一股对文化的理想，凭借直觉与热情，在当时台湾因特网尚处于蛮荒时期的 状况下，创立了博客来，并坚持努力。 选择书籍为销售商品则因书籍最适合网络购物价格、也最适合网络传递信息、知识的属性。 在博客来买书，必须要加入会员才有资格，网友可免费加入会员，照使用密码与账号来买书，不须再重复填写任何数据，就可将书籍直接寄至会员基本数据输入的地址，不但方便，也不用担心网络交易被他人冒用；而会员在登录数据时，可选择有兴趣的主题，博客来也会定期将这些书讯，以E-mail的方式寄给会员。 另外网站上还有贴心的服务，对第一次来到博客来的读者做详细的使用介绍，更为了向消费者保证交 易安全，更有专门网页介绍其安全机制，以确保消费者的权益。 是一个类似超级大型卖场的网络书讯服务站，主要提供消费者50余家知名出版社、二十万余册的详细书讯，并可以享受直接在网络上刷卡购书的便利。 并且经过发展，现在将生活也纳入整个系统中，网站上的内容不再只有书籍，提供了更多的购物服务。（类似与大陆的当当网，书籍为主，生活为辅） 三、经营团队 员工人数：260人 资本额：2亿 公司负责人：林丕容 总经理：高明义 博客来成立于1995年，是台湾图书、影音销售第一大通路，近年更积极跨足成为全方位网购零售平台，以「在购物中思考‧在阅读中进化」为品牌精神，持续拓展百货商品品类与服务，以更简易、更贴心的购物接口及流程、便捷的出货速度与优质的客服服务，博客来更获得经济部「数据隐私保护标章认证」的安全购物网站，期待提供消费者更安全、便利、无障碍的购物体验。 四、经营理念 「提供诚信、便利、专业、创新的服务平台，打造消费者完美使用经验。」成为华文世界电子商务服务平台的第一品牌。 以谦虚的态度接受环境的要求，持续开发符合会员多元选择的商品属性及数量，设计更简易、更贴心的购物接口及流程，挑战更快的出货速度及更好的客户服务质量，为广大华文阅读人口在虚拟环境中提供真实、有效率的服务，并为信息需求人口而努力，建造最便捷的书籍讯息 管道，期待迈向更安全、更便利、无障碍的电子商务服务平台。 五、市场定位 博客来自我定位为「全球华文的知识入口」，强调为广大华文知识需求人口提供丰富完整的服务。以华文书籍经营开始事业的发展，将来仍将以此作为企业主要经营的项目。至今以台湾地区的出版品为主，亦将把香港、中国大陆地区出版品资料纳入，以提供完整的华文书讯。陆续开发的新商品，亦围绕网络人口对知识的需求之上，包括古典音乐CD、爵士乐CD、杂志、电子书 等会是书籍之外重要的服务项目。 六、经营策略1. 与实体书店明显区别 博客来贴近消费者的方式，一是数据库愈来愈丰富，二是配送速度愈来愈快。 和实体商店相比，虚拟商务最重要的物流服务是在销售后才开始，而且寄送的速度代表对消费者的服务品质，也是对业者相当大的挑战。 虚拟化商品本来就不易得到消费者的信任与好感，如果总是以折扣来刺激购买力，以目前销售量有限的情形来看，恐怕会得反效果。因此虚拟商店必须更注重加值服务，才能与实体商店做出明显区隔。 实体书店需要的是「库存量」，而网络书店则需要一个强大完善的「数据库」。 传统书店和网络书店的比较 \\ 传统书店 网络书店 地区限制 有（限定某区域） 无（互联网全世界都可以看到） 气候影响 有（天气不好客人少） 无 时间限制 有（晚上会关门） 无（服务器24小时不断线） 交易方便度 低（还需要亲自到现场） 高 开店成本 成本高（主要是店面租金） 成本低 交易风险 低（一手交钱，一手交货） 高 商品品质 高（亲眼可见，亲手可感） 低（容易有瑕疵，和预想不一样） 2. 企业合作 无论是实体的社群或是虚拟的社群，如和企业、学校合作等。博客来网络书店目前与1,500 家出版社建立合作关系，在预售书方面获得极大成绩，并将与更多实体通路合作，继续扩大在网络书店市场的占有率。 3. 超强物流 利用统一超商的物流系统，具有相当大的优势。可于统一超商取书付款的方式，提供以此方式取书的消费者更高的折扣，以节省邮资成本，另外在购物流程中务求简单流畅。 简单来说博客来和大智通物流中心合作，其主要客户及经营的业务为负责母公司统一超商通路及其他通路像博客来、统一型录、康是美、统一皇帽等，共约4,500店的出版品、影音信息、数字影像服务、 玩具等营销与配送业务。 拥有全省7-11之强大通路支持，公司业务含盖物流、出版、冲印、网站、礼赠品等业务！目前也为 7-11 专业代理冲印便、数字影像网站及I cash卡团卡制等业务。 大智通除专业的物流服务外，其业务内容是为出版社、通路及消费者规划优质的营销活动。 台湾的统一超商每条街都也，也就是说你前一天在网上买的书第二天就到你家最近的超商店里了，绝对强的物流。 4. 吸收邮资，降低消费者成本 利用统一超商的物流系统，具有相当大的优势。可于统一超商取书付款的方式，提供以此方式取书的消费者更高的折扣，以节省邮资成本，另外在购物流程中务求简单流畅。 5. 利润来源 计算每月成本并能用适度的成本来完成工作，另外计算每本书利润，以算出卖出多少书本能达获利并以此为目标。 博客来的利润来源来自于卖书，不过博客来强调单靠卖书的利润相当微薄，这与台湾的邮资高居不下有很大的关系。 6. 电子书出版 实体书为目前主流，但电子书是未来趋势。对出版业来说，可大幅节省成本的数字内容出版潜力无穷，然而对于内容保护措施以及电子出版流程的安全性却是业者未能大举攻措之因。数字内容的加密保护周全与否是影响获利的重要关键之一；成熟的版权保护及制作技术，都是电子书发展成功的重要因素。 博客来网络书店是台湾最早成立的网络书店。除了实体书的交易，电子书销售服务也是博客来开发的市场之一。而博客来网络书店在采用台湾数字版权管理系统供货商优硕系统「eBook 版权管理系统」后，已有作业及营销上的成效。 博客来在2001年2月选择台湾数字权利商优硕信息做为技术伙伴，推出付费电子书下载服务。电子书的内容由博客来向出版社取得授权，博客来提供销售平台，而电子书制作、转文件加密等技术流程，则由优硕负责。在推出电子书销售后，一年来已有超过上万人次付费下载电子书。而未来即将推出的PDA版本电子书，预估全年下载人次将增加数倍。 博客来所采用的优硕电子书系统 (Neovue eBook System)」，采用 128-Bit AES 加密机制，优硕电子书系统整合创作、制作、发行与阅读平台，更为博客来快速建立完整的电子书产销体系。博客来营销部门还可根据系统每月所提供之销售统计作客户分析，精准进行数据库营销。此套电子书解决方案也可整合现有出版系统，并支持多种付款机制的完整B2B2C平台。 7. 利用facebook管理粉丝 客服跟大陆类似的在线服务，而是利用email和facebook与网站的会员进行联系。 不过网站的客服专区基本能解决大部分的问题，而email服务则是提供给需要特别服务的客户的，其次是用来发布消息的facebook官方账号，这就类似与大陆的微信公众号，推送的是网站最近的消息，通过这样的方式来活跃会员，并且将网站的最新消息推送给会员。 因为facebook是一个更加开放的平台，因此不仅仅可以活跃已经关注的会员，同时也可以起到宣传的目的，在广场上的活跃度也能提升网站的知名度。 七、竞争优势 通过SWOT分析法来体现竞争优势。 博客来的S（优势Strengths） 书籍商品种类丰富 随时随地都可以购买 与 7-11 合作到店取货 完整性的数据库，搜寻方便 价格便宜 物流快 博客来的W（劣势Weakneses） 未达金额有运费 缺货时等待时间长 无法直接确认书况 竞争业者的增加 博客来的O（机会Opportunities） 网络购物为未来的趋势 独家物流的配送方式 商品多元化 利用会员优惠得到消费者的信赖 博客来的T（威胁Threats） 网络安全性的把关 传统网络书店(EX:亚马逊) 实体店面加入网络战场 成交金额偏低 电子书发展成熟 八、网站特色网站上人口 网站主要会员是由关心社会议题、支持公益活动，追求品味与质感生活的消费者组成。 会员数在2015年已经突破500万。 逻辑思维图分析网站结构 图片链接：http://otn4ut2th.bkt.clouddn.com/study%E5%8D%9A%E5%AE%A2%E6%9D%A5%E7%BD%91%E9%A1%B5.png 九、APP架构 图片链接：http://otn4ut2th.bkt.clouddn.com/study%E5%8D%9A%E5%AE%A2%E6%9D%A5APP.png 九、成功原因 规避在线付款的风险，打造超商付款的商机 贴心的为会员服务，提供会员个人化电子报 订购容易，取货据点多、推出10天内退货等售后服务 提供消费者完整的书籍讯息（包括绝版书） 常办活动，以五折价出售畅销书 无论是新书或其他书籍皆有折扣，且新书折扣期间较长 订单送出后如有库存三天后即可领取商品，推出中午前订明天到的销售方法 十、未来发展 博客来网络书店总经理张天立认为：”实体书店和网络书店是可以并存的，实体书店不会因为网络书店的出现就消灭或结束”。网络书店与实体书店各自代表着不同的意义，各自有不同的功能，网络书店与实体书店并存，可以提供各式各样不同类型的消费者更多的选择管道。 当初创办博客来网络书店，最大的动机不在于商业的营利性，而是在于整合台湾的出版资源及提升阅读环境的理念下而出发，因此在未来，博客来将不只提供读者购书的服务，更希望成为主动的导览者、专业的推介人，读者不仅可以在博客来看到越来越多种商品，更有越来越快速而方便的服务，并更有效率地与读者分享知识的传递及推广，让读者在网络上能够遇见更多种可能性！","tags":[{"name":"学习","slug":"学习","permalink":"http://yangkunyi.com/tags/学习/"},{"name":"电子商务","slug":"电子商务","permalink":"http://yangkunyi.com/tags/电子商务/"},{"name":"网页分析","slug":"网页分析","permalink":"http://yangkunyi.com/tags/网页分析/"}]},{"title":"物流App分析——货车帮","date":"2018-01-27T06:28:19.000Z","path":"2018/01/27/物流App分析——货车帮/","text":"物流App营销策略分析——以货车帮为例 App架构 其实货车帮App有根据使用者的不同，分别有两个，一个是给司机使用，一个是给货主使用。如图： 营销策略品牌策略主要产品为货车帮手机App，目前支持Android和iOS两大主流平台。该手机App专门针对国内的卡车司机提供货源匹配核心功能，同时提供交易担保、卡车团购、维修救援、汽配销售等周边产品服务。同时也专门对国内货主提供配送司机的核心功能，同时提供货物担保等服务。整合了国内的货物与货车资源，解决了让货主和司机最实际最头疼的问题，以此获得不少司机和货主的青睐。 网页策略网页架构 网页类型本网站属于单一的企业介绍网站。 产品策略产品功能 千万优质货源信息实时跟新，全新操作页面，找货更简便。 优质货源一键订阅，实时语音提示 ETC享优惠，拉货省钱又安心 担保交易保障，放空赔付无需担心空返 短信一键定位，让货主发现身边的你 快速计算里程估测成本 违章查询信息查询 产品特点 覆盖全国的货源信息网络及公共运力池，同时在全国设立线下直营服务网点，线上线下联动，保障了良好的服务水平。 严格的审核机制，构建平台诚信体系。司机和货主均需要通过严格的材料审核，才能注册和使用货车帮APP，同时平台提供担保交易，保障司机利益。 独有的公路物流垂直领域的大数据。2015年，货车帮联合阿里云大数据团队共同打造的全国公路物流指数，全面反映了我国公路物流货物运输流向、货物分布情况、车辆分布情况，丰富了物流统计指标体系。 更新内容 订阅货源数量显示更准确； 订阅货源列表支持车长/车型筛选； 订单详情支持发送证件给货主； 扫一扫功能统一至附近频道； “我的”提供统一客服入口； 价格策略 A套餐 688元–100条，每条货源6.8元 B套餐1688元–2000条，每条货源0.84元 C套餐 2688元–5000条，每条货源0.54元 D套餐 3688元–10000条，每条货源0.37元 促销策略对司机 一站式提供油品、ETC、白条、保险、新车等产品优惠（双十一）。 从购车、保险、拉货、加油、过路费、贷款周转等全链条钜惠用户，现金券、低折扣、诚意金抵扣现金、礼品抽奖等活动丰富，优惠力度空前，福利毫不逊色电商平台（双十一）。 针对信用好的会员，平台会给予优质货源置顶、优先积分变现、金融支持优惠、投诉优先调处、专职服务顾问等奖励（会员行为守则）。 对货主 运费打折 免保险费 整体策略 借助网上知名站点（ISP或ICP）、免费电子邮件和一些免费公开的交互站点（如新闻组、公告栏）发布企业的产品信息，对企业和产品进行宣传推广。 利用网络营销策略扩大站点的知名度，吸引上网者访问网站，起到宣传和推广企业以及企业产品的效果。 利用可以直接销售的网络营销站点，采用一些销售促进方法如价格折扣、有奖销售、拍卖销售等方式，宣传和推广产品。 借助互联网的交互功能吸引用户与企业保持密切关系，培养顾客忠诚度，提高企业收益率。 渠道策略 及时在网站发布促销信息、新产品信息、公司动态 为了方便付款还要提供多种支付模式 与多家大企业合作，通过这些合作将产品推广到更多人面前 客服策略 客户电话：95006（会主动给客户打电话询问需求） 微信小程序：提供App类似服务 微信公众号：第一时间提供最新消息 线下地址：贵州省贵阳市经济技术开发区（原小河区）开发大道123号","tags":[{"name":"学习","slug":"学习","permalink":"http://yangkunyi.com/tags/学习/"},{"name":"App分析","slug":"App分析","permalink":"http://yangkunyi.com/tags/App分析/"}]},{"title":"电子商务案例分析——PChome","date":"2018-01-21T07:45:43.000Z","path":"2018/01/21/电子商务案例分析——PChome/","text":"本次分析主要从PChome网络家庭的经营现状，营销策略，网站特色和结构，面临的挑战，潜在的问题和五力等方面分析。 一、前言动机 根据蹇洁老师对本学期自己无法在本学期完成电子商务案例分析课程的要求，自己在台湾选择两所电子商务公司做为案例，进行案例分析；再次根据自己的了解，自己选择博客来PChome作为其中一所电子商务企业作为一个案例来分析，自己有尝试联系PChome的总部，希望可以到总公司进行参访，但是官方拒绝了自己的申请，所以下面的分析来自与自己查阅的资料，以及使用PChome的一些亲身体验。 目的 以PChome家庭网络为例完成电子商务案例分析。 分析经营现状 分析营销策略 分析官方网站 分析挑战和问题 分析五力 二、PChone简介 电子商务主要可分成三种商业模式，网家集团当然皆有布局。网家母公司经营的是 B2C(PChome 在线购物)，两家子公司则分别经营 C2C(露天拍卖)与 B2B2C(商店街)。 B2C 为传统的购物网站型态，即消费者向购物网站下单，购物网站再向大盘商调货来出给消费者。台湾前五大 B2C 网站依序为网家、台湾奇摩、富邦 momo、博客来、Pay Easy 等，合计市占率(电子商务)超过50%，网家的市占率则约为 17~18%。 网家是在 2000 年开始 PChome 在线购物的业务，并于 2007 年开始提供「24H 购物」的服务。可以想象，要在这么短的时间送货给消费者，物流能力将会是决胜关键，为了维持成长，网家每年要增加一处仓储中心喔！ 三、经营现状 名称 详情 产业 电子咨询供应服务 营业额（季度） 31.34亿元新台币 总资产（季度） 27.24亿元新台币 资产净值（季度） 12.01亿元新台币 实收资本额（月） 6924388450元新台币 结算期 每年12月（月制会计年度） 主要股东 赛特咨询服务有限公司 子公司 露天市集国际信息股份有限公司网络家庭投资顾问股份有限公司网络家庭投资开发股份有限公司乐屋国际信息股份有限公司等 网址 www.pchome.com.tw 独立仓库 入口网站提供电子商务服务的典型为台湾 PChome 网络家庭及香港商 Yahoo！奇摩，由 PChome 先开始的电子商务销售。早期电子商务网站是转单模式，店商平台像是大型的购物目录消费者下单后，由平台将订单转至各供货商，再由供货商出货。由于效率不佳，也较难掌控购物流程质量，故PChome后来直接开设独立仓库，开始自己主导购物流程，由于后台可以更顺利串流至仓储系统及金物流，让消费者真正享受到网络购物的方便性。 PChome 推出全球创举24小时到货专区(PChome 24h 购物)！率先采用中央仓储方式，掌握整体配送流程。这不仅让网购平台不再只是供应商与顾客之间的媒介，他们所追求的「订单、库存、出货零时差」更让网购通路成为足以和实体通路分庭抗礼的购物管道。 经营模式 过去 PChome 一直与 Yahoo！奇摩购物中心对打，当时 PChome 只是以低价要求的网络通路，直到后来效法Amazon建立物流仓储系统。以三班制24小时的台式服务精神，在仓库中不断用手推车走到不同货架前检货，他们以:网络购物只要专心一件事，「就是如何让消费者最快拿到商品。」然后推出了让消费者可以放心并准确预测收到时间的 PC home 24 小时到货服务来取的顾客的信任与满足下单者对于产品拿到的时效性限制。 推出的创新服务| 名称 | 详情 || :——–: | :—–: || PChome Online 线上购物创新服务 | 杂志的网络订阅平台 || ATM 一对一账户转账 | 线上分期付款 || 线上捐赠发票给福利团体 | 跟实体大通路合作 || 网络首买 MP3 | 线上折价券 || 线上现金积点 | 简讯确定订单 || 线上自动退货 | 发票电子化寄送 || 信用卡红利积点折抵刷卡金 | 首创线上购物24小时专区 || 增加更多的福利来满足消费者 | 购物更便利 | 服务流程 他们有自己的仓储库减少消费者下单后还需要向源头厂商叫货并集中后再统一宅配至消费者手上的时间，尽可能地与消费者拉近距离，简化流程增加时效性。 作业流程的比较 2015年营业收入报告 四、营销策略 PChome成立于 1998 年，为一综合网络服务集团，提供电子商务、入口网站、网络电信服务等，其中电子商务与网络电信服务早已是台湾龙头，入口网站则是全国第二大。 PChome业务结构 市场分析 商品内容：内容多样性，但易精品为主 区域市场：台湾为主 产品市场销售：较为热门 消费者购买类型分析：以一般生活用品，衣服，鞋子等为主 销售费用：基本手续费 整体行销策略1. 品牌形象 突显品牌的价值与差異，努力提升品牌形象，并提高客户信赖度及消费者认同感。积极配合上下游厂商，建立良好互动关系，以掌握稳定的供货及销售网络，及由供货商提供之良好服务及产品，维护公司之 良好商誉。 2. 消费者导向策略 计划根据既有的营运成功经验，以消费者导向为主要营销策略，提供更多、更完整、更便宜、各方便的网络购物环境，并持续推动与其他产业之合作计划，寻求同业或異业之策略联盟；网络购物流程则兼顾交易安全化及交易接口简单化。长期而言，持续加强消费者导向，贴近网络消费者习性需求，推出符合消费者期望之产品或服务。 3. 差异化策略 依消费者族群偏好为依据，客户的需求为导向，了解客户的年龄结构、消费趋向及消费习惯，并以有效的方式达到广告与宣传效果，藉由将市场切割为愈小的区块，愈能为消费者提供愈优质的服务与产品。 4. 快速回应 将入口网站与在线购物之业务、研发客服人员，按照产品别进行任务编组，以更完善的服务质量，增加产品的附加价值，并更快速响应消 费者或客户的问题。 STP分析 市场细分（market segmentation）：自由的买卖方式让各族群能便利购物。 目标市场（market targeting）：通用于各族群间使用，提高便利性与使用方法。 市场定位（market poditioning）：购物、拍卖网站，以多样化的民生用品或信息产品。 4P分析1. 产品 网络购物的优点在于不需实体店面，因此在不用考虑空间的限制下，商品的种类就可以多元化，消费者可以在一个地方购足他们所需的各种商品。所以在产品类型的多样化是网络营销的重要关键。在 PChome 或 Yahoo 首页即可见到各类商品，让消费者可以依需求选择。 2. 价格 低价，一直是消费者会购物的一大原因。购物网站首页总是会有各种 促销方案。PChome 网络家庭的总体策略是「希望给消费者最优惠的价格，并赚取合理的报酬，但是要给消费者最实惠的价格，缩少通路的层级。」是由公司营运长谢振豊所规划出来的组织方向。 3. 通路 网络商店由于无实体店面，虽然不能提供现场选货服务，但省下可观的店租成本，在通路上，网络营销的组织弹性是较大的，能够因应环境做适当调整。且对于消费者而言，超商取货、宅配，都是极为方便的选择。 4. 促销 购买流程的简易便利性，也影响着消费者的选择，Yahoo 和 PChome 也不时推出各类促销活动，且 PChome 的 24 小时送货服务、逾期还有积点的赔偿，这样的策略让许多消费者选择这样的服务。 创新之处1. 网页 PChome 24 小时购物精准掌握消费者需求产出新服务概念，解决顾客下订单之后等太久的困扰，为顾客创造价值才是创新的根本。 PChome 24 小时购物的「新服务概念」、「新客户接口」、「新服务传递系统」、「技术选择」四构面都有相当的创新。 PChome 24 小时购物服务的内容与特色鲜明，锁定需要快速收到货的目标族群，在网络购物市场找到独特利基优势。 PChome 24 小时购物在新客户接口提供「容易操作」、「容易查询」商流服务接口，有助于创新服务的表现。 PChome 24 小时购物设计三个新流程：(1)商品选购、(2)成立仓储物流中心集中管理商品、(3)宅配送达，来处理商流、金流、物流、 信息流。 PChome 24 小时购物的核心技术策略，成功开发「快速供货管理系统」及「硬盘式仓储管理储存模式」二个 IT 系统，成功作到资讯实时整合，让订单零时差、出货零时差、库存零时差，为技术 选择关键。 2. 科技 「技术选择」在 PChome 24 小时购物创新服务的扮演不可或缺的关键性角色，技术决定服务，支撑「新服务概念」「服务传递系统」、「新 12 客户接口」其它三构面。 3. 特点 PChome 24 小时购物的营销、分配、及组织发展策略奏效，链接新服务概念、新客户接口、新服务传递系统，成功推行创新服务。 PChome 的营销策略锁定需要迅速收到货的目标市场，提供多样产品选择，强化 24 小时购物品牌形象。 PChome 整合统一速达的宅配，提供 24 小时购物服务，与为分配策略重要的一环。 PChome 24 小时购物的组织发展策略，在组织资源及能耐已有足够的能力规划及经营管理此创新服务。 PChome 降低消费者交易成本，缩短交易流程及时间，加速消费者采纳 24 小时购物。 五、网站特色和结构 网站架构与功能 (1) 架构：用会员登入后浏览供货商的产品并做竞标或购买的手续， 然后再以各种负费方式(信用卡.转账)来付款。 (2) 功能：PChome -提供网络商品展示平台让买家卖家可以互相交流 并交易。 品牌形象的营造 突显品牌的价值与差異，努力提升品牌形象，并提高客户信赖度及消 费者认同感。积极配合上下游厂商，建立良好互动关系，以掌握稳定的供货及销售网络，藉由供货商提供之良好服务及产品，维护公司之 良好商誉。 消费者导向策略 计划根据既有的营运成功经验，以消费者导向为主要营销策略，提供 更多样、更完整、更便宜、各方便的网络购物环境，并持续推动与其他产业之合作计划，寻求同业或異业之策略联盟；网络购物流程则兼顾交易安全化及交易接口简单化。长期而言，持续加强消费者导向， 贴近网络消费者习性需求，推出符合消费者期望之产品或服务。 差異化营销手法 依消费者族群偏好为依据，客户的需求为导向，了解客户的年龄结构、 7 消费趋向及消费习惯，并以有效的方式达到广告与宣传效果，藉由将市场切割为愈小的区块，愈能为消费者提供愈优质的服务与产品。 任务编组快速响应 将入口网站与在线购物之业务、研发及客服人员，按照产品别进行任 务编组，以更完善的服务质量，增加产品的附加价值，并更快速响应 消费者或客户的问题。 PChome网站结构 六、面对的挑战和潜在问题 在现今网络无国界的环境下，PChome 虽然已是台湾第一大甩卖网站，但依旧还是需要不断的更新技术，增加新的产品服务，来锁住消费者的心。而拍卖网站除了商品的多元化来吸引消费者浏览外，最重要的还是『交易的安全』，当交易程序繁琐、厂商不实交易或是个人隐私信息外泄，这些在在都显示，要经营拍卖网站，必顸有强大又安全的信息技术、多元化商品与优惠营销服务…… 等。 面对的挑战 竞争程度高，必须要与各大甩卖网站竞争。 营销通路，商品运送成本分摊，满足消费者需求。 都属于交易平台，服务性质也相似。 有哪些优惠营销、信息取得和商品的价钱，能够吸引大众使用。 如何将此品牌知名度扩展开来等等。 潜在问题 面对一场新的金融革命，互联网金融蓬勃发展，其中就包含第三方支付。台湾目前提供第三方支付平台业者有『PChomeOnline的支付连』、欧13买尬转投资的欧付宝以及红阳、绿界与蓝新科技等，藉由「第三方支付」平台，买方可利用该平台提供的帐户进支付交易款项，经第三方支付平台通知卖家货款入账、并要求发货，最后买方签收货物后，第三方就可款项转账至卖家账户。现阶段只有Yahoo!奇摩的购物中心、PChome网络家庭等交易规模较大业者，较容易与收单银行洽谈刷卡业务，而其小规模网拍卖家，或是个人对个人的网络交易，仍无法提供信用卡交易服务，多半依赖转账交易，交易风险较大。 问题 互联网技术过于庞大：银行是行政性垄断，互联网是技术性垄断，互联网金融为二者的 结合，其垄断性更强。 互联网存在着另一种信息不对称问题：因为没有实际规范数据的真实性，其所使用的大数据、云计算、平台、移动金融等四大环结都没有实名制，亦即其所使用之信息缺少确实的依据，因此，其所引发的信息不对称所引发的问题可能更大。 在线与线下缺少一致性：一般而言，在线考虑的是违约率，线下考虑的是违约率与损失率，二者缺少一致性的规范，故其风险判断亦不同。 反洗钱问题在现行金融管制体系中，线下对洗钱问题有一定的管制模式，唯在线由于资金没有记号，都是数字所构成，很难加以 控管。 互联网金融的缺点 互联网金融犯罪难以预防：除了遇到与其他国家相同的网络犯罪和计算机病毒外，其他如电子 商务、互联网应用、有关软硬件知识等，其对目前已经建立的支付制度等出现后所涉及的责任认定、承担、仲裁结果的执行等， 其复杂的法律关系现在仍难以解决。 普及不易：网络技术日新月異，使用模式经常更新，并非人人可以使用，普及相对困难。 风险管理必须加强：网络的真实性难测，也难以有效控管，政府的风险管理尚不成熟。 尚未建立有效的监督制度:信息科技日新月異，新技术所引发的舞弊问题层出不穷，而监督 制度尚未形成独立系统。 七、五力分析1. 现有竞争者 竞争对手多，例如：Amazon 是最大网络零售商，起初由网络书店进入市场，目前产品项目包括书籍、影音产品、消费性电子产品、玩具、 家庭用品等。Yahoo 则是最大的入口网站。同样是拍卖厂商，在市场 中拥有多个厂商，所以竞争程度提高许多，例如：E-BAY、 PAYEASY……等。 2. 潜在竞争者的威胁 影响进入障碍的原因包括规模经济、产品差異化、资本需求、移转成本、绝对成本优势、范畴经济、营销不对称等，新进厂商的进入障碍 是属于高的。 3. 顾客的议价能力 PChome 在实务上透过一些优惠方案来提高使用者的转换成本以增加对于买者的议价能力。 4. 供货商的议价能力 供货商的力量并不大，对于网络拍卖商来说，有绝对不能当机的压力，其选择的供货商必顸具有一定的质量，所以供货商的议价能力也就相 对地降低了。 5. 替代品的威胁 网络拍卖的替代品为传统拍卖，传统的拍卖由于有地域、产品多样性的限制，以及必顸有实体通路成本，再加上买卖双方没有一个便利沟通的管道，因此传统拍卖对于网络拍卖的威胁并不大。网络无国界，因此消费者要更换网络拍卖网站并不难，甚至在其他国家也可以在线购买物品，因此其他拍卖网站的威胁也就大大的增加。","tags":[{"name":"学习","slug":"学习","permalink":"http://yangkunyi.com/tags/学习/"},{"name":"电子商务","slug":"电子商务","permalink":"http://yangkunyi.com/tags/电子商务/"},{"name":"网站分析","slug":"网站分析","permalink":"http://yangkunyi.com/tags/网站分析/"}]},{"title":"深层理解GET与POST","date":"2018-01-09T06:00:39.000Z","path":"2018/01/09/深层理解GET与POST/","text":"推荐文章中，再次理解了GET与POST。 GET与POST是HTTP请求的两种方式，每次谈到，不免都是想说这两者的区别嘛，之前自己也只是模糊的知道POST方法好一点，为什么，自己也只能回答一句，安全一点嘛，觉得说得太少了，于是去搜索了一下，以下是w3schools给出的答案： GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 说得真是有道理，没错啊，这就是区别啊，但是这样的答案大家背一背什么的就都会说了，但是这就完了吗？以上的自己都能理解，但是我觉得都只是现象，并不是原因啊！于是继续懵逼，直到看到下面的解释，自己好像慢慢开始理解了。 原文链接99%的人都理解错了GET与POST 既然说GET与POST是HTTP请求的两种方式，那什么是HTTP？ 学过一点计算机网络的我有点印象，但是也不记得官方咋说的了，于是借鉴一下别人的话： HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。 那既然HTTP的底层是TCP/IP，GET与POST自然也是基于TCP/IP咯，那GET与POST就是TCP/IP的两种链接方式了，那它们的区别到底在哪里呢？ 借助原文的比喻： 在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。 既然只是对传输数据的方式有要求，那关于参数的大小要求又从哪里来的？ 这就是“运输公司”——浏览器和服务器不同导致的，业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到。 现在，我知道了，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。这个时候我觉得标准答案的现象我都可以解释了。 紧接着，我又看到了一个令我目瞪口呆的区别： 简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包。 这是什么情况，我难道睡觉的时候老师讲重点了！！！？？？反正就是现在才知道这么重要的知识点。 好吧，了解之后明白了，GET在请求的时候会一次性将header和data发出去，然后服务器响应200（返回数据）；而POST会先发header，等到服务器响应100（continue）的时候再发送data，然后服务器返回200（返回数据）。 POST两次发送骤导致时间上消耗要多一点，那GET看起来就更有效了，于是Yahoo团队推荐将所有的POST请求用GET请求替换，以此来优化网页性能，无可厚非这可以达到一定效果，但很明显也是一个坑啊！ 为什么？ 存在即合理啊！（GET与POST都有自己的语义，不能随便混用。） 网速够快这点时间可以忽略（据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。），而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有“运输公司”（浏览器）都会在POST中发送两次包，Firefox就只发送一次。","tags":[{"name":"学习","slug":"学习","permalink":"http://yangkunyi.com/tags/学习/"},{"name":"web","slug":"web","permalink":"http://yangkunyi.com/tags/web/"},{"name":"GET","slug":"GET","permalink":"http://yangkunyi.com/tags/GET/"},{"name":"POST","slug":"POST","permalink":"http://yangkunyi.com/tags/POST/"}]},{"title":"WeeklyMind-7","date":"2018-01-07T15:39:16.000Z","path":"2018/01/07/WeeklyMind-7/","text":"期末周真的很崩溃，赶各种报告，还要复习，命天要考不动产管理和西方哲学史，不动产管理自己都快要放弃了，今天下午又整理出二十页pdf的知识点，也是选择随缘了，反正这个周就是很忙碌就对了，为了复习自己周末都去图书馆了，真是不敢相信！！！ 学习 web网页程序设计已经结课了，这个对有基础的自己来说，不难，也没有担心什么，成绩也在自己的规划之中。 行销管理的报告初步形态也基本完成，明天早起去把名片打印出来就行了。 再来是明天要考试的两门，脑子已经不够用了！ 周三的财务管理也算复习了三个单元了，但还是不算有底，主要是有一个数据不会算！！！这个问题要在明天和后天晚上的时间里面解决了。 最后周四还有一门课堂的期末报告，不过时间还够，所以不用太担心。 还有就是自己的博客有改一些个性化设置，更新了主题。 生活 明明前两天都还是清空万里，到考试就大雨滂沱，自己不太喜欢雨天，所以有点点影响心情吧。 这个周都睡得比较晚，生物钟感觉都已经变了，不过自己也能接受。 其实就是很普通的一个周，所以自己也想不起太多想写的东西。 待更进事项 走之前给自己写一封信 走之前给家里写一封信 思想报告 期末报告 联系老师商量考试安排 今天雨，可是我们在一起","tags":[{"name":"周记","slug":"周记","permalink":"http://yangkunyi.com/tags/周记/"}]},{"title":"西方哲学史期末复习","date":"2018-01-07T15:22:08.000Z","path":"2018/01/07/西方哲学史期末复习/","text":"明天期末考试，今天下午整理出来的复习资料，这还只是后半学期的，简直要疯了，最后还是佛系的选择随缘了！ 柏克莱著作 《视觉新论》（Essay towards a New Theory of Vision,1709） 《人类知识原理》（A Treatise concerning the Princeples of Human Knowledge,1710） 《西利斯和斐罗诺斯得三篇对话》（Three Dialogues between Hylas and Phlionus,1713） 存在就是被感知（柏克莱） 一切物体的存在都离不开能感知它们的心灵或者说存在于心灵之中。 贝克莱的命题。他站在经验论的立场上，对外物的存在不做断定，认为存在就是观念的存在，而观念的存在，就是观念的感知和被感知，即使没有人感知事物的存在，上帝的心灵也会感知它。从而否认了物质概念的实在性，承认了上帝的存在。 贝克莱的这一命题是肯定外物客观实在性的基本观点。按照这个命题，根本不存在任何独立于感觉观念的事物，所谓事物无非是被“心灵”实体感知的一组观念，事物和观念是同一个东西，它们的存在只在于被心灵所感知，这夸大经验中的观念，从而陷入了主观唯心主义。 像洛克一样，贝克莱认为人类知识的对象就是“观念”，而无论哪一种观念都只存在于能感知的能动的实体即心灵之中。换言之，认识的对象是观念，观念只存在于心灵之中，它们不可能离开心灵而独立存在，因此观念的存在就在于被感知。 既然观念的存在就在于被感知，那就意味着感觉事物的存在就在于被感知，因而一切事物的存在就在于被感知。因为“具有一个观念与感知一个概念是一回事”，“事实上，对象和感觉是一种东西”。所以，事物的存在就是被感知。 存在就是被感知在贝克莱那里是逻辑地从“物是观念的集合”这一命题中推演出来的。 休谟（David Hume）经验主义认识论：观念与印象1. 认识的起源：表象的分类 印象：强烈而活跃的直觉 对外：直接的感性直觉，如视觉、听觉 对内：直接的心里经验，如愤恨、喜悦 观念：基于先有印象然后产生的心里图像，念的产生有可能经过我们的组合和排序 2. 知识的边界在于观念能过回归印象可能的知识范围1. 经验主义只承认有两类知识 经验知识：建立于感性知觉基础上 数学与逻辑等知识：建立于概念关系的约定规则的基础之上的知识 2. 无法经验的东西 无法经验的动心，又不仅是涉及我们（主体之间）约定上的概念规则的话，则不可能有知识，例如关于上帝和所谓客观规则。 所以：数学观念对实际存在没有说服力（它们是分析的），反之，经验科学的观念对实在有说服力，他们是综合的。 休谟的激进经验主义 我们只经验到不同的感觉印象，却没有什么背后的「实体」，去「承载」这些印象。 这些感觉印象会以恒常群组的方式出现，我们所说的桌子、椅子，不过就是这些群组本身──而不是背后的什么东西！ 同样，我能把握的仅仅内部印象，当中有些恒常稳定成出现，但幻想背后有一「自我」，实是形而上学幻觉，一种习惯的联想 休谟的知觉 现代哲学一般接受某种观念理论 (theory of ideas)：认为思想直接对象的是某种心灵之内项目或观念，而不是外在的物理客观。休姆统称观念之为「知觉」(perceptions)。 印象：包括各类感觉 (sensations)，也包含欲望 (desires)、情感 (passions)、情绪 (emotions) 等。 观念：则是印象「在思想与推理中的模糊影像 (faint images)」。 观念和印象的关系：摹本原则（简单印象总是先于简单观念） 因为感受 (feeling) 与思想 (thinking) 的差别是清晰的，故此印象与观念之分别亦然。(例当下吃柠檬塔的味觉 vs 记得上周吃过的味道)。 印象 感觉印象：感觉印象或称为「原初印象」 (original impressions) 。它们包括通过五官而得到各种感觉，以及痛感与快感 (pains and pleasures)。它们之所以称为「原初」，是因为它们是思考不可再回溯的始点，要再探究它们的原因，我们便会跨出经验以外。 反思印象：反思印象则包括欲望、情绪、情感等等。本质上，它们是心灵对于观念之反应，故此对比于原初印象，休姆称之为第二序印象。例如：对于去年患感冒的记忆是观念，它是去年的原初印象 (患流感的感觉)之影像。此时记起这段记忆，让你感到「害怕」 这年秋冬还会患上流感、「希望」不会再患上流感，等等。 观念之间的关系 联想关系 思想内容的心理连结，一者引起我想到另一者。 休姆自许为首位对「联想原则」作系统分类的哲学家。 分三类联想： (1) 相似 (resemblance)； (2) 时空连续 (contiguity in space and time)； (3) 因果 (causation) 。 例子： (1) 画作及其所描绘的主题实物； (2) 提及房子的大门入口，想起它的玄关； (3) 想到一个伤口，想起它带来的疼痛感。 知觉分类 简单的：黄、酸、香味，等等。 复合的：复合印象由简单印象组成，例如「柠檬」的印象 = 黄 + 酸 + 柠檬香味，等等。这些个别的印象是简单印象，因为它们没有组成部份。 印象与观念之别在于力度 (degree of force)或活泼度 (degree of vivacity)。印象比观念更有力、更鲜明与活泼。(休姆没有完全满意这个区分的规定方式) 休谟对因果论的批判 休谟指出，当我们讨论因果时，我们认为： 某现象随另一现象而来。→ 相继性 两个现象间有接触。→ 接触性 随接触而来的现象必然发生。→ 必然性 但我们能否真的知道上述3点？ 休谟：我们能知道1 与 2，但不能知道 3！ 对因果论批判的回应 我们透过归纳法，一再重复的现象关系，使我们可推论出因果关系。 休谟：只能知道迄今现象关系确是如此，不能说我们知道其确是如此，而且将会如此。 归纳法与自然科学过往成功显示这类推论有效而可堪继续使用。 休谟：此论诉诸自然齐一观，但自然齐一若非归纳，便为形上假设。 若非出于归纳推论，因果概念从何而来？ 休谟：因果概念不过是我们的心理习惯或心理预期。 康德著作 《纯粹理性批判》(Critique of Pure Reason, 1781, 第2版 1787) 《未来形而上学导论》(Prolegomena to Any Future Metaphysics, 1783) 《道德形而上学原理》(Groundwork of the Metaphysics of Morals, 1785) 《实践理性批判》(Critique of Practical Reason, 1788) 《判断力批判》(Critique of Judgement) Pure Reason, 1790) 《单在理性范围内的宗教》(Religion within the Limits of Reason Alone, 1793) 〈永久和平论〉(“Perpetual Peace”, 1795) 康德哲学的定位 一般定位：启蒙运动的哲学代表，理性主义与经验主义的集大定者。 理性主义的立场： 心灵拥有天赋观念 (innate ideas)。 只需以理性分析与思想相关的观念，我们便可掌握世界之真相(至少关于最重大议题之真相，例如灵魂是否不朽，上帝是否存在，意志是否自由等等)。 以数学、逻辑为知识典范 代表人物: Descartes, Spinoza, Leibniz 经验主义的立场： 并无所谓天赋观念，一切观念皆经由经验习得，人的心灵是生而如「白纸」(tabula rasa)，不存在先有的蓝图、内容或架构。 一切知识，皆来自经验；知识之建立有赖于有方法地对自然进行考察。 以自然科学为知识典范 代表人物： Locke, Berkeley, Hume 批判（康德） 康德的批判是指：根据理性具有普遍必然的科学知识对理性的一般认识能力进行分析，通过分析来确立一种衡量知识是否科学知识的一般标准，然后以此来衡量形而上学的命运。在当时，批判的含义首先是针对莱布尼兹-沃尔夫体系提出的，其次，它还要通过对不依赖经验因素的纯粹理性的批判，为数学、自然科学提供哲学论证，同时又限制理性的活动范围，为宗教信仰保留地盘。 （PPT）所谓「批判」不是指单纯的「批评」(criticism)，而是指： (1) 限制、划定界限论域的有效范围； (2) 有别于对论域有效性的「朴素」(naively)接受，对其进行反思，阐释其构成原则。 判断上的线索 给定了完整具体的经验是命题性的，那么，表达命题的判断即可成为探索经验超验条件的线索，包括：先验综合判断的线索 综合判断 vs. 分析判断 (主谓概念的分析与非分析的关系──「清华大学男多女少」vs. 「三角形有三只角」) 经验综命判断 vs. 先验综合判断 先验综合判断的例子：「两点之间最短者为直线」、「凡变化均有原因」 非经验字词的线索 (例如「有些」、「和」、「或者」) 判断逻辑形式的线索 ( “S is P” 的量、质、模态与关系的可能变化) 简述康德的“先天综合判断”理论。 康德为了解决经验知识的普遍必然性问题而提出了“先天综合判断”理论。康德认为，知识的基本单位是判断，一种是分析判断，一种是综合判断。分析判断的宾词蕴含在主词当中，具有普遍必然性，但不能给我们提供新的知识，经验知识属于综合判断，宾词不包含在主词中。具有普遍必然性的经验知识必有两个来源：感官提供的后天质料和头脑中固有的先天认识形式。具有这种特征的判断称为先天综合判断。先天综合判断的命题可以分为三类：数学命题、自然科学命题、形而上学命题。 超越 「超越」与「经验」相对，指关于经验可能性的先验条件(超越哲学即关于这些条件之严格学问)。 康德的哥白尼转向 自然科学的哥白尼革命：从地心说转向日心说。 康德哲学的哥白尼革命：从表象实在论 (representational realism) 到转移超验论 (transcendentalism) 表象实在论：认知主体受客体影响而产生表象，进而产生对象性知识 (观念)。 超验论：客体是因为经受主体先行的安排与整顿，方能树立为对象性，故此对象依赖于主体的经验与思维方式。 康德 VS 休谟 休姆的正确洞见：知识起源于经验，而单是感性经验的管道本身无法提供「必然而普遍有效东西」；诉诸个殊感性所接收的内容无法说明因果性。 休姆的错谬：因为感性经验管道无法说明因果的来源，故此因果性无客观有效性，只是主观的心理习惯。 休姆的假设：经验只是零散的、无秩序的材料之累积和收集而已。 康德：经验一旦发生，便总已具有普遍有效的秩序；经验是「命题性」的。(我们的知觉经验所相对的是事物、对象，以至整全的事态，而并非在一堆零散的「杂多讯息」之堆积。) 超越的三性 康德的超越论的设定：这些既存于经验的秩序是由认知主体的不同机能所赋予，这些机能包括：(1) 感性 (sensibility)；(2) 知性 (understanding)；(3) 理性 (reason)。 感性（康德） 感性是指主体自我借助于感性经验而形成的感性直观知识的先天认识能力，包括两个方面，一是经验直观，一是纯直观。前者是后天的质料，后者是先天的形式。感性的先天形式是空间和时间，感性与感觉经验结合后形成数学知识。 知性（康德） 知性是指主体自我对感性对象进行思维，把特殊、没有联系的感性对象加以综合，并且联结成为有规律的自然科学知识的先天认识能力。知性的先天认识形式是知性纯概念，即“范畴”。用这些范畴把感性知识结合起来，使其具有一定的形式，成为知识。知性与感觉经验结合形成自然科学知识。 理性（康德） 理性指在经验中无法达到的知识的完备性和无条件性，即要求认识世界、灵魂和上帝的认识能力。理性是认识的最高阶段，要求认识自在之物本身，获得关于世界的绝对认识，即理念。但是理性自身没有先天形式，只能借用知性范畴。但用认识有限对象的知性范畴去把握无限对象，理性必然陷入不可解决的矛盾，因此形而上学是不可能的。 超越的演绎 「超越的演绎」(transcendental deduction) 的目标是透过阐明感性的直观形式和知性的先验范畴构成对象性经验的程序，显示这些先验条件的有效性。这个程序涉及三个层次的综合： a) 直观之统握 (Apprehension in der Anschauung; Apprehension in the Intuition)：初步赋予感性摄取回来的杂多资料一个时空秩序的形式，如时间上的共时与相续。 b) 想象力的再造 (Reproduktion in der Einbildung; Reproduction in the Imagination)：将直观逐一经历者重新呈现，并使之合成为一个统一的「意象」。 c) 知性概念之重认 (Rekognition im Begriff; Recognition in the Concept)：依据先验概念，将已被直观统握和想象力再造的杂多，确认之为某物的表象。 超越演绎描述的是一个互相协调下的广义思考活动，背后统一的思考者即某个超越的、形式性的、主动的「我」(I)，称为超越统觉 (transcendental apperception)。康德认为，正因为我的所有经验皆过此超越的我之统觉思考，故「我思」总是能够伴随着一切我的表象的。 知识的消极批判：有效知识的限度 现象学 (phenomenon) 与物自身 (thing in itself) (或「智思物」(noumenon))的区分。 具体判准：现象为知性(概念)与感性(直观)协作而成；任何无法感性直观给予的对象，我们对之皆无法建立积极的知识。 二律背反(antinomy)及独断形上学的谬误。例如「世界是有限/无限」；「自然因果性以外还有自由的因果性/ 自然因果性通贯决定一切」。 二律背反 (antinomy) 显示独断的形上学是不一致的，因为它们涉及一些超出感性经验以外的事情。 二律背反的积极价值：时空实在只是现象，自由即使不容于现象，也不代表它不能是某种实在。 经验的实在论 (empirical realism) ：对于可直观呈现的经验对象来说，时空、范畴等先验条件皆为构成「实在」的一环。 超越的观念论 (transcendental idealism) 对于无法直观的、超离于感性经验以外的事物来说，时空、范畴等不过是观念 (一些虚的想法)，我们无法针对它们建立积极的知识。 伦理学理性主义 VS 经验主义 理性主义：有些根本的道德观念和原则是天赋或先验的，我们可透过理性反省来掌握它们──就如我们可以透过理性反省我们的推理行为，而获得一些先验而普遍有效的逻辑观念与逻辑原则。 经验主义反之认为，道德只是偶然的人性与欲望的产物，例如Hume 认为，道德是基于同情共感 (同情心)，而同情心是人性偶然的产物，若人性不同，人便可能有不同的欲望与感情，由此也会有不同的道德原则。道德原则只是偶然的经验原则，而理性只是满足欲望与情感的手段。(理性是也应是情感的奴隶！) 康德伦理学立场 道德之基础是理性而非偶然的人性欲望与情感，道德原则是必然而非偶然的。否则无法解释道德的特殊规范力：它对所有理性存在者之行为皆普遍有效。(我们不但要求人应当公正、诚实、尊重他人、保护弱者，等等，而是任何有理性者皆当如此！) 当然，道德也需实践，但要策动实践道德原则之行为，我们所依赖的不是偶然的欲望，而是理性的意志。 针对道德领域，超验哲学的反思要阐明的是：纯粹理性自身如何可能是实践的。 实践理性与道德原则 对于康德来说，人类实践之理性表现在于它是在法则意识下的行动。(依法则行动 vs. 依法则表象而行动)有限实践理性与道德规范力或强制力：义务 (Duty, Pflicht) 的优先性。 令式与两种应该： 假言令式 如果要减肥，你就不应该在晚上吃很多。 定言令式 不应该滥杀无辜。 康德认为，真实的道德是为道德而道德，或为义务而义务，故其相应的令式为定言令式。 道德原则即为可普遍化原则 康德认为是有的，他同样也称之为定然令式(狭义)。 康德对之有几组不同的表述，其中一组强调普遍化，为了辨识之故，我们可以称之为「普遍化原则」(Principle of Universalization)： 「仅据如此格准 (maxim) 行动，即你能同时意愿之成为普遍遍法则。」 (「格准」是康德的术语，意指主观的行动原则。) 「可普遍化」这个判准告诉我们甚么可以做(道德上容许的)，甚么不可以做。 栗子： 许假承诺（自我矛盾，因为之所以许诺就是为了未来能够达成） 即使有能力，也不要帮助他人（意志上的矛盾） 普遍化原则所表达的道德观念 道德上对的行为，即某意义上合理的行为。 理性的特征是普遍的，在道德上合理，即行为在某意义上是可以普遍化的。 为此，我们要检讨某个行为是否道德上正确与否，便应建立一套程序，显示如何可在普遍的观点下考察该行为，并尝试阐明，符合什么特征时，该行为才是合理的。 检测流程： 第一阶段：主观原则（陈述行动背后的标准） 栗子：每当我需要的时候，我就许假承诺。 第二阶段：陈述行动的客观原则 栗子：每当任何人有需要的时候他们都许假承诺。 第三阶段：按能否普遍化或其它标准，判定行动在道德上是否允许。 对普遍化原则的批判 Anscombe 的反驳 ：只要加上恰当的条件，说谎便可容许，例如，「若旨在拯救无辜，说谎也无妨」以乎可以普遍化。 回应：我们无法肯定知道行动的结果──例如以为说谎可救忠良，免其受暴政追捕，但却有可能阴差阳错，导致无辜者陷入罗网──，但却肯定知道行动有无违反义务。故此，我们理当行其义不计其功，避免因任何后果计算，违反已知的道德义务。康德认为，既行其义，我们便以尽了自己的责任，致于行动后果是否美好，也不是我们的过错。(因为此点其实我们无法肯定的)。 Rachels 的反驳：康德认为，我们须为说谎行为的坏结果负责(例如误让无辜者被捕)，但却不需要为说真话的坏后果负责？──这并不合理。 三个表达式 自然法则原则 (Principle of the Law of Nature)：「如此行动，宛如藉由你的意志，你的行动格准变成普遍的自然法则。」 目的原则 (Principle of Ends)：「如此行动，致使无论是在你自身人格中的或是其他人的人格中的人性，皆被当作目的而非仅当作手段 (means) 看待。」 自律原则 (Principle of Autonomy)：「如此行动，致使你的意志藉由自身的格准，能够同时自视为在制订普遍法则。」 道德行动的预设 道德行动有三个设准 (预设)(postulate)，这些设准之实在性不能被证明，但却对实践生活极为重要： 自由意志：「意志独立于任何东西，而仅仅遵从道德法则」→ 自由意志是「拱心石」。 灵魂不朽：实现 summum bonum 至善即德福一致的预设。 上帝：实现 summum bonum 至善即德福一致的预设。 美学审美与反思判断 审美能力依于判断能力 (power of judgment) 判断能力的一般性格：将个殊 (particular) 隶归到普遍 (universal) 判断力有两种： 决定式判断力 （determinant judgment）：先有「普遍」，再将它应用到特殊之上。 反思式判断力（reflective judgment）：先面对特殊各物，而找一些普遍原理来涵盖。 反思式判断力的特点： 愉悦感：发现规律去涵盖纷杂现象时，自然会产生。 自然的合目的性：寻找普遍律，即预设有「律」可寻找，而假定自然界具有某种规律或是事先设计的秩序一样。 审美判断的特点 康德把「审美判断」包含在「反思判断」中。他没有明确解释原因，但主要有三个要点可说：美的欣赏一样要面对一些杂多的现象，并加以反省或观照。 一样涉及「合目的性」这个原则，虽然于此是所谓「主观的合目的性」。 会涉及「某种快感」，而且感受就是判断的基础。 我们说某物为「美」时，我们往往虽只诉诸我们对该物的感受，但仿佛又将「美」当作事物昭明的客观性质，要求每个(有品味的)人皆能辨察。以康德的术语说：审美判断具普遍有效性(universal validity)，它们具有某种「必然性」(necessity)或在某程度上是「先验的」(a priori)。 判断力批判的任务 笼统来说，《判断力批判》(Critique of Judgment) 的主要任务对人的判断能力作超越的分析，以阐明「审美判断」与「目的论判断」是如何可能。 就美学而言，《判断力批判》要说明的是：单纯依主观的基础(审美的愉悦感)而判定某物为美，但同时要求此判断被普遍认同──这如何可能？ 美感缘何能够成普遍有效性的基础？ 审美判断力的分析 品味判断： 性质 (Quality) 数量 (Quantity) 目的关联 (Relation of the Purpose) 模式/模态 (Modality) 美的性质 就性质而言，「美」是一种愉悦的感受，而审美判断则相应是主观的，其基础消极来说不在于对事物的概念性的知识，而是在单纯的观看 (contemplation) 中得感受到的愉悦或不愉悦感。(康德认为实践上的好坏是概念性，审美上的美丑则不然)。 纯粹的审美判断必须是无「利害关心」的 (disinterested)，我们审美时不但悬搁我们的知识兴趣、欲求与道德意愿，我们甚至不关心对象是否实存。(因此美食往往不是纯粹的美，美色亦然。) 在质上，康德的总结性论断如下：「鉴赏力/品味能力是通过不带任何利害的(without interest)愉悦或不悦而对一个对象或一个对象的表象方式作评判的能力。一个这样的愉悦的对象就叫做美的」。 审美判断的量 康德就「量」方面的主要论断是:「凡是那单个没有概念而普遍令人喜欢的东西就是美的」。因为审美愉悦完全脱离于个人的个别需要和欲望，所以它具有某种独特的普遍性。单个：在对象的量上，审美判断和关于感官快适的判断一样，严格而言都是针对眼前某个个殊东西的判断。(「这朵玫瑰是漂亮的」；「这块蛋糕很好吃」) 无概念而普遍：但两者有一点关键的不同：在判断感官快适时，我根本上就我个人而言而下判断的(例如别人可以认为这块蛋糕太甜或太淡或太多奶油而不爱吃的)，反之，判断对象美与不美时，主体却不是单为了他本人，也同时是为所有人下判断的。 基于概念而产生，事实上，康德认，纯粹审美判断全部的如上所说，审美主体要求所有人都认同他的判断，但这种普遍性不是「客观关涉」都只是仅在于眼前这个不能被概念化的、独一无二的现象。 审美判断的关系 关系: 「美是一个对象的合目的性之形式，如果这形式是没有一个目的的表象而在对象身上被知觉到的话」。审美判断是以美感为基础，而美感是一种快感。然而快感之所以产生，当中应涉及某种「适然的」状况：应该是由于审美对象在某个意义下对我是「适然的」，故此我才会感到愉悦。可是上述分析已指明，审美快感并非出于满足于我的某种特殊的感性欲望或理性欲望，那么它是之所适是适于什么东西？康德认为，既然美感是单纯因为观照而产生，那么美感之所适便是适于人的知觉，故此单从品鉴审美对象，便能产生审美的愉悦。用现代的术语来表达审美愉悦的基础可说并不在于知觉对象的某些实存的性质，而是在于审美知觉活动 (perceptual activity) 本身的特殊方式。﹝犹如游戏的愉悦不在于其对象，而是由游戏活动本身一般。﹞ 审美判断的模态 模态:「那没有概念而被认作一个必然愉悦的对象的东西就是美的」。 审美判断判定某物必然带来美感的愉悦，但这种必然性之基础不在于某种依于概念上的推证的必然 (apodeictic 的必然性，而是exemplary (展示某不可明示的规则) 。 康德以为，审美判断的主观普遍性的基础，最终在于共通感 (sensus communis。 审美判断的第四个特点是其「模态」上的必然性：品味判断基于审美愉悦感，康德的分析将这愉悦感归因于审美主体内部的超验认知能力之和谐游戏，因此，审美判断所隐含的普遍有效的宣称便有一先验的基础。此先验基础使对象的美感有着某种「必然性」(每个人皆应该认同我的判断，皆应该感到此对象之美)，但这种必然性不是按照明确规定的法则而树立，而只是「主观的」或「典范性」(exemplary) 的。 康德说，这里的「典范性」是指「所有人皆须同意某个判断的必然性，此判断是被视作某个我们无法表明的普遍法则之范例」。 德国观念论背景 德国观念论是德国后康德时期哲学的主流，在18世纪末、19世纪初盛行。以批判地承接康德为特征，与启蒙运动 (the Enlightenment) 及浪漫主义 (Romanticism)，密切关系。 代表人物 德国观念论主要有三家，按其照跃时候，费希特 (Johann Gottlieb Fichte)、谢林(Friedrich Schelling)及黑格尔 (Georg Wilhelm Friedrich Hegel)。 费希特著作 《试论一切天启之批判》(Versuch einer Kritik aller Offenbarung) 《全体知识学之基础》(Grundlage der gesamten Wissenschaftslehre) 《自然权之基础》(Grundlage der Naturrechts) 《伦理学体系》(Das System der Sittenlehre) 费希特 VS 康德 自认承接和「忠于」发展康德学说，认为康德哲学有两个漏洞或不足： 物自身的假设 (独断论 (dogmatism) 的假定) 理论理性与实践理性之分离 费希等眼中，康德的基本洞见为：实践理性至于理论理性之优先地位；自由为理性的事实。 舍弃「物自身」(Ding an sich) 概念，而由「我自身」(Ich an sich) 为绝对基点出发，建立一元的主观观念论 (subjective Idealism) 费希特的基本进路： 消除独断论，建立彻底的观念论。 以绝对自我为始点的主观观念论，整合理论理性与实践理性(两者为同一自我的两种表现)。 我自身 (绝对自我) 为始的存在模式： 消极：自我  物、客体、对象、实体。 积极：自我在于「活动」、「行动」(Handlung)；其为「即活动即存在」，「事行合一」(费希特称之为 Tathandlung) 。 独断论与观念论争议无法在理论上终极解决──它是「倾向与关心」之争：「最高的关必或即其他关心的根据，乃是对我们自己的关心。哲学家的情形亦然。」「一个人选择何种哲学，端看他是那一种人。」 知识学 主观观念论以自我之事行为根本原理，演绎其他一切。 自我（费希特） 费希特反对康德通过设定自在之物为经验寻找依据，而认为全部经验的根据就是“自我”。“自我”查知经验客体而不依赖于经验客体，自我通过主体的自我反省建立起来，通过绝对自我的理智觉察主体的存在。自我没有规定，没有限制，没有间接认识，是一种直觉。 （PPT）费希特所谓的「自我」，乃绝对自我 (das absolute Ich)，而并非经验心理学意味的个别的人。绝对自我乃康德的超验统觉，并揉合笛卡儿的「我思、我在」，去掉后者的实在论假定之形上学化概念。(「我在」是第一序的，而我思则被理解为超验的、建构性的思想) 三个建立客体知识的原则 第一原理： 自我设定自身：所谓「设定」(setzen, posit) 是指在意识中确立起来。自我设定自身即意识中确立自己的存在。对应于 “A = A” 的命题，为绝对无条件的原理。 第二原理： 自我设定非我。费希特认为此对应 “~A ≠ A” 的命题，由于否定性 (「不是」)并非衍生自肯定性(「是」)，故此设定非我的事行也是一形式本原的行动，只有内容上有预设 (非我以「我」为前提)。 第三原理： 自我在自身中设定一个可分(割)的非我与可分(割)的自我相对立。 第三原理以先行两个原理为基： 非我是自我的否定，但因为我是建构性的，也是非我的设定者、没有自我就没有非我。(非我既不是我，但又是我) 于是在一定程度，我与非我、A与~A、实在与否定虽要结合起来。 第一原理中的自我是无条件的绝对自我；第二原理中的自我是受非我限制、与之对立的有条件自我。故第三原理所表达的是：有条件的自我与有条件的非我相对立，但两者皆从属于绝对的自我。 费希特认为，第三原理即知识的最高的综合 (以绝对自我综合主客关系)。 谢林著作 《超验观念论体系》(System des transcendentalen Idealismus, 1800) 《哲学与宗教》 自然学说 自然哲学中的自然：并非自我设定的对象(非我)、整体、内在的动力结构与普遍原理，自然之为自然的条件。 自然哲学 = 思辨物理学 (speculative physics)。 自然并非与意识、理智对立，它不过是暗哑和尚未成熟的理智。(谢林的构想与唯物刚巧相反：把自然还原为初阶的精、理智。) 自然哲学即旨在显示，自然发展如何使得主体渐渐出现，并勾勒从「质料」、「无机物」到「有机物」至最终出现精神的过程。 这个发展的逻辑，谢林以「对立统一」表释之。 对立统一的例子 质料层次：引力与斥力。引力表现客观、物质、自然；斥力表现为主观、自我、精神性。二种力物质和精神的共同基础，引力把外在世界的运动变化凝聚到内在的感觉世界，构成我们的内部经验，谢林以之配对时间的先验基础；斥力则是向外在世动，构成外部经验，是空间的先验基础。 二元对立和统一推动着无机领域向有机领域的转化。谢林以为电、磁现象即此转化的关系。自然哲学中的自然：并非自我设定的对象(非我)、整体、内在的动力结构与普遍原理，自然之为自然的条件。 同一性哲学 谢林是以费希特为始点而发展出自己的思想道路的： 预备时期 (1797)：完备费希特的「知识学」而发展自然哲学(自然哲学作为超验哲学的一个补充部份) 第1期 (1799)：以「自然哲学」冠名自己的思想，以之与康德的批判哲学及费希特的知识学相对比。 第2期 (1800)：发表《超验观念论体系》，并举自然哲学与超验哲学两部份，合构成「同一性哲学」。 同一性哲学的观念：知识学的最高原理 = 自我 = 主观的主客合一、自然哲学：客观的主客合一。完全从绝对本原出发：主客绝对的同一 (尚未分离意义的同一)。 （立场）费希特 VS 谢林 相同点是克服康德的超验哲学的主客体分离的二元框架，贯彻观念论的立场，质疑越出建构性主体以外的「物自身」的设定。 费希特：以主体收摄客体，客体只是主体以内所确立的「非我」。 前期谢林：以自然哲学 (把主体视作自然本身的发展的目标) 补足费希特的主体观念论 (把客体视作主体的观念)。 后期谢林：追溯前于主客体区分的「绝对者」、「同一者」，其表征及掌握超出概念思维以外，或诉诸艺术直观，或诉诸宗教体验。 费希特可说是超验哲学化的笛卡儿主义，而谢林则是超验哲学化的史宾诺莎主义。 黑格尔著作 【处女作】《论费希特与谢林哲学体系的差异》(1801) 【生前出版（书）】《精神现象学》(The Phenomenology of Mind) 【生前出版（书）】《逻辑学》(Science of Logic) 【生前出版（教材或讲义）】《哲学全书纲要》(Encylopedia of the Philosophical Sciences in Outline) 【生前出版（教材或讲义）】《自然法与政治学纲要·法哲学原理》(Natural Law and Politics in Outline. The Principles of the Philosophy of Right) 柏林时代的遗稿：（整理的课堂笔记） 《历史哲学》 《美学》 《宗教哲学》 《哲学史》 思想特点 古典基础： (1) 存在与思维合一的构想 (Parmenides, Plato)； (2) 概念或观念的存在论意味 (Plato, Aristotle) 近代基础：康德至费希特、谢林一脉的德国观念论发展。 注重哲学思想及其课题的历史性与社会文化脉络 (“philosophy is its own time apprehended in thoughts“)。 有别于谢林只追溯(超验)哲学的前历史，黑格尔也描述其后续的历史发展之逻辑与目的以辩证法取代演绎法，以之为：(1) 哲学方法；(2) 存在本身的逻辑 康德基础上的黑格尔 就如其他德国观念论者一样，黑格尔也是以康德的超验哲学中的主客对立(我与物自身的分离)为思考的始点：物自身意味，知识与对象有「差距」： (1) 要么是指经验意义或一般； (2) 要么是指超验的意义 (康德的问题, transcendental gap) 若 (1) ，则只涉及知识(思想)调节，务求思想与现实吻合的问题。但若 (2)，则黑格尔认为，同样理应调节思想，以便吻合于现实，形成超验知识。只是问题是：此时的思想是超验的、建构性的思想。故此…… 调节思想便同时意味以新的形式建构它的客体 (产生新的transz. gap)，原来的物自身(「自在之物」)变成对象，但同时又产生新的「自在之物」 思想 – 知识 – 对象 – 自在物 乃一串连动的环节，调节一者则整系列皆有改变。 例子：《精神现象学》的感性确定 结论： (1)知识与对象间的落差会推动知识自身的发展，但对象与自在物也同时会变化； (2) 调节思想以与实在一致，此历程称为辩证法。 辩证法 (Dialectics) 原意：对话，即人际的现象→ 哲学转化 (柏拉图苏格拉底传统)：心灵的自我对话，以趋向真理的表述 (定义)的历史 黑格尔的转化：D. = 主体思想与客观实在的共同规定。 辩证法的历史 古典的辩证法： (1) Heraclitus的自然辩证法； (2) Zeno 的论辩的辩证法； (3) Socrates的对话的辩证法。 近代的辩证法：康德的消极的理性辩证法 (二律背反) 辩证法的层次 哲学思想与心理学层次：D. = 思想/认识的发展逻辑 (如正题、反题、合题) 存在论层次：D. = 思想(观念) 与实在融合的过程：一方面，实在观念化、思想化；另一方面则是思想的实在化。最终达致，思维与存在合一，「凡是现实均为合理，是合理的均为现实」 宇宙论层次：为精神实体自身发展的逻辑，从目的处回头考察各个阶段的合理位置与意义 。《精神现象学》考察从最个殊具体(感性意识)至普遍(绝对精神)的辩证发展；《逻辑学》则考察从最普遍 (存在一般) 至最个殊的概念之辩证发展。 黑格尔的辩证法 辩证法的基本运动：否定性 但辩证的否定性是具体的否定性，不是虚无主义的抽象否定 (negation as negation of…)辩证的否定，黑格尔以德语 “aufheben” (扬弃) 表述其特征，即 (1) 否定、终止； (2)保持； (3) 提升； 辩证法的例子例一：《逻辑学》的最初三个概念 正题：存在 (Being) 反题：无 (Nothing) 合题：变化 (Becoming) 阶段之间不是逻辑蕴涵关系，而是某种思想的必然发展。 例二：《精神现象学》的主奴辩证 自我意识须通过他人的自我意识而成为自身 阶段1：物化他人，显示只有自己是「主」(例如战争、暴力中以消灭他人为目的)。 阶段2：奴役他人 (留其命以事奉自己)，被「承认」的主体。 阶段3 ：主奴的依从地位颠倒 主人因为过于依赖奴隶，最终丧失自主的能力。 奴隶反因通过生产与制造，意识自己能够改造世界的独立主体能力。 辩证法的原文 § 130Being is the indeterminate immediate; it is free from determinateness in relation to essence and also from any which it can possess within itself. This reflectionless being is being as it is immediately in its own self alone. § 131Because it is indeterminate being, it lacks all quality; but in itself, the character of indeterminateness attaches to it only in contrast to what is determinate or qualitative. But determinate being stands in contrast to being in general, so that the very indeterminateness of the latter constitutes its quality. It will therefore be shown that the first being is in itself determinate, and therefore, secondly, that it passes over into determinate being — is determinate being — but that this latter as finite being sublates itself and passes over into the infinite relation of being to its own self, that is, thirdly, into being-for-self. § 132Being, pure being, without any further determination. In its indeterminate immediacy it is equal only to itself. It is also not unequal relatively to an other; it has no diversity within itself nor any with a reference outwards. It would not be held fast in its purity if it contained any determination or content which could be distinguished in it or by which it could be distinguished from an other. It is pure indeterminateness and emptiness. There is nothing to be intuited in it, if one can speak here of intuiting; or, it is only this pure intuiting itself. Just as little is anything to be thought in it, or it is equally only this empty thinking. Being, the indeterminate immediate, is in fact nothing, and neither more nor less than nothing. § 133Nothing, pure nothing: it is simply equality with itself, complete emptiness, absence of all determination and content — undifferentiatedness in itself. In so far as intuiting or thinking can be mentioned here, it counts as a distinction whether something or nothing is intuited or thought. To intuit or think nothing has, therefore, a meaning; both are distinguished and thus nothing is (exists) in our intuiting or thinking; or rather it is empty intuition and thought itself, and the same empty intuition or thought as pure being. Nothing is, therefore, the same determination, or rather absence of determination, and thus altogether the same as, pure being. § 134Pure Being and pure nothing are, therefore, the same. What is the truth is neither being nor nothing, but that being — does not pass over but has passed over — into nothing, and nothing into being. But it is equally true that they are not undistinguished from each other, that, on the contrary, they are not the same, that they are absolutely distinct, and yet that they are unseparated and inseparable and that each immediately vanishes in its opposite. Their truth is therefore, this movement of the immediate vanishing of the one into the other: becoming, a movement in which both are distinguished, but by a difference which has equally immediately resolved itself. 三位哲学家的观念比较洛克 表象实在论：实际有那么一个东西，然后心里才有这样的观念。 柏克莱 存在即被感知 休谟 既无物理实在，也无精神实体 结构图 考试题预测复习印象与观念（休谟） 休谟提出一个命题：“除了知觉，一切都是不可知的。”在论证这一命题时，休谟把感觉经验叫做知觉，认为知觉可分为印象和观念。进入心灵时，最强烈、最活泼的知觉是印象，包括感觉、情感和情绪；观念则是感觉、情感和情绪在思维和推理中的微弱的意象。印象又可分为感觉印象和反省印象两种，而感觉是观念和反省印象的基础，观念则是感觉印象的精神的表象。观念可分为复合观念和简单观念，复合观念则是简单观念的集合或复合。 观念联想（休谟） 休谟把感觉经验统称为知觉，然后又把“知觉”分为“印象与观念”。观念区别于印象，是由于它们具有较低程度的“生动性和强烈性”。又因为一些观念以某种未经解释的方式，带着印象的生动性与强烈再现，或者，“产生”了他所谓的“反省印象”的“新印象”。因此，反省是从感觉派生的。一切事实（知觉）都从感觉派生，而感觉印象来源于不知道的原因。简单观念之区别于简单印象仅仅是由于它们比较缺乏生动性和强烈性。通过这种“观念联想”就形成了关系、情状和实体的复杂观念。 简述休谟的因果关系理论。（休谟） 休谟坚持人们只能在经验的范围内研究因果性的问题。他认为在经验中，我们关于因果关系的观念是从对象间的某种关系得来的。首先，人们看到两个对象之间的接近关系，因此只有在时间上和学问上接近的东西才能相互作用，其次，人们看到两个对象在时间上的先后关系，因先于果，果接续因，接近关系和接续关系是我们形成两个对象之间因果关系的必要条件，但还不能由此提出一个完善的因果性观念，即两个对象之间必须存在着必然的联系。这是因为，观念即对象总是特殊的、各别的。我们从经验中最多只能看到两个对象之间的接近或接续关系，但是，我们永远看不到它们中间有任何纽带”，即必然联系，看不到原因中存在着某种必然产生结果的能力。休谟认为，原因和结果是两个根本不同的东西，二者之间不可能存在什么必然的联系。人们之所以觉得因果之间有着必然联系，是因为这种观念是从对象的恒常会合中引出来的，是对象恒常会合在人心中形成的一种习惯。 休谟怀疑论思想述评。 休谟认为人通过感性知觉只能知道经验中一些表面的个别的现象，超出这个范围的事物的性质、本质、内部联系等等都是不可知的。他拒绝回答知觉的起源问题。他说：“用什么论证可以证明，心灵的各种知觉，一定是由一些虽然与他的相似，但是与他们完全不同的外物引起的，而不能由心灵本身的能力，或者由某种我们更不知道的其它原因产生呢？对于这个问题，经验是没有什么话可说的，也必须完全保持沉默。在心灵前面主观的，除了知觉以外，是根本没有别的东西的，它绝不能经验到知觉与对象的联系。因此，我们假定这样一种联系，是没有任何根据性的。显然，休谟拒绝回答感性知觉是由物质还是由精神引起的问题，实质上是拒绝公开回答哲学的根本问题。 休谟称自己的不可知论为“温和的怀疑论”，休谟的怀疑论把人的认识和外部世界隔绝，根本怀疑外部世界的存在，完全否认认识世界的可能性。在哲学史上，休谟的这种观点称为不可知论。休谟的不可知论，不过是贝克莱的直接否定物质世界客观存在的另一说法而已。 休谟从不可知论出发，在事物的现象和本质之间建立了一条不可超越的鸿沟，否认人们能认识事物的内在因果联系和本质。他说：“结果和原因是完全不一样的，因此我们也就不能在原因中表现出结果来。”休谟否认客观因果性。 简述费希特知识学的三条基本原理。 费希特知识学简单说来，以三条原理为中心内容。 第一原理，“自我建立自我”。自我建立自我是基于自我反省的认识。在认识之前，假定有一个绝对的自我，绝对自我通过主体的自我反省建立起来，于是设定自我。自我在设定自我时，把自我作为认识对象，与认识事实不同，它是一种直觉，还没有规定，没有限制。 第二原理，“自我建立非我”。自我在认识“自我”时，由于把自我作为一个对象看待，必然产生一种对象意识，即与“自我”相对立的东西，这就是“非我”。但非我并不是唯物主义所说的“自然界”，它是“自我”建立起来的，是自我能动的创造物。 第三原理，“自我与非我的统一”。自我与非我，主体与客体，主观与客观，意识与存在，精神与物质都统一于自我意识之中，相互限制，相互决定。这种自我与非我之间的统一关系即自我与非我的统一。 这三个阶段是辩证发展的，自我在不断创造非我时不断丰富自己，自我的创造过程也是自我的认识过程，自我不断丰富着对非我的认识，从而对自我的认识也丰富了。 绝对同一（谢林） 谢林的“绝对同一”指“无差别的同一”。它既非主体，亦非客体，而是“主体与客体的绝对无差别”。其中主体与客体、思维与存在都融合为一，没有差别。“绝对同一”是一种不自觉的精神力量，使自己和自己区别开来，从而产生出主体和客体、思维和存在、精神和物质的差别和矛盾，并复归于绝对同一。 简述谢林的历史观。 第一，谢林认为，自然界和人类历史是一个由低级到高级的不断发展的过程。 第二，谢林认为，矛盾是自然界和人类历史不断发展的动力。他说：“对立在每一刻都重新产生，又在每一刻被消除。对立在每一时刻都这样一再产生又一再消除，必定是一切运动的根据。 第三，谢林认为，人类社会的发展规律是不依人的主观意识为转移的。他认为人类历史乃是一个有意识的自由创造的过程，但正如无意识的必然的自然界中存在着有意识和自由一样，在有意识的自由的社会历史的创造活动中也存在着无意识必然的东西。这种东西就是不依人的主观意识为转移的历史规律。 第四，谢林认为，贯穿于自然界和人类社会历史中的意志的自由性和规律的必然性根源于“绝对同一性”，整个历史都是对这种绝对的启示和表露。 自在之物（康德） 在康德哲学中，“自在之物”与“现象界”相对，有三种不同含义： （1）指外在事物，在其认识论中常用，意思是在人认识外界事物时，先由这些事物刺激人们的感官而产生杂乱的印象与观念，然后由感性形式与知性范畴加以改造而形成现象界，人只能认识现象界，对自在物则不得而知。 （2）在《纯粹理性批判》的先验辩证部分中认为理性所试图达到的三个理念：一是一切精神现象的最高统一体“灵魂”；二是一切物理现象的最高统一体“世界”；三是无条件的全体统一。但人们对这些事物的统一仍然用知性的有限范畴去认识，因而理性陷入二律背反和谬误，以此说明自在之物存在于现象的彼岸，并不具有经验材料，不能形成知识，但可以通过伦理学思想而达到对它的假设。 （3）指与本体意义接近的极限概念，见于《纯粹理性批判》知性理论中论述本体与现象对立的部分。这种用法强调自在之物的不可知的性质，认为人的认识到此为止，不能超越这个界限，极限之内是现象界，可以认识，自在之物不能认识。从这个意义提出本体概念，作为对自在之物的另一种表述。辩证唯物主义承认自在之物，但否认自在之物与现象之间有不可逾越的界限。 现象（康德） 在康德哲学中，“现象”与“自在之物”相对，是指在直观中对人呈现的东西。凡人经验所及，皆属现象范围，但并不是指客观事物的表面现象，而是指一种主观表象。这种表象由自在之物作用于人的感官形式，但它不反映自在之物的性质，而只是一种纯粹的主观心理状态。 二律背反（康德） 在康德哲学中，指两项原理对同一主题进行论证，其论证是矛盾的，但都是可以证明是正确的；或者两个前提推出的结论是矛盾的。二律背反的理论提出了理性思维中有矛盾的问题，但没有提出矛盾双方的统一与转化，并认为“有限”“无限”“简单”“复杂”这些说明现象界的知性范畴来说明自在之物是错误的；又认为自由与作为最初原因的上帝是属于自在之物的，而自然界则具有必然性，不能从必然性证明上帝存在，因而“自由”与“必然”“有上帝存在”与“没有上帝存在”可以存在于不同的地方，从而调和了矛盾。《纯粹理性批判》中提出理性宇宙论的四组二律背反，《实践理性批判》提出实践理性的二律背反，《判断力批判》中提出判断力的二律背反。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yangkunyi.com/tags/笔记/"},{"name":"复习","slug":"复习","permalink":"http://yangkunyi.com/tags/复习/"},{"name":"哲学","slug":"哲学","permalink":"http://yangkunyi.com/tags/哲学/"}]},{"title":"不动产管理复习","date":"2018-01-03T12:10:09.000Z","path":"2018/01/03/不动产管理复习/","text":"今天抽空整理了上个星期的不动产管理的复习题，当作复习吧，毕竟下个周就要考试了。 样品屋不是不动产。 不是定着物的特点：继续附着在建筑物上。 不动产的定义未包含预售屋。 要销售预售屋必须要有建造执照。 不动产物权只要签约就生效(X)；需要登记。 物权优先于债权。 关于地上权：不以支付地租为必要,不以订定租期为必要,地上权之目标为土地。 一坪 = 3.3058平方公尺 一平方公尺 = 0.3025坪 描述土地的词语：面积，位置，形状（密度不是）。 都市计划法包括的内容：乡镇计划，乡街计划，特定区计划。 基地面积100平方公尺,建蔽率50%,总楼地板面积25000平方公尺,容积率为多少?(容积率:楼地板面积除以建蔽率) 500% 容积率500%,基地面积100平方公尺,建蔽率50%,可盖几楼? (容积率除以建蔽率)10楼 从地籍图无法知道市价。 土地的性质不包括：异质性。 预售屋：高风险高报酬（自备款比中古屋少，总价负担重）。 房地产的特性：不可移动性，消费性，投资性。产品一致性不是房地产的特性。 在非都市土地中,山坡地保育区所兴建的房屋会属于何者用地?丙（老丙建）(甲:乡村 乙:乡村 丙:山坡 丁:工业) 所有权类型： 单独持有，分别共有，共同共有。 分别共有的特性：应有部分均等，着重应有部分，可自由处分应有部分。 房地产的声明周期：投资-&gt;生产-&gt;交易-&gt;使用。 共同共有：合伙财产（合伙人），共同财产（夫妻），未分割的遗产（继承）。 不是市地重划的原因：使用为公共交通促进土地合理之需要者（非都市）。 市地重划：经政府选定指定范围办理市地重划；人民申请优先办理；奖励私人自办重划。 市地重划描述错误的：重划后的土地按抽签的方式分配给原土地所有权人（按原位）。 市地重划中,土地所有权人共同负担不可超过? 45% 市地重划的效益：增加土地供给，促进土地利用，提高土地价值。不是为了增进当地人口数。 市地重划（一定是都市土地）的原因：新设都市地区的全部或一部分，实施开发建设；旧都市地区为公共安全促进土地合理需要者；都市土地开发新社区者。 市地重划后土地所有人最少可领回? 55% 桃园航空城属于哪一种征收？ 区段征收 有关区段征收的描述，错误的是：仅适用于都市土地 区段征收：国家因公益需要的征收私有土地；土地征收程序第一步是举办公听会；新设都市地区的全部或一部分，实施开发者可以进行区段征收。 区段征收与市地重划的比较何者错误? 区段征收较公平（区段征收不公平） 一般征收与区段征收之描述何者错误?一般征收之原因不一定要为公共事业需要者（征收的土地一定要用于公共事业）–正确的：区段征收执行较为困难；区段征收公共设施较多样性；市地重划民众参与较多；区段征收的原因是开发建设或者促进土地利用；区段征收以现金、抵债地予以补偿；区段征收就是一定区域内的土地全部征收。 国泰禾 定型化契约是根据消费者保护法定下的。 登记面积超过3%就可以解约了。 预售屋定型化契约不得记载事项：广告仅供参考/使用面积销售等 公寓大厦管理条理的适用描述：建物形态相关 住户权益义务说法错误：不须负担共同壁的管线维修费用（需要） 物业管理范围不包括个人财务管理。 消费者保护法和公平交易法的描述错误的是：广告不实无法依据公交法向业者开罚。 适用于公平交易法：先付订金才可看契约,没有接露重要信息（违反了市场交易秩序） 社会住宅的用意：只租不卖；帮助经济弱势；协助社会弱势。 都市更新不包括：合建。 约定专用部分说明正确的：经约定将共享部分给特定区分所有权人使用 权利变换正确的是：（都市更新）立体分配的概念，重新分配土地和建物 物权具有排他性,请求权,追及性 凉亭是建筑物，门框铁窗是固定物，售票亭不是不动产 使用执照是卖之后才有 区段征收执行比较困难也应该是最后一个手段,公共设施比较多样性(因为政府拿比较多)所以市地重划的公社是比较少的。 保留增收:还不知道做甚么用先保留 区段征收:大规模大面积征收 一并征收:我要征收这边这边有小块一并征收 区段增收:抽签 市地重划:原位 公同共有:双方因法律关系共同持有这个东西","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yangkunyi.com/tags/笔记/"},{"name":"复习","slug":"复习","permalink":"http://yangkunyi.com/tags/复习/"},{"name":"不动产","slug":"不动产","permalink":"http://yangkunyi.com/tags/不动产/"}]},{"title":"WeeklyMind-6","date":"2017-12-30T15:11:06.000Z","path":"2017/12/30/WeeklyMind-6/","text":"2017就这样过了，今天已经是2018年了，想来这一年确实发生了太多的事情，自己的价值观也在这些事情中一次次的改变和塑造着，未来的路在昨天的铺垫中慢慢成型，在今天的过程中慢慢延伸，在明天的憧憬理慢慢向前。这个周开始进入考试复习周，下周三就开始考试了，但自己在假期里显得十分的懒散，可能是因为自己这两天一直在想这一年自己到底干了什么，事情太多，整整两个日记本了，这应该就是自己的成长吧，在这里还是不想太多，就说说这个周。 学习 web课程已经结束了。下周三期末考试，作为自己最不担心的一门课程，只希望自己不要粗心吧。 行销管理的小组报告自己有想好好做出来，做一个成品，之后也可以拿得出手，所以自己把自己当作这个小组的组长，一直在拉着整个报告的进度，但是这个假期还是懈怠了很多，不过假期嘛，大家都没有将心思放在这上面，所以打算回来后继续。 不动产管理课程也结束了，因为元旦下周的课程放掉了，下下周直接考试，这门课也希望自己能不留遗憾的完成，毕竟是缘分让自己选了这门课。 财务管理一直是自己不喜欢又带有些害怕的课程，考试范围也算是出来了，所以只能说努力吧。 西方哲学史也因为假期结课了，最后仍是考试，这门课自己倒不是很担心。 体育课已经结课了，从来不担心的课程，应该是一个不错的成绩。 人际管理课程报告也结束了，还有最后两节课和与一个期末总结就完成了，成绩应该也算理想，报告自己觉得做得也不错。 所有课程都进入尾声，自己在这边的学习生活也只剩下最后的15天了。来到这里就说自己要做点什么，然后度过前一周的新鲜期之后陷入深深的迷茫期，感觉不知道做什么，课程前期比较轻松，大把的时间让自己思考，突然不知道该做些什么，直到找到真正的目的——体验，才真正算是投入了这边的生活，这时候在想这五个多月自己没有辜负，完成了这一次体验的行程，自己也清楚的感受到，除了知识，这一次的体验拓展了自己的太多，就想自己开始说的那样，这段经历也是自己人生路的铺垫。 生活 因为小组报告，自己又认识了一群来自不同地方的朋友。一双眼睛只能看到一个世界，但不同双眼睛就能看到不同的世界，自己在这些朋友的眼睛里又看到了不同的世界，那是自己不曾接触过的，却充满智慧，充满乐趣。 不动产管理的老师请全班的同学吃了披萨，虽然不是老师第一次请吃东西，但是这种氛围自己是第一次感受。从小，在自己的眼里，老师都是要尊敬的，这样自己和老师之间从来都没有向朋友一样亲近过，因为自己在老师面前就是无法将自己视为老师的朋友，但是那个时候我真的没有把筱蓉当作老师来看待，当然不仅仅是因为一顿批萨，而是筱蓉身上散发出来的气场，那种亲和的态度，我也不是说之前的老师不亲和，反正就是个人觉得自己是真的很喜欢筱蓉，也很喜欢她不拘小节的课程。 原校下周就要选课了，自己想来其实也没有太困难，就是物流的课程需要补回来，其余都还好，所以没必要那么担心。 人间一趟，看看太阳。","tags":[{"name":"周记","slug":"周记","permalink":"http://yangkunyi.com/tags/周记/"}]},{"title":"PHP绘图","date":"2017-12-24T04:25:09.000Z","path":"2017/12/24/PHP绘图/","text":"web课程的笔记和一些实例代码。还有一份自定义图形作业，感觉还不错，简单做了一个二维码。（全是画矩形，确实有点无聊了，有空画点有趣的图） PHP绘图1. GD（Graphics Dynamic Library） GD1 / GD2 可以通过phpinfo()来查询 2. 绘图流程1234567891011121314151617181920212223242526272829303132333435// 确定绘画图片的格式// 格式有：jpg，png，gifheader(&quot;Content-type:image/格式&quot;);// 1. 建立一个画布（分配存储空间）$image = ImageCreate(长度,宽度);// 一般画布$image = ImageCreateTrueColor(长度,宽度);// 高清// 2. 建立颜色板$bgcolor=ImageColorAllocate($image,0,255,0);// 默认背景颜色// 3. PHP绘图命令// 点 ImageSetPixel($image,x,y,$color)ImageSetPixel($image,90,40,$textcolor);// 线 ImageLine($image,x1,y1,x2,y2,$color)ImageLine($image,0,0,$bgcolor);// 弧 ImageArc($image,x,y,高,宽,开始角度,结束角度,$color)ImageArc($image,50,25,90,40,0,360,$textcolor1);// 巨型 ImageRectangle($image,x1,y1,x2,y2,$color)ImageRectangle($image,20,10,80,40,$textcolor);// 空心多边形 ImagePolygon($image,$点数组,点数,$color)ImagePolygon($image,$point,count($point)/2,$textcolor);// 实心多边形 ImageFilledPolygon($image,$点数组,点数,$color)ImageFilledPolygon($image,$point,count($point)/2,$textcolor);// 透明 ImageColorTransparent($image,$color)ImageColorTransparent($image,$textcolor);// 文字输出 ImageTTFtext($image,大小,角度,x,y,$color,字体绝对路径,string)ImageTTFtext($image,32,0,0,50,$textcolor,&quot;simhei.ttf&quot;,$string);// 4. 显示/导出 ImageXXX($image[,储存图形的位置和名称])Imagepng($image);// 5. 结束 释放空间ImageDestroy($image); 实例：二维码绘制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;?php // 文件输出图片格式为png header(&quot;Content-type:image/png&quot;); // 建立一个画布 $image = ImageCreate(100,100); // 设定画布的北京颜色 $bgcolor = ImageColorAllocate($image,255,255,255); ImageFill($image,0,0,$bgcolor); // 画笔的颜色 $black = ImageColorAllocate($image,0,0,0); $white = ImageColorAllocate($image,255,255,255); ImageFilledRectangle($image,0,0,28,28,$black); ImageFilledRectangle($image,4,4,24,24,$white); ImageFilledRectangle($image,8,8,20,20,$black); ImageFilledRectangle($image,72,0,500,28,$black); ImageFilledRectangle($image,76,4,96,24,$white); ImageFilledRectangle($image,80,8,92,20,$black); ImageFilledRectangle($image,0,72,28,500,$black); ImageFilledRectangle($image,4,76,24,96,$white); ImageFilledRectangle($image,8,80,20,92,$black); ImageFilledRectangle($image,64,64,84,84,$black); ImageFilledRectangle($image,68,68,80,80,$white); ImageFilledRectangle($image,72,72,76,76,$black); ImageFilledRectangle($image,0,32,20,44,$black); ImageFilledRectangle($image,4,36,8,40,$white); ImageFilledRectangle($image,4,44,12,48,$black); ImageFilledRectangle($image,0,48,4,68,$black); ImageFilledRectangle($image,8,52,12,56,$black); ImageFilledRectangle($image,12,48,20,68,$black); ImageFilledRectangle($image,16,52,20,64,$white); ImageFilledRectangle($image,32,4,36,8,$black); ImageFilledRectangle($image,40,0,44,8,$black); ImageFilledRectangle($image,48,0,52,4,$black); ImageFilledRectangle($image,52,4,56,8,$black); ImageFilledRectangle($image,60,4,64,8,$black); ImageFilledRectangle($image,64,0,68,4,$black); ImageFilledRectangle($image,64,8,68,12,$black); ImageFilledRectangle($image,48,8,52,16,$black); ImageFilledRectangle($image,52,12,56,20,$black); ImageFilledRectangle($image,56,8,60,16,$black); ImageFilledRectangle($image,24,56,32,68,$black); ImageFilledRectangle($image,24,60,28,64,$white); ImageFilledRectangle($image,24,40,28,44,$black); ImageFilledRectangle($image,24,48,28,52,$black); ImageFilledRectangle($image,28,44,32,48,$black); ImageFilledRectangle($image,32,40,36,44,$black); ImageFilledRectangle($image,36,48,44,52,$black); ImageFilledRectangle($image,32,12,44,16,$black); ImageFilledRectangle($image,36,16,40,24,$black); ImageFilledRectangle($image,32,20,36,28,$black); ImageFilledRectangle($image,24,32,40,36,$black); ImageFilledRectangle($image,36,28,48,32,$black); ImageFilledRectangle($image,40,24,44,28,$black); ImageFilledRectangle($image,44,20,68,24,$black); ImageFilledRectangle($image,48,24,52,28,$black); ImageFilledRectangle($image,56,24,60,28,$black); ImageFilledRectangle($image,64,24,68,28,$black); ImageFilledRectangle($image,32,68,36,100,$black); ImageFilledRectangle($image,32,76,36,80,$white); ImageFilledRectangle($image,68,84,84,88,$black); ImageFilledRectangle($image,88,88,92,92,$black); ImageFilledRectangle($image,84,68,88,84,$black); ImageFilledRectangle($image,88,64,92,88,$black); ImageFilledRectangle($image,88,76,92,80,$white); ImageFilledRectangle($image,92,72,96,88,$black); ImageFilledRectangle($image,96,72,100,100,$black); ImageFilledRectangle($image,76,96,96,100,$black); ImageFilledRectangle($image,76,88,80,96,$black); ImageFilledRectangle($image,80,92,88,96,$black); ImageFilledRectangle($image,88,88,92,92,$black); ImageFilledRectangle($image,68,96,72,100,$black); ImageFilledRectangle($image,64,92,68,96,$black); ImageFilledRectangle($image,68,32,72,36,$black); ImageFilledRectangle($image,76,32,80,44,$black); ImageFilledRectangle($image,84,32,88,36,$black); ImageFilledRectangle($image,92,32,96,44,$black); ImageFilledRectangle($image,64,36,68,44,$black); ImageFilledRectangle($image,68,40,72,44,$black); ImageFilledRectangle($image,84,40,88,44,$black); ImageFilledRectangle($image,96,36,100,48,$black); ImageFilledRectangle($image,64,48,76,56,$black); ImageFilledRectangle($image,68,52,80,60,$black); ImageFilledRectangle($image,68,52,76,56,$white); ImageFilledRectangle($image,80,48,84,52,$black); ImageFilledRectangle($image,64,60,72,64,$black); ImageFilledRectangle($image,80,60,88,64,$black); ImageFilledRectangle($image,84,52,88,64,$black); ImageFilledRectangle($image,88,48,100,52,$black); ImageFilledRectangle($image,92,52,96,60,$black); ImageFilledRectangle($image,96,56,100,64,$black); ImageFilledRectangle($image,44,32,48,36,$black); ImageFilledRectangle($image,56,28,64,32,$black); ImageFilledRectangle($image,52,32,60,36,$black); ImageFilledRectangle($image,48,36,56,40,$black); ImageFilledRectangle($image,40,36,44,44,$black); ImageFilledRectangle($image,56,40,64,48,$black); ImageFilledRectangle($image,48,44,52,52,$black); ImageFilledRectangle($image,52,48,56,56,$black); ImageFilledRectangle($image,44,56,64,60,$black); ImageFilledRectangle($image,56,60,60,64,$black); ImageFilledRectangle($image,36,56,40,64,$black); ImageFilledRectangle($image,40,64,44,72,$black); ImageFilledRectangle($image,44,60,48,68,$black); ImageFilledRectangle($image,48,68,56,72,$black); ImageFilledRectangle($image,52,72,56,80,$black); ImageFilledRectangle($image,56,72,60,76,$black); ImageFilledRectangle($image,48,76,52,84,$black); ImageFilledRectangle($image,36,72,40,88,$black); ImageFilledRectangle($image,40,76,44,84,$black); ImageFilledRectangle($image,36,96,40,100,$black); ImageFilledRectangle($image,44,88,48,100,$black); ImageFilledRectangle($image,48,88,52,92,$black); ImageFilledRectangle($image,60,68,64,72,$black); ImageFilledRectangle($image,56,80,64,84,$black); ImageFilledRectangle($image,56,92,60,96,$black); // 形成图像 Imagepng($image); // 释放空间 ImageDestroy($image);?&gt; 结果（扫一扫啊，哈哈哈） 更新图图一12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?php // 一幅随机图 // 文件输出图片格式为png header(&quot;Content-type:image/png&quot;); // 建立一个画布 $image = ImageCreate(500,550); // 设定画布的北京颜色 $bgcolor = ImageColorAllocate($image,0,0,0); ImageFill($image,0,0,$bgcolor); // 画笔的颜色 $black = ImageColorAllocate($image,0,137,167); // 绘画过程 $x2 = 0; for($j = 0;$j &lt; 25; $j++)&#123; // 随机生成圆半径 $radius1 = rand(7,12); // 随机点生成一个实心圆 $x1 = rand(1,499); $y1 = rand(1,499); for($i = 1;$i &lt; $radius1;$i++)&#123; $w = $i; $h = $i; imagearc($image, $x1, $y1, $w, $h, 0, 360, $black); &#125; if($x2 !== 0)&#123; ImageLine($image,$x1,$y1,$x2,$y2,$black); &#125; // 随机生成圆半径 $radius2 = rand(7,12); // 随机再生成一点连接上一点 $x2 = rand(1,499); $y2 = rand(1,499); for($i = 1;$i &lt; $radius2;$i++)&#123; $w = $i; $h = $i; imagearc($image, $x2, $y2, $w, $h, 0, 360, $black); &#125; ImageLine($image,$x1,$y1,$x2,$y2,$black); &#125; // 打出名字 $string = &quot;x1067017 杨坤怡&quot;; ImageTTFtext($image,12,0,360,530,$black,&quot;c:/windows/fonts/FZPXJW.TTF&quot;,$string); // 形成图像 Imagepng($image); // 释放空间 ImageDestroy($image);?&gt; 图二1234567891011121314151617181920212223242526272829303132333435&lt;?php // 一幅随机图 // 文件输出图片格式为png header(&quot;Content-type:image/png&quot;); // 建立一个画布 $image = ImageCreate(400,420); // 设定画布的北京颜色 $bgcolor = ImageColorAllocate($image,55,60,56); ImageFill($image,0,0,$bgcolor); // 画笔的颜色 $black = ImageColorAllocate($image,0,137,108); // 绘画过程 // 随机生成空心三角形 $point=array(); for($j = 1;$j &lt; 10;$j++)&#123; for($i = 1;$i &lt; 4;$i++)&#123; $x = rand(1,399); $y = rand(1,399); array_push($point,$x,$y); &#125; ImagePolygon($image,$point,count($point)/2,$black); &#125; // 打出名字 $string = &quot;x1067017 杨坤怡&quot;; ImageTTFtext($image,12,0,250,410,$black,&quot;c:/windows/fonts/FZPXJW.TTF&quot;,$string); // 形成图像 Imagepng($image); // 释放空间 ImageDestroy($image);?&gt; 图三123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?php // 绘画一个A字母 // 文件输出图片格式为png header(&quot;Content-type:image/png&quot;); // 建立一个画布 $image = ImageCreate(400,400); // 设定画布的北京颜色 $bgcolor = ImageColorAllocate($image,0,0,0); ImageFill($image,0,0,$bgcolor); // 画笔的颜色 $black = ImageColorAllocate($image,241,124,103); // 绘画过程 // for($i = 1;$i &lt; 6;$i++)&#123; // $w = $i * 15; // $h = $i * 15; // imagearc($image, 250, 250, $w, $h, 0, 360, $black); // &#125; $start = 0; $stop = 120; for($i = 1;$i &lt; 13;$i++)&#123; $w = $i * 25; $h = $i * 25; imagearc($image, 200, 200, $w, $h, $start, $stop, $black); $start += 1*$i; $stop -= 1*$i; &#125; $start = 120; $stop = 240; for($i = 1;$i &lt; 13;$i++)&#123; $w = $i * 25; $h = $i * 25; imagearc($image, 200, 200, $w, $h, $start, $stop, $black); $start += 1*$i; $stop -= 1*$i; &#125; $start = 240; $stop = 360; for($i = 1;$i &lt; 13;$i++)&#123; $w = $i * 25; $h = $i * 25; imagearc($image, 200, 200, $w, $h, $start, $stop, $black); $start += 1*$i; $stop -= 1*$i; &#125; // 打出名字 $string = &quot;x1067017 杨坤怡&quot;; ImageTTFtext($image,12,0,250,370,$black,&quot;c:/windows/fonts/FZPXJW.TTF&quot;,$string); // 形成图像 Imagepng($image); // 释放空间 ImageDestroy($image);?&gt;","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yangkunyi.com/tags/笔记/"},{"name":"PHP","slug":"PHP","permalink":"http://yangkunyi.com/tags/PHP/"}]},{"title":"WeeklyMind-5","date":"2017-12-24T04:23:09.000Z","path":"2017/12/24/WeeklyMind-5/","text":"本周开始学习都开始进入最后的报告和复习阶段，不动产报告， 人际关系报告，以及接下来的行销报告和各种总结，然后是期末考试复习，所以这两个周不太有时间自学了。 学习 不动产管理小组报告：可能因为对这边的一些名词不太熟悉，所以报告的时候自己有一点说不清楚，不知道该如何表达自己的想法；不过也是没有准备充分的表现。 人际关系小组报告：我们小组的主题是社交软件对大学生人际关系的影响，自己准备的ying影响的好坏部分，这次就好很多了，自己有事先练习自己不熟悉的稿子，报告的时候就能很顺利的讲下来。 行销管理小组讨论：这样的小组讨论是很重要的我觉得，以后作为一个想要在互联网公司工作的人，这种小组讨论的能力是必须具备的，而自己在讨论中的表现还算行，队友们也很给力，最后分工也很快敲定下来，希望最后的小组报告也能一切顺利。 财务管理和西方哲学史也都剩下最后一节课了，所以要抓紧时间复习了啊！ 生活 本周的天气都不错，前两天很冷，后面都有着充足的阳光。 周四人际关系报告完回寝室的路上，在马路中间和它相遇了，它就好像在那里等我一样，我当时还在看手机，却不经意的一个转头，看见它就那样安静的躺在马路上，心里当时唯一的想法就是不要让来往的车辆压着它了，于是把它带了回来。 今天是平安夜，明天是圣诞节，作为一个不怎么过圣诞节的我来说，吃一个苹果就足够了，还有就是今晚和室友约着去吃火（tang）锅，这可能是自己在这边的最后一顿火锅了吧！ 周五去看了旁边的交大，只是去吃了有名的松饼，所以也没有来得及细看整个学校，唯一的感觉就是看到的建筑都很有设计感。 待更新事项 不动产管理上节课的评价和学期总结 关于台湾的三千字 复习","tags":[{"name":"周记","slug":"周记","permalink":"http://yangkunyi.com/tags/周记/"}]},{"title":"WeeklyMind-4","date":"2017-12-17T04:52:37.000Z","path":"2017/12/17/WeeklyMind-4/","text":"这个周开始都开始准备各科的报告和总结了，所以不是在写报告就是在做ppt，周五下午有抽空学习node，看了N-blog项目的大概，但是困难出在MongoDB，虽然连上了，项目跑起来了，但是并没有懂其中的原理，之后会继续理解。 学习 web学了PHP的绘画，还画了一个二维码。 不动产管理报告 人际关系报告 完成了毛概 不定期更新微信 生活 进入自己想要的规律状态，但是每天运动量还是太少了，可能是气温太低了，自己也没有想出门。 今天晚上准备去买水果，维生素还是不能少 真的不是很喜欢这边的食物，吃的不是很开心，开始想奶奶做得菜了 昨晚和一个同龄的妹子聊到了父母的期望和自己想做的有偏差，自己将自己想做的都告诉了她，那是因为自己也想像自己所说的那么坚持，坚持做自己想做的事情，父母的期望并不想辜负，尽自己最大的努力去达到他们想看到的样子，但是这并不意味着我不能做自己，这并不是矛盾的关系，很多情况下自己的想法和父母的想法是可以共存的。父母希望自己把心思放在学习上，只不过想自己的成绩能够过得去，那自己在保证了成绩的前提下做的事情父母也会接受的，获许还更可能得到支持。所以我觉得不能把自己的想法和父母的想法完全对立起来吧，换一种看法，就像前面所说的，是可以共存的。 待更进事项 西方哲学整理复习 财务管理复习（考课后题，我就把课后题全做一遍总可以了吧！死记硬背我都给你过了。。。） 行销管理报告，视频，ppt 继续学习英语 已经开始倒数着回去的日子了，是真的想家了吧！","tags":[{"name":"周记","slug":"周记","permalink":"http://yangkunyi.com/tags/周记/"}]},{"title":"NeverLimitYourself","date":"2017-12-14T13:01:57.000Z","path":"2017/12/14/NeverLimitYourself/","text":"看完C菌的视频有感而发，想说一些话！ 自己正是出于这样的原因选择来到台湾交流学习，我想看看那远离我的生活的地方有什么不一样，那里的生活是怎么样的？那里的人是怎么样的？那里的猫也是那么懒吗？… 于是九月四日踏上里人生的第一次飞机之旅，短短三个小时，来到了这个离家一千多千米的岛上。一切都是那么好奇，现在的我已经在这里快四个月了，学习生活也都很顺手了，该体验的自己也都体验到了，再也不会像刚来的前几周那样充满不安的焦虑，或许这就是成长吧。 在申请这个交换机会的时候，自己曾给自己找各种理由，但最后还是只能说：我就是想看看。 自己在最开始的时候焦虑一个是因为陌生环境的压力；另一个原因是自己看到了自己相看的东西之后，心里突然之间有一瞬间感觉空空的，不知道自己之后该做什么了，整个人好像在这里生活着没什么意思了，同时本校也开学了，看着同学们开学的动态，那种叫做孤独的东西一下子就从心里冒了出来。可是别人还在“羡慕”的“恭维”和祝贺自己来到这里，所以自己还要打起精神来应付，为了来这里之前说下的那句：“我想去看看！”没错，那个时候每天都很丧，过得很混沌。 那个时候只有父母算生活动力，想着他们为了让自己出来看看所做的努力，自己真的没理由就这样混沌的过，但同时这种压抑的感觉又让自己整个人感觉很紧绷，所以也是压力吧。自己没有自觉与他们联系的习惯，在本校的时候一个月也是要回家的时候才会联系一下，所以根本不知道平时有什么好跟他们说的。不过为了让他们不担心自己的生活和学习，自己还是学会了每隔两天报告一下平安，是真的只有一个“报”字的报平安。不过母上大人还是想自己的，偶尔会在晚上和自己视频一下，说一下家里的情况，自己也会简单的报告一下自己的近况，虽然自己初中以来就是住校，但这次毕竟隔得比较远，所以其实真的是有些想他们了。 然后终于那句：“意义这种事情只有在做过之后才知道，之前说的意义都是肤浅的认知罢了！”解决了让自己失眠一个周的问题，终于将急躁的心放到了肚子里，开始慢慢享受每一天的生活，早起，看书，上课，写作业，跑步…终于生活算是步入了正轨。 正式抱着这样的心态，中间出去短途旅行了三次，那才叫真的看到了自己看到的，由于马上要期末考试了，所以之后应该不会再出去了。不过这三次的记忆就足以抵上前三个月的努力了，接下来就好好准备课程相关报告和考试吧。 经过这四个月的生活后，那种不知名意义好像快要浮出水面的时候，看到了C菌的Nerver Limit Yourself，自己终于找到了可以表达自己心情的句子： Never limit yourself because of others’ limited imagination; never limit others because of your own limited imagination.— MAE JEMISON ps:如果想了解本人在台湾的更多近况，可以扫描下面的公众号二维码。（可能这就是广告吧。）","tags":[{"name":"日常","slug":"日常","permalink":"http://yangkunyi.com/tags/日常/"},{"name":"随笔记","slug":"随笔记","permalink":"http://yangkunyi.com/tags/随笔记/"},{"name":"观后感","slug":"观后感","permalink":"http://yangkunyi.com/tags/观后感/"}]},{"title":"WeeklyMind-3","date":"2017-12-10T09:30:09.000Z","path":"2017/12/10/WeeklyMind-3/","text":"本周很日常，只是感觉自己有点缺乏锻炼，所以显得不是特别的精神，可能也和天气有关系，开始凉了，自己也没带什么厚衣服，所以没课都不怎么出门的那种。 学习 各科课程进行正常 但并没有完成本校作业 完成了第一次不动产小组报告，虽然内容很尬，但是表现自己还算满意 关于人际关系的人际圈，自己在课堂上画出不同的圈也让自己十分的意外，但这也是自己本身的看法罢了，或许这才是最真实的自己 让自己丧了一天的财务管理期中成绩也是真的令自己心碎啊 了解了一些数据库的知识，应该叫复习了，毕竟之前还是多少学了一点 node要努力了，时间的零碎学起来也是很零碎 生活 这一周缺乏锻炼，怎么感觉又长胖了。。。 稍微一点混沌，可能躺太多 手臂在乒乓球课崴了，一直一点酸疼 吃饭特别不规律！！！这一点下个周一定得改了 对了，微信终于开始了，不过进度貌似不能保证每天，所以自己准备改一下，暂时上学期间频率保持一周两篇吧，如果空闲的周可以多做一点 待更进事项 通信作业的问题回答 还是抽时间把毛概的论文写了吧，毕竟回去可能还真的可以考试呢 node php继续学习","tags":[{"name":"周记","slug":"周记","permalink":"http://yangkunyi.com/tags/周记/"}]},{"title":"用户验证与数据库","date":"2017-12-06T12:22:28.000Z","path":"2017/12/06/用户验证与数据库/","text":"这是今天web课程的笔记，亲自尝试了前面两种验证方式，第三种方式之前也有所接触，还都算比较好理解。后面还有一些数据库的简单解释。 验证用户方法1. HTTP自带的验证 这种方式是利用HTTP所提供的验证头信息来对用户进行身份验证。由于这种凡是对大量的使用者缺乏有效的管理，在用户太多时并没有太大用处，因此少量用户时使用。例如开发人员。 123456789101112131415161718192021222324&lt;?php // 如果 $PHP_AUTH_USER 不等于 &quot;tea&quot;，就进不去网站。 if($_SERVER[&apos;PHP_AUTH_USER&apos;] !=&apos;tea&apos; || $_SERVER[&apos;PHP_AUTH_PW&apos;] !=&apos;ok&apos;)&#123; //通过头部信息告知浏览器验证 header(&apos;WWW-Authenticate: Basic realm=&quot;「需验证」---请输入账户/密码&quot;&apos;); header(&apos;HTTP/1.0 401 Unauthorized&apos;); echo &quot;账号或密码错误。请刷新重新输入。&quot;; //记得要加上 exit() 离开，不然就跟没有验证一样了！ exit(); &#125; /* 如果用户输入正确的账户和密码，下面的 HTML 就会显示 */ ?&gt; &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;&lt;/TlTLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;P&gt;Hello World！&lt;/P&gt; &lt;/BODY&gt; &lt;/HTML&gt; 2. htaccess方式的验证 这种凡是其实时Apche所提供的加强版HTTP验证方式，利用Apche所提供的htpasswd来设定使用者账号和密码。但是任然不适用过多用户。 首先建立用户数据（授权的动作）12345678910111213// 第一次 -c，第二次添加就不需要了c:\\appserv\\apache\\bin&gt; htpasswd -c htusers Tom New password: ←输入用户密码 Re-type new password: ←再次输入 Adding password for user Tomc:\\appserv\\apache\\bin&gt; htpasswd htusers Jack New password: Re-type new password: Adding password for user Jack// 可以将不同的人进行分组，group是群组名称group:Tom Jack 然后在需要权限才可以进入的路径中建.htaccess文档（将已授权和访问地址联系到一起）12345678910111213141516// 显示给用户看的提示AuthName &quot;登陆时需要输入账号和密码「账号」与「密码」&quot; // 验证时不编码AuthType Basic // 之前建立的用户数据AuthUserFile c:\\appserv\\apache\\bin\\htusers #AuthGroupFile c:\\appserv\\apache\\bin\\htgroup // 所有访问的都需要验证require valid-user #require user jollen #require group ieem316 // 定义说拒绝所有，允许个别order deny,allow deny from all #allow from .nthu.edu.tw allow from 140.114.70.31 3. 数据库存储用户数据 最有效，最普遍的做法，将用户的账户和密码存在数据库中，每次登陆到数据库中查找数据，最后返回有无和正确性。 准备工作 登陆的表单 登陆的程序 建好用户的资料库，至少要包括账号和密码 步骤 通过表单获取用户账号与密码 到数据库中查找对应的账号和密码 失败就返回重新获取信息，直到成功为止 1234567891011121314151617181920212223242526// 本程序通过头信息获取的用户的账户和密码&lt;?php // 如果用户沒有输入账户，要求用户重新验证。 IF(!isset($PHP_AUTH_USER))&#123; header(&apos;WWW-Authenticate: Basic realm=&quot;请输入账号和密码&quot;&apos;); header(&apos;HTTP/1.0 401 Unauthorized&apos;); echo &quot;刷新后重新登陆&quot;; exit(); &#125; else&#123; mysql_connect(&quot;localhost&quot;,&quot;admin&quot;,&quot;asdee4&quot;) or die (&quot;无法连接 MySQL&quot;); rnysql_select_db(&quot;members&quot;) or die(&quot;无法连接数据库&quot;); $query=&quot;select id from users where username=&apos;$PHP_AUTH_USER&apos; and password=&apos;$PHP_AUTH_PW&apos;&quot;; $result=mysql_query($query); $n_rows=mysql_num_rows($result); mysql_close(); // 当row&lt;1时，用户账号与密码有错，重新登陆 if($n_rows &lt; 1)&#123; header(&apos;WWW_Authenticate: Basic realm=&quot;请输入账号和密码&quot;&apos;); header(&apos;HTTP/1.0 401 Unauthorized&apos;); echo &quot;刷新重新登陆&quot;; exit(); &#125; &#125; ?&gt; 数据库数据库系统 = 数据库管理系统 + 数据库DBMS（数据库管理系统）：database management system 只是一个软件 作用：资料的管理和维护 DB（数据库）：databaseSQL（structure query language）：结构化查询语句 第一代：89 第二代：92（绝大部分数据库所遵循的规则） 第三代：99（没有成立） DDL（data definition language）：数据库和数据表定义语言 create database table drop database table alter（改变数据库的结构） table DML（data manipulation language）：数据处理语言 select（查询） insert [into]（添加） delete（删除） updata（单个属性的改变） DCL（data control language）：数据库控制语言 grant（授权） revoke（取消授权） 使用者 DBO（database operater） DBA（database administrator）：root/password 简单的结构DB Server（数据库服务器） DB（数据库） table（数据表） record（） field charset 流程 链接数据库 use/create：database create：table/改变资料表里面的数据 数据库操作方法 通过程式（php） 通过命令行 -u：使用者 -h：主机 -p：密码 通过图形界面（软件） PHP &amp; 数据库1. 连接数据库12$db = mysql_connect（数据库主机名称或ip,数据库账号,数据库密码）; or die(&quot;无法连接数据库服务器&quot;); 2. 使用数据库12mysql_ select_db(名称,$db); or die(&quot;无法连接数据库&quot;); 3. 对数据进行操作1$sql = &quot;(此处就是SQL指令)&quot;; 4. 用变量对数据进行存取1$result = mysql_query($sql,$db); 5. 最后关闭数据库 当取到数据的时候就可以关掉了，这样可以降低数据库风险。 1mysql_close($db); 注 sql指令可以大小写，但各种数据库名称和数据表名称要区别大小写。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yangkunyi.com/tags/笔记/"},{"name":"PHP","slug":"PHP","permalink":"http://yangkunyi.com/tags/PHP/"},{"name":"验证","slug":"验证","permalink":"http://yangkunyi.com/tags/验证/"},{"name":"数据库","slug":"数据库","permalink":"http://yangkunyi.com/tags/数据库/"}]},{"title":"坎帕斯学院讨论日常-2","date":"2017-12-03T13:23:28.000Z","path":"2017/12/03/坎帕斯学院日常讨论-2/","text":"这是第二次整理讨论的内容，本次内容有点深奥，值得细嚼慢咽。 名词解释 高并发(High Concurrency) 指通过设计保证系统能够同时并行处理很多请求。 是互联网分布式系统架构设计中必须考虑的因素之一。 高性能(High performance) 目前理解就是提高浏览网页的速度。 高可用(High Availability) 通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。 高扩展性(High Extensibility) 通常和可伸缩性混为一谈.在软件范畴上，是软件系统本身的属性，或者进一步说是设计的属性，代码的属性。 高可维护性(High Maintainability) 是衡量一个系统的可修复(恢复)性和可改进性的难易程度。 接口的高可用性 保证这个接口在任何情况下都可以正确的取到数据。 方案一：每次访问的时候将a接口的数据存在本地，第二次访问的时候接口如果gg了，可以直接在本地获取数据，然后渲染出来；（前提是访问过a接口） 方案二：推oss或者cdn；每次访问了一个接口，然后服务器把返回的数据生成文件推送到一个静态资源服务器上去； 好处：比如某人访问了接口，静态资源服务器就会缓存a里面的数据，这时候gg了，其他人依然可以请求到oss上的数据；（逻辑是前端做到的，但是数据推到oss上是从后台推上去的） oss几乎不可能gg，原因是它只是一个静态资源存储的地方； 默认数据：（假数据）当接口不可用的时候，用这个自己做的数据； 目前企业的解决方案是：先走服务器接口，若是gg了；再访问本地缓存；若没有，则访问oss。 本地缓存 优点： 如果第一次没有访问对应的接口就没有本地缓存； 数据的时效性不够； 缺点： 快，不用通过网络请求； 缓存地点 缓存类型： sessionStorage：只在当次回话有效，不会带到每一个请求里面去； indexDB：浏览器支持度很低，也就是说兼容问题很大； cookie：过期时间可以设置，默认是浏览器当期回话结束失效；cookie很小；每次对应域名是会在每个请求头带过去，浪费资源，所以限制了大小，如果不限制，就会跟上传文件没有区别了，会导致特别慢；对于数据接口，我们不能保证内容有多大，而且每个接口数据都要缓存，所以不能用cookie。 localstorage：没有大小限制； 以上都属于这两种类型： （私有）浏览器缓存：单个用户，你浏览过的页面浏览器缓存起来。 （共享）代理缓存：多个用户，所在公司自己架构的，减少网络拥堵与延迟。 浏览器缓存机制浏览器请求一个资源，是怎么判断取缓存还是找服务器下载？ 状态码304是怎么产生的？ 是因为本地文件设置的信息头部过期了，去服务器拉取，然后服务器告诉我，其实你的文件还尚未过期，让你回自己本地取资源； 状态码200（from cache）是怎么产生的？ 一定是通过了请求并且成功然后返回的状态码，方式get或者post。 以上的问题只是有所了解了，但是关于浏览器的缓存机制还没有系统的了解，自己在看官方文档的时候，感觉有点困惑，所以先在这里埋个种子。","tags":[{"name":"前端","slug":"前端","permalink":"http://yangkunyi.com/tags/前端/"},{"name":"讨论","slug":"讨论","permalink":"http://yangkunyi.com/tags/讨论/"},{"name":"问题","slug":"问题","permalink":"http://yangkunyi.com/tags/问题/"},{"name":"浏览器缓存","slug":"浏览器缓存","permalink":"http://yangkunyi.com/tags/浏览器缓存/"},{"name":"状态码","slug":"状态码","permalink":"http://yangkunyi.com/tags/状态码/"}]},{"title":"WeeklyMind-2","date":"2017-12-02T04:29:09.000Z","path":"2017/12/02/WeeklyMind-2/","text":"忙碌的一周，这都是浪三天的后遗症。上周的周记都在浪中忘记了，但是心情还是很开心的。 总结上两周学习 期中考试和报告全部完成，成绩一般，接下来又要开始准备期末考试了，来台湾三个月了，自己也在想这一趟来的值不值。 课程： 突然对不动产的作业很是上心，希望在同学和老师们面前不丢咱大陆学生的脸 为了行销管理的期中报告，自己也算是呕心沥血了，希望不要太差 西方哲学到康德部分，开始有点抽象到不懂了，还是知识面太狭窄了 财务管理课程让自己彻底对经融课程失望了，自己是真的不适合学习，修这门课都当作了解吧 突然觉得人际交往是一门很重要的课程，既认识了自己，也认识了别人 这两个周因为中间的各种考试和报告，时间有点混乱，所以接下来应该好好计划 其它 http缓存机制的了解，周末希望能理解完 继续学习了php 了解php架构包中如何建wordpress以及评论板块（但是发现自己对数据库的认识还不够，导致在尝试过程中老是出现问题） 生活 上个周末算是很精彩了，一趟三天两夜的旅行回来，也导致了博客的的各种托更。 台南： 赤崁楼 安平古堡 安平树屋 安平老街 高雄 夜市 爱河 真爱码头 西子湾 中山大学 也算是见过真正的浪了！ 待更进事项 12月计划 微信订阅号 各种作业 前端书籍（每天给点时间来做，积累最重要） 今年的最后一个月，完成你年初的计划可好，少年！","tags":[{"name":"周记","slug":"周记","permalink":"http://yangkunyi.com/tags/周记/"}]},{"title":"WeeklyMind-1","date":"2017-11-19T06:11:30.000Z","path":"2017/11/19/WeeklyMind-1/","text":"寻常的一周，不过做了许多的决定，之后每一周也希望自己能坚持做一下简单的总结。 总结上周生活 新买的T恤很喜欢 吃得很随便，但不失营养，老年人一样的生活，哈哈哈 住的寝室，还是比较宅，之后希望有时间，还是多出去走走看看 这周没怎么出门，最近在准备各种考试和期中报告 学习 课程： 人际考试 周三运动会放假 复习财管 其它课程一切照常进行 完成日常作业 其它 申请和绑定了域名 博客主题修改 了解nodeppt 简单的看了一下网易云api（有准备做一个音乐播放器） 待更进事项 复习财管（周三考试） 电商案例分析 人际期中报告 不动产课堂报告 课程小节论文 通信英语ppt 继续学习php 更新博客 日常作业 最后还有锻炼，这个事情还是比较重要的。按照自己的计划腾出锻炼的时间，保持健康，毕竟在这个遥远的地方没有买保险。。。","tags":[{"name":"周记","slug":"周记","permalink":"http://yangkunyi.com/tags/周记/"}]},{"title":"PHP学习笔记","date":"2017-11-17T09:55:52.000Z","path":"2017/11/17/PHP学习笔记/","text":"本文是一些PHP的基础知识，自己看书的时候做的一些笔记。 PHP变量 PHP 语句和 PHP 变量都是区分大小写的。 PHP 没有声明变量的命令。 PHP 是一门弱类型语言 不必向 PHP 声明该变量的数据类型。 PHP会根据变量的值，自动把变量转换为正确的数据类型。 在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称。 作用域局部变量和全局变量 global可以将局部变量提升为全局变量。 PHP将所有全局变量存储在一个名为$GLOBALS[index]的数组中。index保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。 Static作用域 当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除。要做到这一点，请在您第一次声明变量时使用 static 关键字。 参数作用域：属于函数的局部变量。 php中常见的输出语句 echo(): 可以一次输出多个值，多个值之间用逗号分隔。echo是语言结构(language construct)，而并不是真正的函数，因此不能作为表达式的一部分使用。 print(): 函数print()打印一个值（它的参数），如果字符串成功显示则返回true，否则返回false。 print_r(): 可以把字符串和数字简单地打印出来，而数组则以括起来的键和值得列表形式显示，并以Array开头。但print_r()输出布尔值和NULL的结果没有意义，因为都是打印”\\n”。因此用var_dump()函数更适合调试。 var_dump(): 判断一个变量的类型与长度,并输出变量的数值,如果变量有值输的是变量的值并回返数据类型。此函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。 数据类型字符串（String） 双引号串中的内容可以被解释而且替换，而单引号串中的内容总被认为是普通字符。 在单引号串中甚至反斜杠也失去了他的扩展含义（除了插入反斜杠\\和插入单引号\\’）。 所以，当你想在字串中进行变量代换和包含\\n（换行符）等转义序列时，你应该使用双引号。单引号串可以用在其他任何地方，脚本中使用单引号串处理速度会更快些。 整型（Integer） 整数是一个没有小数的数字。 浮点型（Float）-浮点数是带小数部分的数字，或是指数形式。 布尔型（Boolean）数组（Array）对象（Object） 类似于java的类 123456789101112&lt;?php class Car &#123; var $color; function Car($color=&quot;green&quot;) &#123; $this-&gt;color = $color; &#125; function what_color() &#123; return $this-&gt;color; &#125; &#125;?&gt; NULL值 NULL值表示变量没有值。NULL是数据类型为NULL的值。 NULL值指明一个变量是否为空值。同样可用于数据空值和NULL值的区别。 可以通过设置变量值为 NULL 来清空变量数据 字符串函数 strlen(string)函数：返回字符串长度 strpos(seacher,char)函数：查找一个字符串在另一个字符串中第一次出现的位置 数组排序 sort() - 对数组进行升序排列 rsort() - 对数组进行降序排列 asort() - 根据关联数组的值，对数组进行升序排列 ksort() - 根据关联数组的键，对数组进行升序排列 arsort() - 根据关联数组的值，对数组进行降序排列 krsort() - 根据关联数组的键，对数组进行降序排列 PHP 超级全局变量 $GLOBALS：是一个包含了全部变量的全局组合数组。变量的名字就是数组的键。 $_SERVER：是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。 $_REQUEST：用于收集HTML表单提交的数据。 $_POST：被广泛应用于收集表单数据，在HTMLform标签的指定该属性：&quot;method=&quot;post&quot;。 从带有 POST 方法的表单发送的信息，对任何人都是不可见的（不会显示在浏览器的地址栏） 并且对发送信息的量也没有限制。 $_GET：同样被广泛应用于收集表单数据，在HTMLform标签的指定该属性：&quot;method=&quot;get&quot;。$_GET也可以收集URL中发送的数据。 从带有 GET 方法的表单发送的信息，对任何人都是可见的（会显示在浏览器的地址栏） 并且对发送信息的量也有限制。 $_FILES $_ENV $_COOKIE $_SESSION PHP魔术变量 __LINE__：文件中的当前行号。 __FILE__：文件的完整路径和文件名。 __DIR__：文件所在的目录。 __FUNCTION__：函数名称。 __CLASS__：类的名称。 __TRAIT__：trait的名称。 __METHOD__：类方法的名称。 __NAMESPACE__：命名空间的名称。 XSS又叫 CSS (Cross-Site Script) 跨站脚本攻击。恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。 正则 邮箱：/([\\w\\-]+\\@[\\w\\-]+\\.[\\w\\-]+)/ URL：/\\b(?:(?:https?|ftp):\\/\\/|www\\.)[-a-z0-9+&amp;@#\\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\\/%=~_|]/i 只有字母和空格：/^[a-zA-Z ]*$/ Get 与 Post何时用method=”get”？ 在 HTML 表单中使用 method=”get” 时，所有的变量名和值都会显示在 URL 中。 注释：所以在发送密码或其他敏感信息时，不应该使用这个方法！ 然而，正因为变量显示在URL中，因此可以在收藏夹中收藏该页面。在某些情况下，这是很有用的。 注释：HTTP GET 方法不适合大型的变量值。它的值是不能超过 2000 个字符的。 何时用method=”post”？ 从带有 POST 方法的表单发送的信息，对任何人都是不可见的，并且对发送信息的量也没有限制。 然而，由于变量不显示在 URL 中，所以无法把页面加入书签。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yangkunyi.com/tags/笔记/"},{"name":"PHP","slug":"PHP","permalink":"http://yangkunyi.com/tags/PHP/"}]},{"title":"JavaScript调试","date":"2017-11-16T10:38:42.000Z","path":"2017/11/16/JavaScript调试/","text":"本文就想总结一些调试的方法，其实调试是提高效率的重要方法之一，会用正确高效的调试方法，可以事半功倍。 1、最常用console.log（简单数据输出） 这就没有什么好解释的，不过输出也是有技巧的，那就是要格式化，简单说就是要有标志性，只有数据或许会让人不理解，最好是加上前缀 123// exampleconsole.log(&quot;fun&apos;s result---&quot; + fun(2));console.log(&quot;value of a---&quot; + a); 当然可以改变颜色和字体等 2、debugger：断点 与console.log相比，debugger会在执行的过程中停在你想的地方，能够更加直接的看到执行过程。 3、将对象以表格的形式展示console.table() 将对象强制用表格打出来，这样展开的对象键值对应更加清晰 注意firefox有限制，最多显示1000行 4、尝试适配各种机型屏幕大小 这个对开发手机页面很有帮助 其次是可以检查布局问题 5、如何快速找到对应的DOM元素 方法1浏览器的快速选择工具 方法2是通过参数访问，浏览器有将DOM元素进行编号，可以通过$x的方式去访问。（具体后续补充） 6、使用console.time()和console.timeEnd()来记录时间 关注函数运行的时间是提高效率的方法之一 获取某个函数的Stacktrace console.trace() 向Web控制台输出一个堆栈跟踪 将minify的代码还原 {} 快速定位需要debug的函数 debug(funName) 会在执行函数的地方停下来 屏蔽不相关的脚本 注释掉 查看某个函数调用和其参数 monitor(funName) Postman很好用，不过传说Firefox更快 但由于本人喜欢用chrome，所以没有用尝试firefox","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yangkunyi.com/tags/Javascript/"}]},{"title":"域名的购买和绑定","date":"2017-11-15T09:42:30.000Z","path":"2017/11/15/域名的购买和绑定/","text":"终于下定决心，自己在阿里云上购买了域名，开始将自己的博客放到一个更大的“池塘”里面了，之后的学习，希望自己能继续坚持。 购买域名 前期翻看了很多关于在哪里购买域名的博文，最后还是决定就在阿里云买了，原因如下：（其实很早就想买了，但是之前还是觉得自己技术不成熟吧，买了也是浪费，不过现在觉得，买了就有更大的动力学习了） 为了让自己的博客更有识别度 作为一个新手，阿里云的性能已经很够用了 价格一般，作为大学生，还是能负担 阿里云在国内也算有名了吧 购买方法很简单啊，只要去官网就好了阿里云 域名绑定 之前自己的博客是挂在github上面直接用的免费的github pages，为了更有识别度，便买了域名，因为还没有购买服务器，（准备在接下来一年内完成这任务）所以之后项目还是会放在github上。 因此这样的话，绑定域名就很简单了。 域名的解析，在阿里云的后台管理进行如下设置 然后是github项目的重定向 用过github pages的都知道，github赠送的域名是yourgithubname.github.io，而我们现在要做的就是将这个页面重定向到我们申请的域名上去 方法如下： 方法1. 直接更改项目设置中的pages设置，如图： 方法2.在项目的根目录中新建一个CNAME文件，文件的内容就是我们申请的域名： 最后就是等待了（时间长短不定，本人感觉并没有等很久），就可以通过我们自己申请的域名访问项目页面了。","tags":[{"name":"域名","slug":"域名","permalink":"http://yangkunyi.com/tags/域名/"}]},{"title":"学习PHP之环境搭建","date":"2017-09-30T04:02:08.000Z","path":"2017/09/30/学习PHP之环境搭建/","text":"注：因为搭建的是本地的服务器，所以只有自己的电脑开着的时候，才能访问到。 一、注册域名 这是一个免费域名的注册地址www.noip.com，这种网站有很多，只是本人用的这一个，可自由选择。 注册登录即可。（一个简单的域名注册申请，就不再赘述了） 根据自己的ip注册后的结果是这样（要特别注意的是ip地址的填写，不知道自己此刻的ip地址可以用命令行查询；此处的ip地址会根据你使用的网络而改变）： 二、架构包的安装 下载架构包（架构包当然也有很多种，本人使用的是链接中的这个）AppSever8.6.0 安装架构包（跟着流程走就好了，规则就是两个键按左边，三个键按中间，一个键就只能按它咯~）注意安装目录的选择！安装完之后，会有一个这样的目录： 测试：在浏览器地址栏中输入你之前申请的并且与ip地址对应的域名，当看到以下结果，说明你ok了，否则请从头开始=_=（嘿嘿，有问题肯定是某个步骤出了问题，仔细检查）： 此处显示的是，文件夹www中的index.php文件 当然我们希望这些关于服务器的各种信息只有我们自己能看到，而别人看不到，很简单，将文档的名字改成只有你自己知道就好了: 既然index文件已经被我们改掉了，因此可以开始写第一个index文件了，此刻网页会自动显示该文件（之后就可以开始写自己的网页了）： 123456789101112// index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p style=&quot;font-size: 50px;color: #66ccff;&quot;&gt;啦啦啦&lt;/p&gt; &lt;p style=&quot;font-size: 40px;color: red&quot;&gt;完了&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"学习","slug":"学习","permalink":"http://yangkunyi.com/tags/学习/"},{"name":"PHP","slug":"PHP","permalink":"http://yangkunyi.com/tags/PHP/"}]},{"title":"画地为牢","date":"2017-08-04T01:16:39.000Z","path":"2017/08/04/画地为牢/","text":"它是一套规则，这套规则用来管理引擎如何在当前作用域及嵌套的子作用域中根据标识符名称进行变量的查找。 1234if(true) &#123; var num = 10;&#125;console.log(num); 思考：JavaScirpt怎样才会形成作用域？ 函数作用域 就是说，在JavaScript中，在函数里面定义的变量，可以在函数里面被访问，但是在函数外无法访问。 1234var func = function() &#123; var num = 10;&#125;;console.log(num); 1234var func = function() &#123; var num = 10; console.log(num);&#125;; 前面说了，函数可以限定变量的作用域，那么在函数中的函数就成为该作用域的子域。在子域中的代码可以访问到父域中的变量。 12345678var func = function() &#123; var num = 10; var sub_func = function() &#123; console.log(num); &#125;; sub_func();&#125;;func(); 123456789var func = function() &#123; var num = 10; var sub_func = function() &#123; var num = 20; console.log(num); &#125;; sub_func();&#125;;func(); 由此可见访问有一定规则可言。在JavaScript中使用变量，JavaScript解释器首先在当前作用域中搜索是否有该变量的定义，如果有，就是用这个变量；如果没有就到父域中寻找该变量。以此类推，直到最顶级作用域，仍然没有找到就抛出异常”变量未定义”。 123456789(function() &#123; var num = 10; (function() &#123; var num = 20; (function()&#123; console.log(num); &#125;)() &#125;)();&#125;)(); 块级作用域 思考：什么叫块级作用域？ 123456789function outputNumbers(count)&#123; for (var i=0;i&lt;count;i++)&#123; console.log(i); &#125; console.log(i) var i; console.log(i);&#125;outputNumbers(3); 很遗憾，在es6之前，javascript是没有块级作用域的。所以也会因此造成对一些变量值的忽视，从而引起程序运行结果不对。那前辈们遇到这个问题是怎么做的呢？让我们来考考古。 利用函数来实现块级作用域 因为函数是js里唯一具有块级作用域特点的。 123456789function outputNumbers(count)&#123; (function()&#123; for (var i=0;i&lt;count;i++)&#123; console.log(i); &#125; &#125;)(); console.log(i);&#125;outputNumbers(3); 思考：这是不是一个闭包？ 方法类（不建议使用）with 用with从对象创建出的作用域仅在with声明中而非外部作用域中有效。1234567891011121314151617function foo(obj) &#123; with (obj) &#123; var a = 2; &#125;&#125;var o1 = &#123; a: 3&#125;;var o2 = &#123; b: 3&#125;;foo( o1 );console.log( o1.a );foo( o2 );console.log( o2.a );console.log( a ); try/catch1234567try&#123; undefined();//执行一个非法操作来强制制造一个异常&#125;catch(err)&#123; console.log(err)//能够正常执行&#125;console.log(err); ES6中的块级作用域 将代码在函数中隐藏的信息扩展为在块中隐藏起来。 let(不能重复声明) let关键字可以将变量绑定到所在的任意作用域中。 垃圾回收 12345678function process(data)&#123; //在这里做点有趣的事情&#125;&#123;//在这个块中定义的内容完事可以销毁 let someReallyBigData=&#123;...&#125;; process(someReallyBigData);&#125; let循环 1234for(let i=0;i&lt;10;i++)&#123; console.log(i);&#125;console.log(i); const（不能重复声明） 定义一个该块的常量，不能修改值。 12345678910var foo = true;if (foo) &#123; var a = 2; const b = 3; a = 3; b = 4;&#125;console.log(a);console.log(b); 作用域链 因为作用域是一套用于确定在何处以及如何查找变量的规则，我对作用域链的理解就是查找变量所走的路。 建筑 根据这个图来理解，就是查找变量所爬的楼。 树 爬楼太累了，我们再看看用画树的方法再来看看。 绘制规则 作用域链就是对象的数组 全局作用域是0级链，每个对象占一个位置 凡是看到函数延伸一个链出来，一级级展开 访问首先看当前函数，如果没有定义往上一级链检查 如此往复，直到0级链 123456789101112131415161718var num = 10;var func1 = function() &#123; var num = 20; var func2 = function() &#123; var num = 30; console.log(num); &#125;; func2();&#125;;var func2 = function() &#123; var num = 20; var func3 = function() &#123; console.log(num); &#125;; func3();&#125;;func1();func2(); 现场绘制一波 预解析 形成变量提升现象1234567var num = 10;var func = function() &#123; console.log(num); var num = 20; console.log(num);&#125;;func(); 函数提升12345678910var func = function() &#123; console.log(&quot;调用外面的函数&quot;);&#125;;var foo = function() &#123; func(); var func = function() &#123; console.log(&quot;调用内部的函数&quot;); &#125;; func();&#125;; 预解析：在当前作用域下,js运行之前，会把带有var和function关键字的事先声明，并在内存中安排好，然后再从上到下执行js语句。预解析只会发生在通过var定义的变量和function上。 var 只要是通过var定义的，不管是变量，还是函数，都是先赋值undefined，如果是变量，也不管变量有没有赋值，在预解析阶段，都是会被赋值为undefined。 function function进行预解析的时候，不仅是声明而且还定义了，但是它存储的数据的那个空间里面存储的是代码是字符串，没有任何意义。 123function fun() &#123; //代码区&#125;(); 定义一个函数想要立即执行，写成上面的形式是不可行的，在预解释的时候，它把它分解成两部分来对待，第一部分是fun函数，而第二部分是(),一个匿名函数，执行时会报错。如果小括号带参数，如(2)，虽然不会报错，会打印出来2，但并不能把fn执行，也不能当成参数传递给fn函数。 如果你想实现立即执行的函数，可以把要执行的函数放到一对括号里面，对于JavaScript 来说，括弧()里面不能包含语句，所以在这一点上，解析器在解析function关键字的时候，会将相应的代码解析成function表达式，而不是function声明所以，只要将大括号将代码(包括函数部分和在后面加上一对大括号)全部括起来就可以了。 如下： 123(function fun() &#123; //代码区&#125;()); 预解析是发生在当前作用域下的，刚开始的时候，我们预解析的是全局作用域，在js中我们的global就是我们的window。 我们运行函数的时候会生成一个新的私有作用域（每次执行都是新的，执行完成就销毁）这个作用域下我们可以理解为开辟了一个新的内存空间。在这个内存中我们也要执行预解析。当我们的函数执行完成后，这个内存或者作用域就会销毁。 如果在当前作用域下的一个变量没有预解析，就会向它的上一级去找，直到找到window，如果window下也没有定义，就会报错。所以，在函数内通过var定义的变量是局部变量，没有通过var定义的变量是全局变量。 预解析不会在同一个变量上重复的发生，也就是一个变量如果已经在当前作用域下预解析了，不会再重复解析。 等号右边的function不会进行预解析。 预解释是不受其它if或者其它判断条件影响的，也就是说，即使条件不成立，我们里面只要有var或者function也会被预解释。 后面定义的会覆盖前面定义的。 一些例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 例子一if(!(&quot;a&quot; in window))&#123; var a = &quot;李玉华&quot;；&#125;console.log(a);// 例子二function fn()&#123; console.log(&quot;我们是全局的fn&quot;);&#125;function fn2()&#123; console.log(fn); fn = 3; return ; function fn()&#123; console.log(&quot;我是fn2里面的&quot;); &#125;&#125;fn2();// 例子三var n = 0;function a()&#123; var n = 10; function b()&#123; n++; console.log(n); &#125; b(); return b;&#125;var c = a(); c(); console.log(n); // 例子四var n = 99;function outer()&#123; var n = 0; return function inner()&#123; return n++; &#125;&#125;var c = outer(); var num1 = c();var num2 = c();var d = outer();var num3 = d();console.log(c);console.log(num1);console.log(num2);console.log(d);console.log(num3); 总结 作用域就是根据标识符查找变量的一套规则。（路标） 作用域链就是找变量所走的路径。 预解析就是万恶的“VIP”。 注： ReferenceError作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。 参考链接 作用域和作用域链 块级作用域 作用域和原型","tags":[{"name":"分享","slug":"分享","permalink":"http://yangkunyi.com/tags/分享/"},{"name":"作用域","slug":"作用域","permalink":"http://yangkunyi.com/tags/作用域/"},{"name":"作用域链","slug":"作用域链","permalink":"http://yangkunyi.com/tags/作用域链/"},{"name":"预解析","slug":"预解析","permalink":"http://yangkunyi.com/tags/预解析/"}]},{"title":"作用域和原型","date":"2017-08-02T11:29:16.000Z","path":"2017/08/02/作用域和原型/","text":"什么是作用域？ 它是一套规则，这套规则用来管理引擎如何在当前作用域及嵌套的子作用域中根据标识符名称进行变量的查找。 先介绍一下RHS和LHS 这是引擎的两种查找类型 “R”和“L”分别代表赋值操作的右侧和左侧 案例 123456function foo(a)&#123;//对a进行LHS引用2 console.log(a); //对console进行RHS引用3 //对a进行RHS引用4&#125;foo(2);//对foo进行RHS引用1 当变量还没有声明的时候（在任何作用域都找不到该变量），这两种查询的行为是不一样的：LHS查询会在全局作用域中自己创建一个变量。RHS查询会抛出一个ReferenceError错误。 作用域的嵌套 当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。这一就形成了一条作用域链。 案例 12345function foo(a)&#123; console.log(a+b);&#125;var b=2;foo(2);//4 将作用域链比喻成一个建筑 词法作用域 词法作用域是由你写代码时将变量和块作用域写在哪里来决定的。 案例 JavaScript中有两个机制可以“欺骗”词法作用域 eval() 例子： 123456789101112131415function foo(str, a) &#123; eval( str ); // 欺骗！ console.log( a, b );&#125;var b = 2;foo( &quot;var b = 3;&quot;, 1 );//严格模式// function foo(str) &#123;// &quot;use strict&quot;;// eval( str );// console.log( a ); // ReferenceError: a is not defined// &#125;foo( &quot;var a = 2&quot;); with() 例子： 123456789101112131415161718function foo(obj) &#123; with (obj) &#123; var a = 2; &#125; // a = 2;&#125;var o1 = &#123; a: 3&#125;;var o2 = &#123; b: 3&#125;;foo( o1 );console.log( o1.a );foo( o2 );console.log( o2.a );console.log( a ); 函数作用域 在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。 案例 1234567var a=2;function foo()&#123; var a=3; console.log(a);//3&#125;foo();console.log(a);//2 不足之处： 必须声明一个foo函数，这个foo“污染”了所在作用域。 必须显示调用才能运行其中的代码 改进 1234567var a=2;(function foo()&#123; var a=3; console.log(a);//3&#125;)();console.log(a);//2//函数会被当作函数表达式而不是一个标准的函数声明来处理。 匿名函数 优点： 书写起来简单快捷 缺点： 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。 如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用。（callee是arguments对象的一个属性。它可以用于引用该函数的函数体内当前正在执行的函数。） 匿名函数省略了对于代码可读性/可理解性很重要的函数名。 立即执行函数表达式 IIFE(Immediately Invoked Function Expression)：(function foo(){...})() 函数名对IIFE来说不是必须的：(function(){...}()) 进阶用法：当作函数调用并传参数进去。 例子：12 块作用域 块作用域将代码在函数中隐藏的信息扩展为在块中隐藏起来。 思考 12345for(var i=0;i&lt;10;i++)&#123; console.log(i);&#125;console.log(i);//为什么要把一个只在for循环内部使用（至少是应该只在内部使用）的变量i“污染”到整个作用域（不管是函数还是全局）中？ with：用with从对象创建出的作用域仅在with声明中而非外部作用域中有效。 try/catch：例子：try.html let：let关键字可以将变量绑定到所在的任意作用域中。 垃圾回收 12345678function process(data)&#123; //在这里做点有趣的事情&#125;&#123;//在这个块中定义的内容完事可以销毁 let someReallyBigData=&#123;...&#125;; process(someReallyBigData);&#125; let循环 1234for(let i=0;i&lt;10;i++)&#123; console.log(i);&#125;console.log(i);ReferenceError const：定义一个该块的常量，不能修改值。例子： 12345678var person = function(name)&#123; this.name = name&#125;;person.prototype.getName = function()&#123; console.log(this.name);&#125;var zjh = new person(&apos;zhangjiahao&apos;);zjh.getName(); //zhangjiahao 原型[prototype]普通对象和函数对象 JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象。 123456789101112131415161718var o1 = &#123;&#125;; var o2 =new Object();var o3 = new f1();function f1()&#123;&#125;; var f2 = function()&#123;&#125;;var f3 = new Function(&apos;str&apos;,&apos;console.log(str)&apos;);console.log(typeof Object); //function console.log(typeof Function); //function console.log(typeof f1); //function console.log(typeof f2); //function console.log(typeof f3); //function console.log(typeof o1); //object console.log(typeof o2); //object console.log(typeof o3); //object 怎么区分，其实很简单，凡是通过new&nbsp;Function()创建的对象都是函数对象，其他的都是普通对象。f1,f2,归根结底都是通过new&nbsp;Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的。 什么是prototype？ 在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype属性，这个属性指向函数的原型对象。 12345678910111213141516function Person() &#123; Person.prototype.name = &apos;Zaxlct&apos;; Person.prototype.age = 28; Person.protetype.job = &apos;Software Engineer&apos;; Person.prototype.sayName = function() &#123; alert(this.name); &#125;&#125;var person1 = new Person();person1.sayName(); // &apos;Zaxlct&apos;var person2 = new Person();person2.sayName(); // &apos;Zaxlct&apos;console.log(person1.sayname == person2.sayname); //true 只有函数对象才有 prototype 属性 什么是原型对象？ 原型对象，顾名思义，它就是一个普通对象。从现在开始你要牢牢记住原型对象就是 Person.prototype，如果你还是记不住，那就把它想想成一个字母 A： var A = Person.prototype; 12345678Person.prototype = &#123; name: &apos;Zaxlct&apos;, age: 28, job: &apos;Software Engineer&apos;, sayName: function() &#123; alert(this.name); &#125;&#125; 在默认情况下，所有的原型对象都会自动获得一个constructor（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数（Person） 原型对象（Person.prototype）是 构造函数（Person）的一个实例。 那原型对象是用来做什么的呢？举个例子： 12345678var person = function(name)&#123; this.name = name&#125;;person.prototype.getName = function()&#123; return this.name;&#125;var zjh = new person(‘zhangjiahao’);zjh.getName(); //zhangjiahao 从这个例子可以看出，通过给person.prototype设置了一个函数对象的属性，那由person实例（例中：zjh）出来的普通对象就继承了这个属性。所以原型对象的主要作用就是用于继承。 具体是怎么实现的继承，就要讲到下面的原型链了。 什么是原型链？ JS在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做__proto__的内置属性，用于指向创建它的函数对象的原型对象prototype。例如： console.log(zjh.__proto__ === person.prototype) //true 同样，person.prototype对象也有__proto__属性，它指向创建它的函数对象（Object）的prototype console.log(person.prototype.__proto__ === Object.prototype) //true 继续，Object.prototype对象也有__proto__属性，但它比较特殊，为null console.log(Object.prototype.__proto__) //null 我们把这个有proto串起来的直到Object.prototype.proto为null的链叫做原型链。 注 ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。 区分函数声明和表达式最简单的方法是看function关键字出现在声明这哦那个的位置（不仅仅是一行代码，而是整个声明中的位置）。如果function是在声明的第一个词，那么就是一个函数声明，否则就是一个函数表达式。 作用域理解基于《你不知道的Javascript 上卷》 原型理解基于文章原型与原型链","tags":[{"name":"分享","slug":"分享","permalink":"http://yangkunyi.com/tags/分享/"},{"name":"Javascript","slug":"Javascript","permalink":"http://yangkunyi.com/tags/Javascript/"}]},{"title":"JavaSccript语言精粹","date":"2017-07-20T07:01:07.000Z","path":"2017/07/20/JavaSccript语言精粹/","text":"知识点 字符串是不可变的。一旦被创建就永远无法改变。 typeof运算符产生的值有‘number’ ‘string’ ‘boolean’ ‘undefined’ ‘function’ ‘object’。 一个属性存取表达式用于指定一个对象或数值的属性或元素。 原型连接只有在检索值的时候才被用到。如果我们尝试弃获取对象的某个属性值，但该对象没有此属性名，那么JavaScript会试着从原型对象中获取属性值。如果那个原型对象也没有该属性，那么再从它的原型中寻找，依次类推，只到该过程最后到达终点Object.prototype。如果想要的属性完全不存在于原型练中，那么结果就是undefined值。这个过程为委托。 用for in的方法来遍历一个对象中的所有属性名，属性名出现的顺序是不确定的，因此要对任何可能出现的顺序有所准备。若想自定义顺序最好的方式是避免使用for in，而是通过建立数组的形式将属性存入，然后用for循环从数组中依次获取属性。这样也不用担心可能发掘出原型链中的属性，并且我们按正常的顺序取得了它的值。 最小化使用全局变量的方法之一是为你的应用只创建一个唯一的全局变量。资源都纳入一个名称空间之下，你的程序与其他应用程序、组件或类库之间发生冲突的可能性就会显著降低。 函数对参数值不会进行类型检查：任何类型的值都可以被传递给任何参数。 apply方法让我们构建一个参数数组传递给调用函数。 因为语言的一个设计错误，arguments并不是一个真正的数组。它只是一个“类似数组（array-like）”的对象。arguments拥有一个length属性，但它没有任何数组的方法。 尾递归是一种在函数的最后执行递归调用语句的特殊形式的递归。 作用域的好处是内部函数可以访问定义它们外部函数的参数和变量（除了this和arguments）。 继承的两种服务： 是代码重用的一种形式。（如果一个新的类与一个已经存在的类大部分相似，那么你只需要具体说明其不同点即可。代码重用的模式极为重要，因为它们可以显著的减少软件开发的成本。） 另一个好处是引入了一套类型系统的规范。（由于程序员无需编写显式类型转换的代码，他们的工作量将大大减轻，这是一件很好的事情，因为类型转换会丧失类型系统在安全上的优势。） 构造一个生成对象的函数： 1.创建一个新的对象。 2.有选择地定义私有的实例变量和放方法。 3.给这个新对象扩充方法。 4.返回那个新对象。 数组的length属性的值是这个数组的最大整数属性名加上1，它不一定等于数组里属性的个数。 for in 用来遍历数组的所有属性，但遗憾的是，for in 无法保证属性的顺序。 数组和对象的使用区别：当属性名是小而连续的整数时，你应该使用数组；否则，使用数组。 排序的稳定性是指排序后的数组中相等值的相对位置没有发生改变，而不稳定性排序则会改变相等值的相对位置。 方法篇Array array.concat(item…):产生新的数组，和它类似功能的array.push(item)。 array.join(separator):把一个array构造成一个字符串。 array.pop():移除数组的最后一个元素，并返回这个元素。 array.push(item…):把一个或多个参数item附加到一个数组的尾部。 array.reverse():反转array里的元素的顺序，并返回array本身。 array.shift():移除数组array中的第一个元素，并返回该元素。 array.slice(start,end):对array中的一段做浅复制。 array.sort(comparefn):对array中的内容进行排序。 array.splice(start,deleteCount,item…):从array中移除一个或多个元素，并用新的item替换它们。 array.unshift(item…):像push方法一样，用于把元素添加到数组中，但它是把item插入到array的开始部分，不是尾部。返回array的新的length。 Function function.apply(thisArg,argArray):调用function，传递一个会被绑定到this上的对象和一个可选的数组作为参数。 Number number.toExponential(fractionDigits):把这个number转换成一个指数形式的字符串。 number.toFixed(fractionDigits):把这个number转换成为一个十进制数形式的字符串。可选择参数控制其小数点后的数字位数。 number.toPrecision(precision):把这个number转换成一个十进制数形式的字符串。可选择参数控制数字的精度（0~21）。 number.toString(radix):把这个number转换成字符串。可选择参数控制基数（2~36，默认是10）。 Object object.hasOwnProperty(name):判断属性是否存在，不会检查原型链中的同名属性。 RegExp regexp.exec(string):最强大（和最慢），看书理解。 regexp.test(string):最简单（和最快），匹配就返回true，否则返回false，不要对这个方法使用g标识。 String string.charAt(pos):返回在string中pos位置处的字符。 string。charCodeAt(pos):返回在string中pos位置的字符的字符码位（以整数形式表示）。 string.conecat(string…):把其他的字符串连接在一起来构造一个新的字符串。 string.indexOf(searchString,postion):在string中查找另一个字符串searchString。找到就返回第一个匹配字符的位置，否则返回-1。可选参数position从字符串的哪个位置开始查找。 string.lastIndexOf(searchString,position):从字符串的末尾开始查找。 string.lacaleCompare(that):比较两个字符串。 string.match(regexp):让字符串和一个正则表达式进行匹配。 string.replace(searchValue,replaceValue):对string进行查找和替换操作，并返回一个新的字符串（如果searchValue不是一个带有g标识的正则表达式那就只会替换第一个）。 string.search(regexp):接收一个正则表达式作为对象参数返回匹配的首字符位置。 string.slice(start,end):复制string的一部分来构造一个新的字符串。 string.split(separator,limit):把这个string分割成片段来创建一个字符串数组。 string.substring(start,end):和slice方法一样，只是他不能处理负数参数。 string.toLocaleLowerCase():返回一个新字符串，使用本地化的规则将这个string中所有字母转换成小写格式。 string.toLacaleUpperCase():返回一个新字符串，使用本地化的规则将这个string中所有字母转换成大写格式。 string.toLowerCase():返回一个新的字符串，这个string中所有字母都被转换为小写格式。 string.toUpperCase():返回一个新的字符串，这个strnig中所有字母都被转换为大写格式。 string.fromCharCode(char…):函数根据一串数字编码返回一个字符串。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yangkunyi.com/tags/笔记/"}]},{"title":"vue2.0生命周期","date":"2017-06-02T02:03:58.000Z","path":"2017/06/02/vue2-0生命周期/","text":"图解 函数解释 beforeCreate在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。 created实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount在挂载开始之前被调用：相关的 render 函数首次被调用。 mountedel 被新创建的vm.\\$el替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 beforeUpdate数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 updated由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 beforeDestroy实例销毁之前调用。在这一步，实例仍然完全可用。 destroyedVue 实例销毁后调用。调用后，Vue实例指示的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/vue/2.1.3/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message : &quot;Hello!&quot; &#125;, beforeCreate: function () &#123; console.group(&apos;beforeCreate 创建前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot; , &quot;el : &quot; + this.$el); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) &#125;, created: function () &#123; console.group(&apos;created 创建完毕状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, beforeMount: function () &#123; console.group(&apos;beforeMount 挂载前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + (this.$el)); //已被初始化 console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, mounted: function () &#123; console.group(&apos;mounted 挂载结束状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); //已被初始化 console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, beforeUpdate: function () &#123; console.group(&apos;beforeUpdate 更新前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, updated: function () &#123; console.group(&apos;updated 更新完成状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, beforeDestroy: function () &#123; console.group(&apos;beforeDestroy 销毁前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, destroyed: function () &#123; console.group(&apos;destroyed 销毁完成状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用浏览器打开 beforecreated：el 和 data 并未初始化created:完成了 data 数据的初始化，el没有beforeMount：完成了 el 和 data 初始化mounted ：完成渲染 关于更新app.message= &#39;vue&#39;; 关于销毁app.$destroy(); 销毁完成后，我们再重新改变message的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在。可以这么理解，执行了destroy操作，后续就不再受vue控制了。 生命周期函数的一些用法 beforecreate : 举个栗子：可以在这加个loading事件created ：在这结束loading，还做一些初始化，实现函数自执行mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情beforeDestory： 你确认删除XX吗？destoryed ：当前组件已被删除，清空相关内容","tags":[{"name":"分享","slug":"分享","permalink":"http://yangkunyi.com/tags/分享/"},{"name":"Javascript","slug":"Javascript","permalink":"http://yangkunyi.com/tags/Javascript/"},{"name":"vue","slug":"vue","permalink":"http://yangkunyi.com/tags/vue/"}]},{"title":"微众银行App体验","date":"2017-05-27T07:29:10.000Z","path":"2017/05/27/微众银行App体验/","text":"微众银行App用户体验报告 体验环境 手机：iPhone 6 操作系统：ios 9.1 软件版本：微众银行1.9.2 时间：2017年3月2日 市场定位&nbsp;&nbsp;微众银行由腾讯公司及百业源、立业集团等知名民营企业发起设立，2014年12月经监管机构批准开业，是国内首家民营银行和互联网银行。微众银行App是为微众银行客户提供的移动端产品。它为客户提供了线上理财，线上投资，线上转账等功能，相比于传统银行更加的方便快捷，且无需线下经营，使得互联网银行的成本低于传统银行，有很大的竞争优势。&nbsp;&nbsp;微众银行的用户定位是对互联网理财有接触或俩节，同时有理财和投资需求的个体及微小型企业。因此 产品设计功能结构图 微信银行App整体有四个tag在底部，第一个tag是总体信息，剩下三个分别代表了微众银行的三大核心业务：理财，投资和存取转账。 交互界面 总览（首页） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开户前显示登录引导项引导客户登录帐号，登录的方式可以是QQ帐号登录，也可以是微信帐号登录；开户后显示客户的总资产，资产可以选择隐藏和显示，这让客户在公共场所不必担心自己的财务信息泄漏出去。另外，不管开户是否都会显示微众银行的机构代码即是由腾讯牵头等信息，是为了使客户更加信任微众银行，毕竟是首家互联网银行，客户会有所担心，是否安全、真实都是客户十分关心的，所以以这样醒目的方式给客户安全感，吸引客户，获得客户的信任。&nbsp;&nbsp;紧跟着显示活期，短期，定期，基金等理财方式的产品推荐，通过利率进一步吸引客户，同时用不同的颜色也区分了产品的性质，深色代表安全性高；浅一定的颜色代表风险较高，但利率相对也高。&nbsp;&nbsp;在最后一栏显示了用户使用数据，进一步给用户安全感，留住客户。 理财 &nbsp;&nbsp;顶部的图文十分醒目，能够吸引顾客的眼球，跟着是各种业务，用鲜艳的颜色体现出收益，同时还为客户推荐精选产品；紧接着是保险服务“一次缴费，终生领取”，宣传语极大的吸引了客户；最后的即将开售板块对即将开售的产品进行了宣传。 投资 &nbsp;&nbsp;基金，微众金，结构化投资产品类型板块让用户对投资产品一目了然。中间最醒目的板块是一个专门针对基金的投资引导，对普通债券型基金，或者混合型基金的现状进行分析和引导购买。紧接着是热门的投资，给用户更多的选择。&nbsp;&nbsp;底部是一些投资相关资料的普及，例如外汇投资更划算，或者是新手入门的教学。 转账 &nbsp;&nbsp;为开户的就没有管理银行卡的板块。存取计划是用户自定义设置每月存取的时间，数额，卡号等，进行每月定时存取款。 我板块 &nbsp;&nbsp;我板块按钮在顶部头像处，类似于QQ。我板块的各种功能都是为了让客户享受高质量的客户服务，给客户人性化的体验，让用户了解微众银行，获得客户的信任。（个人觉得我板块虽然类似于QQ，可是打开和关闭都只能点击不能滑动，也可能是使用智能手机的习惯，突然滑动不了，感觉不是很方便。）","tags":[{"name":"学习","slug":"学习","permalink":"http://yangkunyi.com/tags/学习/"},{"name":"新媒体","slug":"新媒体","permalink":"http://yangkunyi.com/tags/新媒体/"},{"name":"App分析","slug":"App分析","permalink":"http://yangkunyi.com/tags/App分析/"}]},{"title":"换届题目","date":"2017-04-27T04:45:23.000Z","path":"2017/04/27/换届题目/","text":"面临换届，为学弟学妹出一份问卷，想寻找喜欢新媒体的同学加入我们的团队。 一年总结 （至少包括以下内容，可以补充） 大一（大二）在新媒体中心做了些什么 学到了什么 自己的对新媒体的看法 你想对新媒体中心说什么 字数要求（800字） 谈谈发展 是否愿意继续留在新媒体中心学习与做事 谈谈原因（包括自己和新媒体中心） 字数要求（无） 做一份作业（形式不限，内容：毕业季Or军训） 你将拟定什么样的一个主题 如果让你运营公众号，你将用什么样的形式推送什么样的内容 作业要求（有逻辑，搭建起基本框架，有态度，有想法，有创意）","tags":[{"name":"新媒体","slug":"新媒体","permalink":"http://yangkunyi.com/tags/新媒体/"}]},{"title":"坎帕斯学院日常讨论","date":"2017-04-16T08:14:15.000Z","path":"2017/04/16/坎帕斯学院日常讨论-1/","text":"话题：width：100%和width：auto的区别 width：100% 元素宽度等于父级元素的宽度。 width：auto 元素的宽度等于父元素的宽度减去margin，padding，border这些。 高度知识点 子元素的margin和padding百分比知识点根据父元素的width来算。123456789101112131415161718192021222324//test1&lt;style&gt; body&#123; margin:0; padding:0; &#125; .main&#123; width:500px; background:red; &#125; .test&#123; width:auto; padding:20px; margin:10px; border:5px solid blue; background:green; &#125;&lt;/style&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;test&quot;&gt;123&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; test width=父元素width-margin-padding-border 123456789101112131415161718192021222324//test2&lt;style&gt; body&#123; margin:0; padding:0; &#125; .main&#123; display:inline-block; background:red; &#125; .test&#123; width:auto; padding:20px; margin:10px; border:5px solid blue; background:green; &#125;&lt;/style&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;test&quot;&gt;123123123123123&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; test width=123123123123123+margin+padding+border 1234567891011121314151617181920212223242526//test3&lt;style&gt; body&#123; font-size:20px; margin:0; padding:0; &#125; .main&#123; display:inline-block; background:red; width:500px; &#125; .test&#123; width:auto; padding:20px; margin:10px; border:5px solid blue; background:green; &#125;&lt;/style&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;test&quot;&gt;123123123123123&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; test width=500-padding-margin-border这里的500px并不是继承，而是因为div块级元素的影响而来的。 123456789101112131415161718192021222324252627//test4a&lt;style type=&quot;text/css&quot;&gt; body&#123; font-size: 20px; padding: 0; margin: 0; &#125; .first1&#123; background: red; width: 200px; height: 400px; overflow: hidden; &#125; .second1&#123; height: 25%;width: 25%; margin-top: 10%; background-color: green; padding-left: 10%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;first1&quot;&gt; &lt;div class=&quot;second1&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; test width=50,height=100,margin-top=20 2017.4.19 21:00话题：document.getElementByClassName()返回的是什么？ 是一个HTML集合。 集合和数组的区别 HTML集合：一直与文档保持着链接，每次你需要最新的信息时，都会重复执行查询的过程，哪怕只是获取集合里的元素个数，即集合的length属性也是这样。（简单的说就是这个集合会实时改变） 案例：12345var alldivs document.getElementsByTagName(&apos;div&apos;);for(var i=0;i&lt;alldivs.length;i++)&#123; document.body.appendChild(document.createElement(&apos;div&apos;));&#125;//该循环会一直循环下去，因为每次添加一个div之后，alldicvs.length的值也会改变，导致循环条件一直为true，一直循环。 关于闭包和词法作用域 案例：12345678910function foo()&#123; concile.log(a);//2&#125;function bar()&#123; var a=3; foo();&#125;var a=2;bar();//原理：js的运行原理是词法作用域，而非动态作用域，因此当foo函数被调用的时候，对a进行查询的时候会直接在全局作用域中查询。 话题：display：none和visibility：hidden区别？ display：none；有dom树，没有渲染树，也就是说js可以找到display：none。 visibility：hidden；只是将内容隐藏起来了，还是要占位的。 话题：两个inline-block元素在同一行中间的那个间距是多少？ 每个浏览器间距不同。 字体大小不同间距不同。 如何去掉这个空格？ 去掉最底层html标签的空格。 margin为负值。（每个浏览器不同，值不同） 将父级元素的字体大小设置为0。（推荐方案） 注意： 这个间距不仅在水平方向有，在垂直方向也有！ 距离大概是字体大小的1/8（可能会有叠加）。 inline-block元素之间，block和inline-block和inline的元素之间都有间距。","tags":[{"name":"前端","slug":"前端","permalink":"http://yangkunyi.com/tags/前端/"},{"name":"讨论","slug":"讨论","permalink":"http://yangkunyi.com/tags/讨论/"},{"name":"问题","slug":"问题","permalink":"http://yangkunyi.com/tags/问题/"},{"name":"记录","slug":"记录","permalink":"http://yangkunyi.com/tags/记录/"}]},{"title":"数组","date":"2017-04-10T11:13:22.000Z","path":"2017/04/10/数组/","text":"Array创建实例 1234567891011//用构造函数的方法var colors=new Array();var colors=new Array(20);var colors=new Array(&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;);var colors=Array();//可以省略new//用数组字面量表示法var colors=[&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;];var names=[];var values=[1,2,];//不要这样，这样会创建一个包含2或3项的数组var options=[,,,,,]//不要这样，这样会创建一个包含2或6项的数组 检测数组 Array.isArray()确定一个值到底是不是数组转换方法 toString()：返回有由数组中每个值得字符串形式拼接而成的一个以逗号分隔的字符串。 valueOf()：直接返回数组 toLocaleString()：创建一个数组值的以逗号分隔的字符串。 1234567891011121314151617181920212223242526var colors=[&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;];alert(colors.toString()); //gray,green,redalert(colors.valueOf()); //gray,green,redalert(colors); //gray,green,red//最后一行将数组传给alert，alert要求接受字符串，所以后台自动调用头String（）var person1=&#123; toLocaleString:function()&#123; return &quot;Nikolaos&quot;; &#125;, toString:function()&#123; return &quot;Nicholas&quot;; &#125;&#125;;var person2=&#123; toLocaleString:function()&#123; return &quot;Grigorios&quot;; &#125;, toString:function()&#123; return &quot;Greg&quot;; &#125;&#125;;var people=[person1,person2];alert(people); //Nicholas,Gregalert(people.toString()); //Nicholas,Gregalert(people.toLocaleString()); //Nicholas,Grigorios join()方法：可以用其他符号来分隔数组 123var colors=[&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;];alert(colors.join(&quot;,&quot;)); //gray,green,redalert(solors.join(&quot;||&quot;)); //gray||green||red 栈方法 push()方法可以接受任意数量的参数，把他们逐个添加到数组末尾，并返回修改后的数组的长度。 pop()方法则是从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。123456789101112131415var colors=new Array();var count=colors.push(&quot;red&quot;,&quot;green&quot;);alert(count); //2count=colors.push(&quot;black&quot;);alert(count); //3var item=color.pop();alert(item); //&quot;black&quot;;alert(colors.length); //2//可以将栈方法和其它数组方法连用var colors=[&quot;red&quot;,&quot;blue&quot;];colors.push(&quot;brow&quot;);colors.[3]=&quot;black&quot;;alert(colors.length); //4var item=colors.pop();alert(item); //&quot;black&quot; 队列方法 shift()方法能够移除数组中的第一项，并且返回该项，同时将数组长度减1。 unshift()方法能在数组前段端添加任意个项并返回数组长度。12345678var colors=new Array();var count=colors.push(&quot;red&quot;,&quot;green&quot;);alert(count); //2var item=colors.shift();alert(item); //&quot;red&quot;alert(colors.length); //1count=colors.unshift(&quot;black&quot;);alert(count); //2 排序 reverse()方法：反转数组项的顺序。返回值是数组。 sort()方法：按升序排列数字项。（比较的是字符串）返回值是数组。1234567891011121314151617181920var values=[1,2,3,4,5];values.reverse();alert(values); //5,4,3,2,1var values=[0,1,5,10,15];values.sort();alert(values); //0,1,10,15,5//在字符串进行比较的时候5是比10大的，这个时候我们经常让sort方法接受一个比较函数作为参考。//比较函数（升序，改变大于和小于就能变成降序）function campare(value1,value2)&#123; if(value1&lt;value2) return -1; else if(value1&gt;value2) return 1; else return 0;&#125;var values=[0,1,5,10,15];values.sort(campare);alert(values); //0,1,5,10,15 操作方法 concat()方法：创建一个新的数组。复制一遍数组并在末尾添上新的元素。 1234var colors=[&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;];var colors2=colors.contac(&quot;yellow&quot;,[&quot;black&quot;,&quot;brown&quot;]);alert(colors); //gray,green,redalert(colors2); //gray,green,red,yellow,black,brown slice()方法：能够基于当前数组中的一或多个项创建一个新数组。 当有一个参数时：返回从该参数指定位置开始到当前数组末尾的所有项。 如果有两个参数时：返回起始和结束位置之间的项，但不包括结束为止的项。 splice()方法：主要用途是项数组中部插入项。（最强大的数组方法） 删除：需要两个参数，位置和删除项数。例：splice(0,2);删除数组中的前两项。 插入：需要三个参数，起始位置，0（删除的项数）和插入项。例：splice(2,0,&quot;red,&quot;green&quot;)从数组的位置2开始插入字符串”red”和”green”。 替换：需要三个参数，起始位置，要删除的的项数和要插入的任意数量的项。例：splice(2，1，&quot;red&quot;,&quot;green&quot;)删除当前数组位置2的项，然后再从位置2开始插入字符串。位置方法 indexOf()方法：从数组的开头开始向后查找。 lastIndexOf()方法：从数组的末尾开始向前查找。两个方法都接收两个参数，要查找的项和开始查找的起始位置。没找到的情况返回-1，返回值是位置。123456789101112var numbers=[1,2,3,4,5,4,3,2,1];alert(numbers.indexOf(4)); //3alert(numbers.lastIndexOf(4)); //5alert(numbers.indexOf(4，4)); //5alert(numbers.lastIndexOf(4，4)); //3var person=&#123;name:&quot;Nicholas&quot;&#125;;var people=[&#123;name:&quot;Nicholas&quot;&#125;];var morePeople=[people];alert(people.indexOf(person)); //-1alert(morePeople.indexOf(peoson)); //0 迭代方法 every():对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true，否则返回false。 filter():对数组中的每一项运行给定函数，返回该函数会返回true的项组成数组。 forEach():对数组中的每一项运行给定函数，这个方法没有返回值。 map():对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some():对数组中的每一项运行给定函数，如果该函数对任意一项返回true，则返回true。以上方法都不会修改数组中包含的值。都接收三个参数：数组项的值，该项在数组的位置，数组对象本身。1234567891011121314151617181920212223242526272829//every()var numbers=[1,2,3,4,5,4,3,2,1];var everyResult=numbers.every(function(item,index,array)&#123; return (item&gt;2);&#125;);alert(everyResult); //false//some()var numbers=[1,2,3,4,5,4,3,2,1];var someResult=numbers.every(function(item,index,array)&#123; return (item&gt;2);&#125;);alert(someResult); //true//filter()var numbers=[1,2,3,4,5,4,3,2,1];var filterResult=numbers.every(function(item,index,array)&#123; return (item&gt;2);&#125;);alert(filterResult); //[3,4,5,4,3]//map()var numbers=[1,2,3,4,5,4,3,2,1];var mapResult=numbers.every(function(item,index,array)&#123; return item*2;&#125;);alert(mapResult); //[2,4,6,8,10,8,6,4,2]//forEach()var numbers=[1,2,3,4,5,4,3,2,1];numbers.forEach(function(item,index,array)&#123; //执行某些操作&#125;); 归并方法 reduce():从数组的第一个开始，逐个遍历到最后。 reduceRight():从数组最后一个开始，逐个遍历到第一个。 这两个函数接收两个参数：一个在每一项上的调用的函数和（可选的）作为归并基础的初始值。 传给两个函数的函数接收四个参数：前一个值，当前值，项的索引，数组对象。 函数的返回值都会作为第一个参数自动传给下一项。123456789101112//reduce()正向var values=[1,2,3,4,5];var sum=values.reduce(function(prev,cur,index,array)&#123; return prev+cur;&#125;);alert(sum); //15//ruduceRight()反向var values=[1,2,3,4,5];var sum=values.reduceRight(function(prev,cur,index,array)&#123; return prev+cur;&#125;);alert(sum); //15","tags":[{"name":"前端","slug":"前端","permalink":"http://yangkunyi.com/tags/前端/"},{"name":"笔记","slug":"笔记","permalink":"http://yangkunyi.com/tags/笔记/"},{"name":"数组","slug":"数组","permalink":"http://yangkunyi.com/tags/数组/"}]},{"title":"DOM知识点","date":"2017-04-10T11:07:45.000Z","path":"2017/04/10/DOM知识点/","text":"DOM D：document（文档）O：object（对象）：用户定义对象，内建对象，宿主对象M：model（模型）：“map”，树 节点 元素节点（element node）：body，ul，li……获取元素节点的方法： 通过元素id（getElementById ） 通过标签名（getElementsByTagName） 通过类名（getElementsByClassName） 属性节点（attribute node）&lt;p title=&quot;yang&quot;&gt;hahahahahahha&lt;/p&gt;title=”yang”是一个属性节点属性节点总是包含在元素节点中 文本节点获取和设置属性 getAttribute（获取） 12345//例子var paras=document.getElementsByTagName(&quot;p&quot;);for(var i=0;i&lt;paras.lengeh;i++)&#123; alert(paras[i].getAttribute(&quot;title&quot;));&#125; setAttribute（设置）若属性本不存在，实际就将完成两项操作：1.创建属性，2.设置值。注：并不会改变源文件扽静态内容。 123//例子var shopping=document.getElementById(&quot;purchases&quot;);shopping.setAttribute(&quot;title&quot;,&quot;a list of goods&quot;); 实例：JavaScript图片库 childNodes属性用来获取任何一个元素的所有子元素。 123456//获取body所有子元素个数的函数例子function countBodyChildren()&#123; var body_element=document.getElementsByTagName(&quot;body&quot;)[0]; alert(body_element.childNodes.length);&#125;window.onload=countBodyChildren; nodeType属性 元素节点的nodeType属性值是1。 属性节点的nodeType属性值是2。 文本节点的nodeType属性值是3。alert(body_element.nodeType); nodeValue属性得到和设置一个节点的值。alert(discription.nodeValue); firstChild和lastChild属性这两个属性都是为了个简便且直观的获取对应的元素。 注意点 DOM是一套对文档内容进行抽象和概念化的方法。 变量名中不能包含空格和标点符号（美元$符号除外）。 变量名允许包含字母，数字，美元符号和下划线（但第一个字符不能是数字）。 变量申明实例：my_mood或者myMood（峰驼式camel case：首选）。 Javascript是弱类型语言，不需要对变量进行类型声明。 变量可以包含操作。 字符串可以做拼接操作。 innerHTML属性和documen.write方法都是HTML的专有属性。var message=&quot;I am feeling&quot;+&quot;happy&quot;; 每个元素节点都是一个对象。","tags":[{"name":"DOM","slug":"DOM","permalink":"http://yangkunyi.com/tags/DOM/"},{"name":"JS","slug":"JS","permalink":"http://yangkunyi.com/tags/JS/"},{"name":"前端","slug":"前端","permalink":"http://yangkunyi.com/tags/前端/"}]},{"title":"微信排版总结","date":"2017-04-10T06:14:45.000Z","path":"2017/04/10/微信排版总结/","text":"关于两条微信排版的总结 使用工具 秀米 用法简单 模版更新快，也很好看 方便文案排好后的转发 PS 文案中的图片编辑 拼图 裁图 排版步骤 通看文案 分辨文案类型 根据文案拟想自己要怎么排版 理解文案，抓出重点 开始构思 配色 字体大小（一般文案14号字体合适，标题和重点突出可使用16号字体，这样会让排版看起来更清爽） 模版的选择 开始排版 手机预览整体效果，进行最后的改进 确认无误，发给相关人员审核 案例1：身体力行勤浇灌 支教花开别样红 分析：这是一个活动总结的微信，内容是支教，与小朋友有关，照片看起来也是很活跃的。我会突出小朋友们的表现和支教队的表现。 构思：春天，又有小朋友，暖色调是不错的选择。模版的选择我也会选择跟春暖花开有关的。 开始排版 预览，改进（一定要手机预览，电脑和手机效果是不一样的） 审核 案例2：这是你的“互联网+”时代 分析：这是一个比赛宣传微信，重要的是传达信息。 构思：内容和互联网有关，我会用蓝色作为主色调，来突出重要性和可靠性。模版我会选择简单的，不让花哨的模版吸引眼球，而是做到排版相对工整，将信息突出得更明确。 开始排版 预览，改进（手机预览） 审核 排版小技巧 改变行距，让排版清新爽眼 一篇文章的颜色不超过三个（超过三个的颜色除非是同色系的，不影响整体性） 排版有一定的逻辑更有代入性 用现有模版拼凑出自己的模版 图片和文字都带模版放，这样不显单调 注：1.我们收到的文案都是word，不要受了原文案的限制，排版格式单调得跟word一样。2.当你觉得文案写得很low的时候，只要没有大体方向的偏差，大胆的改。3.当你觉得图片这样不好看的时候，就用PS修，不然你什么时候时候用你学到的呢？4.对自己交的每一件作品负责。5.学会思考“我要做什么？我该怎么做？我为什么要这么做？”","tags":[{"name":"新媒体","slug":"新媒体","permalink":"http://yangkunyi.com/tags/新媒体/"}]},{"title":"BOM知识点","date":"2017-04-06T00:56:57.000Z","path":"2017/04/06/BOM知识点/","text":"BOM 一、window对象1.全局作用域 全局变量会变成window对象的属性。 全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性可以。 123456789var age=29;window.color=&quot;red&quot;;//在IE&lt;9时抛出错误，在其他所有浏览器中都返回falsedelete window.age;//在IE&lt;9时抛出错误，在其他所有浏览器中都返回truedelete window.color;//returns truealert(window.age);//29alert(window.color);//undefined 尝试访问未声明变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明变量是否存在。 窗口关系及框架 除非最高层窗口是通过window.open()打开的，否则其window对象的name属性不会包含任何值。 在使用框架的情况下，浏览器中会存在多个Global对象。 在每个框架中定义的全局变量会自动变成框架中window对象的属性。 由于每个window对象都包含原生类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应但并不相等。 窗口位置 screenLeft/screenTop:分别用于表示相对于屏幕左边和上边的位置。 screenY/screenX:提供相同的窗口位置属性。`` 12var leftPos=(typeof window.screenLeft==&quot;number&quot;)?window.screenLeft:window.screenX;var topPos=(typeof window.screenLeft==&quot;number&quot;)?window.screenTop:window.screenY; 注意：最终无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值。 moveTo()两个参数:移动到什么位置去。 moveBy()两个参数:向什么地方移动。两个函数不适用与框架，只能对最外层的window对象使用。 窗口大小 innerWidth/innnerHeight:返回浏览器本身的尺寸。 outerWidth/outerHeight:返回浏览器本身的尺寸。 document.documentElement.clientWidth/document.documentElement.clientHeight 12345678910111213var pageWidth=window.innerWidth; pageHeight=window.innerHeight;if(typeof pageWidth!=&quot;number&quot;)&#123; if(document.compatMode==&quot;CSS1Compat&quot;)&#123; //通过检查document.compatMode来确定页面是否处于标准模式 pageWidth=document.documentElement.clientWidth; pageHeight=document.documentElement.clientHeight; &#125; else&#123; pageWidth=document.body.clientWidth; pageHeight=document.body.clientHeight; &#125;&#125; resizeTo()两个参数:调整到。 resizeBy()两个参数:接受新窗口与原窗口的宽度和高度之差。两个函数不适用与框架，只能对最外层的window对象使用。 导航和打开窗口 window.open():既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。接收四个参数：1.要加载的URL 2.窗口目标 3.一个特定的字符串 4.一个表示新页面是否取代浏览器历史纪录中当前加载页面的布尔值方法会返回一个指向新窗口的引用。 1.打开窗口 2.安全限制 3.弹出窗口屏蔽程序 1234567891011121314var blocked=false;try&#123; var wroxWin=window.open(&quot;http://www.wrox.com&quot;, &quot;_blank&quot;); if(wroxWin==null)&#123; blocked=true; &#125;&#125;catch(ex)&#123; blocked=true;&#125;if(blocked)&#123; alert(&quot;The popup was blocked!&quot;);&#125; 在任何情况下，以上代码都可以检测出调用window.open()打开的弹出窗口是不是被屏蔽来了。但要注意的是，检测窗口是否被屏蔽只是一方面，它并不会阻止浏览器显示与被屏蔽的弹出窗口有关的消息。 间歇调用和超时调用 JavaScript是单线程语言，但它允许通过设置超时值和间歇值来调度代码在特定的时刻执行。 setTimeout(): 接受两个参数：1.要执行的代码（不建议传字符串，因为可能导致性能损失，建议用函数） 2.以毫秒表示的时间 该方法会返回一个数值ID，表示超时调用。这个超时调用ID是计划执行代码的唯一标识符，可以通过它来取消超时调用。 setInterval(): 与超时调用类似，但是它会按照指定的时间间隔重复执行代码，直到间歇调用被取消或者页面被卸载。 也接受两个参数：1.要执行的代码 2.以毫秒表示的时间 clearTimeout():取消超时调用或者间歇时间调用。 在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。所以，最好不要使用间歇调用。 一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。 123456789101112131415var num=0;var max=10;function incremenetNumber()&#123; num++; //如果执行次数尚未达到max设定的值，则设置另一次超时调用 if(num&lt;max)&#123; setTimeout(incrementNumber,500); &#125; else&#123; alert(&quot;Done!&quot;); &#125;&#125;setTimeout(incrementNumber,500); 系统对话框 alert():向用户显示一个系统对话框，其中包含一个制定的文本和一个OK（确定）按钮。 confirm():向用户显示“警告”对话框，返回true或者flase。 prompt():显示一个“提示”框，用于提示用户输入一些文本。接受两个参数：1.要显示给用户的文本提示 2.文本输入域的默认值。 window.find():显示“查询”对话框。 window.print():显示“打印”对话框。 二、location对象查询字符串参数 解析查询字符串的函数 1234567891011121314151617181920212223242526272829303132function getQueryStringArgs () &#123; // 解析查询字符串 //取得查询字符串并去掉开头的问号 var qs=(location.search.length&gt;0?location.search.substring(1):&quot;&quot;), //保存数据对象 args=&#123;&#125;, //取得每一项 items=qs.length?qs.sqlit(&quot;&amp;&quot;):[], item=null, name=null, value=null, //在for循环中使用 i=0, len=items.length; //逐个将每一项添加到args对象中 for (var i = 0; i &lt; len ; i++) &#123; item=items[i].sqlit(&quot;=&quot;); name=decodeURIComponent(item[0]); value=decodeURIComponent(item[1]); if (name.length) &#123; args[name]=value; &#125; &#125; return args;&#125; 位置操作改变浏览器的位置 assigned()：location.assign(&quot;http://www.wrox.com&quot;); location.href window.location replace()：让用户无法回到前一个页面，历史记录中不会生成新的记录。 raload()：作用是重新加载当前显示的页面。最好将其放在代码的最后一行。 三、navigation对象检查插件 检查插件 123456789101112131415161718192021222324252627282930313233//检查插件（在IE中无效）function hasPlugin (name) &#123; name=name.toLowerCase(); for (var i = 0; i &lt; navigator.plugins.length; i++) &#123; if (navigator.plugins[i].name.toLowerCase().indexOf(name)&gt;-1) &#123; return true; &#125; &#125; return false;&#125;//检测flash//alert(hasPlugin(&quot;Flash&quot;));//检测QuickTime//alert(hasPlugin(&quot;QuickTime&quot;));//检测IE中的插件function hasIEPlugin (name) &#123; try&#123; new ActiveXObject(name); return true; &#125; catch(ex)&#123; return false; &#125;&#125;//检测flash//alert(hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;));//检测QuickTime//alert(hasPlugin(&quot;QuickTime.QuickTime&quot;)); 注册处理程序 registerContentHandler()：接收三个参数：1.要处理的MIME类型。2.可以处理该MIME类型的页面的URL。3.应用程序的名称。 registerProtocolHandler()：接收三个参数：1.要处理的协议。2.处理该协议的页面的URL。3.应用程序的名字。 四、screen对象五、history对象 go() back() forward() lengh属性","tags":[{"name":"前端","slug":"前端","permalink":"http://yangkunyi.com/tags/前端/"},{"name":"BOM","slug":"BOM","permalink":"http://yangkunyi.com/tags/BOM/"},{"name":"笔记","slug":"笔记","permalink":"http://yangkunyi.com/tags/笔记/"}]},{"title":"动画和HTML5","date":"2017-03-23T06:33:24.000Z","path":"2017/03/23/动画和HTML5/","text":"用JavaScript实现动画效果 知识点 position属性： static：默认值，意思是有关元素将按照它们在标记里出现的先后顺序出现在浏览器窗口里。 relative：与static相似，区别是relative的元素还可以（通过应用float属性）从文档的正常显示顺序里脱离出来。 absolute：我们就可以将它摆在“容器”的任何位置。这个容器要么是文档本身，要么是一个有着fixed或absolute属性的父元素。这个元素在原始标记里面出现的位置与它显示位置无关，因为它的显示位置由top，left，right和bottom等属性决定。你可以使用像素或百分比为单位设置这些属性。 overflow属性： visible：不裁剪溢出内容。 hidden：隐藏溢出内容。 scroll：类似鱼hidden，浏览器将对溢出的内容进行隐藏，但显示一个滚动条以便让用户能够滚动看到内容的其他部分。 auto：类似于scroll，但浏览器只在确实发生溢出时才显示滚动条，如果没有溢出就不显示滚动条。时间 setTimeout：能够让某个函数在经过一段预定的时间之后才开始执行。 函数有两个参数：第一个是字符串，执行的函数名；第二个是数值，以毫秒为单位设定了需要经过多长时间才开始执行第一个参数所给出的函数。 setTimeout(&quot;function&quot;,interval) 在绝大多数情况下，将函数调用赋值给一个变量是一个好主意。 varible=setTimeout(&quot;function&quot;,interval) 取消某个正在排队等候执行的函数： clearTimeout(variable) HTML5video： currentTime：返回当前播放的位置，以秒表示； duration：返回媒体的总时长，以秒表示，对于流媒体返回无穷大； * paused：表示媒体是否处于暂停状态； 触发脚本的事件： play：在媒体播放开始时发生； pause：在媒体暂停是发生； loadeddata：在媒体可以从当前播放位置开始播放时发生； ended：在媒体已播放完成而停止时发生； 别忘了给&lt;video&gt;元素叫control属性： &lt;video src=&quot;movie.ogv&quot; control&gt; 表单：新的输入控件类型 email，用于输入电子邮件地址； url，用于输入URL； date，用于输入日期和时间； number，数值； ranger，生成滑动条； search，搜索框； tel，电话号码； color，选择颜色；新的属性 autocomplete，用于为文本（text）输入框添加一组建议的输入项； autofocus，让表单元素自动获得焦点； form，对标签外部的表单元素分组； min，max和step，用在范围（range）和数值（number）输入框中； pattern，定义一个正则表达式，以便验证输入的值； placeholder，在文本输入临时性的提示信息； required，表示必填；","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yangkunyi.com/tags/Javascript/"},{"name":"动画","slug":"动画","permalink":"http://yangkunyi.com/tags/动画/"},{"name":"HTML5","slug":"HTML5","permalink":"http://yangkunyi.com/tags/HTML5/"}]},{"title":"JSON相关内容","date":"2017-03-22T15:02:31.000Z","path":"2017/03/22/JSON相关内容/","text":"JSON 知识点 JSON是一种数据结构，不是一种编程语言。 语法（三种类型的值） 简单值：使用JavaScript语法，可以在JSON中表示字符串、数值、布尔值和null，但不支持undefined。 字符串必须用双引号。 没有变量，没有分号。 对象：表示一组无序的键值对儿，每个键值对儿的值可以是简单值，也可以是复杂数据类型。 对象的属性必须加双引号。 没有声明，没有末尾的分号。 一个对象绝不能出项两个同名的属性。 数组：一组有序的值的列表，可以通过数值索引类访问其中的值，数组的值也可以是任意值。 没有变量，没有分号。 解析与序列化JSON可以将JSON数据结构解析为有用的JavaScript对象。 JSON对象 stringify()：将JavaScript对象序列化为JSON字符串。 parse()：将JSON字符串解析为原生的JavaScript值。 序列化选项 stringify()除了要序列化的JavaScript对象外，还可以接收两个参数，用于指定以不同的方式序列化JavaScript对象。一个是参数过滤器（可以是数组，可以是函数），第二个参数是选项，表示是否在JSON字符串中保存缩进。 如果是数组，就返回对象相应的属性。 如果是函数，返回值是undefined将会被忽略。 字符串缩进：第三个参数用于控制结果中的缩进和空白字符串。如果是数字就表示的是每个级别缩进的空格数。 toJSON()方法：（没看懂）。","tags":[{"name":"前端","slug":"前端","permalink":"http://yangkunyi.com/tags/前端/"},{"name":"JSON","slug":"JSON","permalink":"http://yangkunyi.com/tags/JSON/"}]},{"title":"css选择器、权重及优先级","date":"2017-03-21T07:11:22.000Z","path":"2017/03/21/css选择器、权重及优先级/","text":"遇到的问题 子元素使用padding会影响父元素。（解决方法是给父元素用padding） 背景图片的设置。（已解决） 分享会（胡小青）CSS选择器、权重及优先级选择器的种类 通配符选择器（＊） id选择器（#ID） 类选择器（.className） 标签选择器(E) 后代选择器（Ｅ Ｆ） 子元素选择器(E&gt;F) 相邻兄弟元素选择器(E + F) 群组选择器（selector1,selector2,…,selectorN） 交集选择器（E.className) 属性选择器 伪类选择器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//html&lt;div id=&quot;share&quot;&gt;id选择器&lt;/div&gt;&lt;div class=&quot;share&quot;&gt;类选择器&lt;/div&gt;&lt;div&gt; &lt;em&gt;标签选择器&lt;/em&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;后代选择器&lt;/p&gt; &lt;p&gt;&lt;span&gt;非直系后代&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;子元素选择器&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;相邻兄弟1&lt;/p&gt; &lt;span&gt;相邻兄弟2&lt;/span&gt;&lt;/div&gt;&lt;div&gt; &lt;h1&gt;群组选择器&lt;/h1&gt; &lt;h2&gt;群组选择器&lt;/h2&gt; &lt;h3&gt;群组选择器&lt;/h3&gt;&lt;/div&gt;//css*&#123; margin: 0; padding: 0;&#125;#share&#123; width: 200px; background: #cfd2d1;&#125;.share&#123; width: 200px; background: #e9eeec; margin-bottom: 10px;&#125;div.share &#123; border: 2px solid #000;&#125;em&#123; background: #f5f6f6;&#125;div p &#123; background: #e9eeec;&#125;div p span&#123; width: 200px; background: #acb1af;&#125;div &gt; p &#123; width: 200px; background: #adcec0;&#125;p + span &#123; width: 200px; background: #9d9e9e;&#125;h1,h2,h3 &#123; width: 200px; background: #afead2;&#125; 属性选择器 属性选择器 功能 E[att] 匹配所有具有att属性的E元素，不考虑它的值。 css2 E[att=val] 匹配所有att属性等于”val”的E元素 css2 E[att~=val] 匹配属性包含val的元素，并设置其样式：注意是val，所以val-ab这样不算 css2 E[att\\ =val] 匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以”val”开头的E元素，主要用于lang属性 css2 E[att^=val] 选择匹配的元素E，E定义了属性att,属性值以val开头的字符串 css3 E[arr$=val] 选择匹配的元素E，E定义了属性att,属性值以val结尾的字符串 css3 E[att*=val] 选择匹配的元素E，E定义了属性att,属性值包含val的字符串，也就是val可以在任意位置 css3 123456789101112131415161718192021222324252627282930//html&lt;a href=&quot;xxx.pdf&quot;&gt;我链接的是PDF文件&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;icon&quot;&gt;我类名是icon&lt;/a&gt;&lt;a href=&quot;#&quot; title=&quot;我的title是more&quot;&gt;我的title是more&lt;/a&gt;&lt;a href=&quot;#&quot; name=&quot;about&quot; lang=&quot;en-zhN&quot;&gt;选择含有about的元素&lt;/a&gt;&lt;a href=&quot;#&quot; name=&quot;about-ab&quot; lang=&quot;en&quot;&gt;选择含有about的元素&lt;/a&gt;&lt;a href=&quot;#&quot; name=&quot;about ab&quot;&gt;选择含有about的元素&lt;/a&gt;//cssa[href=&quot;xxx.pdf&quot;] &#123; border: 1px solid #000;&#125;a[href$=pdf]&#123; background: orange; color: #fff;&#125;a[class^=icon] &#123; background: #55e2a8; color:#fff;&#125;a[title*=more] &#123; background: #7a92e9; color: #fff;&#125;a[name~=about] &#123; background: #55e2a8;&#125;a[lang|=en] &#123; border: 1px solid #000;&#125; 伪类选择器 *动态伪类 锚点伪类 :link 链接访问前状态 :visited 链接访问后状态 :hover 鼠标悬浮链接的状态 :active 激活链接时的状态 伪类的顺序：link - visited -&gt; hover -&gt; active 用户行为伪类 :hover 用于当用户把鼠标移动到元素上面时的效果 :active 用于用户点击元素那一下的效果 :focus用于元素成为焦点，这个经常用在表单元素上 顺序： focus - &gt; hover -&gt; activeIE6下只有&lt;a&gt;支持:hover，IE6,7都不支持:focus、:active 1234567891011121314151617181920212223//html&lt;a href=&quot;#&quot; class=&quot;link&quot;&gt;link效果&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;visited&quot;&gt;visited效果&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;hover&quot;&gt;hover效果&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;active&quot;&gt;active效果&lt;/a&gt;&lt;input type=&quot;text&quot; name=&quot;&quot;&gt;//css.link:link &#123; background: pink;&#125;.visited:visited&#123; background: #cca;&#125;.hover:hover &#123; background: lightblue;&#125;.active:active &#123; background: lightgreen;&#125;input:focus &#123; outline: 2px solid red;&#125; UI元素状态伪类这类伪类主要针对form元素 伪类 功能 适用元素 :enabled 匹配表单中激活的元素 type=”text” :disabled 匹配表单中禁用的元素 type=”text” :checked 匹配表单中被选中的radio（单选框）或checkbox（复选框）元素 type=”radio” ::selection 匹配用户当前选中的元素 123input[type=&quot;radio&quot;]:disabled &#123; background-color: red;&#125; 结构伪类 :first-child* 选择某个元素的第一个子元素,IE6不支持； :last-child* 选择某个元素的最后一个子元素； :nth-child()* 选择某个元素的一个或多个特定的子元素，IE6-8，Firefox3.0不兼容； :nth-child(length)&ensp;&ensp;参数是具体数字 :nth-child(n)&ensp;&ensp;参数是n,n从0开始计算 :nth-child(nlength)&ensp;&ensp;n的倍数选择，n从0开始算 :nth-child(n+length)&ensp;&ensp;选择大于length后面的元素 :nth-child(-n+length)&ensp;&ensp;选择小于length前面的元素 :nth-child(nlength+1)&ensp;&ensp;表示隔几选一 123456789101112131415li:last-child &#123; background: #f9f57a;&#125;li:nth-child(2) &#123; background: #c8cac9;&#125;li:nth-child(2n) &#123; border: 3px solid red;&#125;li:nth-child(n+3) &#123; border: 3px solid yellow;&#125;li:nth-child(-n+3) &#123; border: 3px solid yellow;&#125; :nth-last-child()选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算，IE6-8，Firefox3.0不兼容； :nth-of-type()选择指定的元素,与nth-child类似也可以使用表达式，IE6-8，Firefox3.0不兼容； :nth-last-of-type()选择指定的元素，从元素的最后一个开始计算； :first-of-type选择一个上级元素下的第一个同类子元素，与first-child类似，不过是指定了元素类型； :last-of-type选择一个上级元素的最后一个同类子元素； :only-child选择的元素是它的父元素的唯一一个子元素，兼容到IE9； :only-of-type选择一个元素是它的上级元素的唯一一个相同类型的子元素，IE6-8，Firefox3.0不兼容； :empty选择的元素里面没有任何内容，兼容到IE9； :not()选择不匹配的元素，兼容到IE9； target 匹配文档中特定”id”点击后的效果，兼容到IE9。 1234567891011121314151617181920//html&lt;a href=&quot;#test&quot;&gt;test&lt;/a&gt;&lt;div&gt;第一个div&lt;/div&gt;&lt;p&gt;第一个p&lt;/p&gt;&lt;div id=&quot;test&quot;&gt;第二个div&lt;/div&gt;&lt;p&gt;第二个p&lt;/p&gt;&lt;p&gt;&lt;/p&gt;//cssdiv:not&#123; background-color: lightgrey;&#125;p:empty&#123; height:30px; width:30px; background:pink;&#125;div:target&#123; color:blue;&#125; 伪元素选择器 伪元素 功能 :first-line 匹配元素的第一行 :first-letter 匹配元素的第一个字母 :before 元素之前插入生成的内容 :after 元素之后插入生成的内容 :selecton 改变浏览网页选中文的默认效果 伪元素可以用::也可以用:关于first-letter使用条件比较苛刻，一般只有有兴趣可以参考深入CSS ::first-letter伪元素及其实例 123li::first-letter &#123; font-size: 56px;&#125; 伪类和伪元素的区别&gt; CSS 伪类用于向某些选择器添加特殊的效果。 CSS 伪元素用于将特殊的效果添加到某些选择器。两者都与选择器相关，可以添加一些“特殊”的效果。 区别：&ensp;&ensp;&ensp;&ensp;伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到 伪类 12345678910//html&lt;p&gt; &lt;i&gt;first&lt;/i&gt; &lt;i&gt;second&lt;/i&gt;+&lt;/p&gt;//cssp&gt;i:first-child &#123; color: red&#125; 伪类 :first-child 添加样式到第一个子元素如果我们不使用伪类，而希望达到上述效果，可以这样做： 12345678910//html&lt;p&gt; &lt;i class=&quot;first-child&quot;&gt;first&lt;/i&gt; &lt;i&gt;second&lt;/i&gt;&lt;/p&gt;//css.first-child &#123; color: red&#125; 我们给第一个子元素添加一个类，然后定义这个类的样式。 伪元素：1234567//html&lt;p&gt;I am stephen lee.&lt;/p&gt;//cssp:first-letter &#123; color: red&#125; 伪元素 :first-letter 添加样式到第一个字母那么如果我们不使用伪元素，要达到上述效果，我们可以这样做： 123//html&lt;p&gt; &lt;span&gt;I&lt;/span&gt; am stephen lee.","tags":[{"name":"前端","slug":"前端","permalink":"http://yangkunyi.com/tags/前端/"},{"name":"笔记","slug":"笔记","permalink":"http://yangkunyi.com/tags/笔记/"},{"name":"分享","slug":"分享","permalink":"http://yangkunyi.com/tags/分享/"}]},{"title":"FirstPassage","date":"2017-03-20T13:20:46.000Z","path":"2017/03/20/FirstPassage/","text":"第一篇博文（搭建博客的坑！！！） 1.关于Hexo nmp安装Hexo 打开命令行工具，执行如下命令： $ npm install -g hexo 创建文件夹 本人是直接在D盘创建了一个名叫blog的文件夹，在blog中创建了Hexo文件夹。（这个看个人喜好吧，用命令行也未尝不可。） 初始化 在Hexo目录下打开命令行工具，执行： hexo init 之后执行： hexo server 会看到： INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 访问：http://localhost:4000/就可以看到Hexo的初始页面了。 2.关于个人设置 基本信息 本人修改了title、subtitle、author的内容，如下： 1234567# Sitetitle: YangKunyi的博客subtitle: 爱看书的杨杨description:author: FrannieYilanguage:timezone: 第一个坑注意每一个冒号后面都有一个空格 无法生效的写法：title:Drubear的博客有效的写法：title:[空格]Drubear的博客 主题 知乎 - 好看的主题！ 使用git命令在github上clone下自己喜欢的主题，本人使用的是litten的yilia。 配置主题根据clone下来的主题将页面进行个性化设置。可以参考博主给的各种参数。 部署设置 只需简单的执行 hexo d But，重点来了前方巨坑请注意 首先在github上建立一个仓库，名字叫做：[你的用户名].github.io注意，你的用户名必须与你实际的用户名一字不差！ 拥有了个人的GitHubPages后，再回到Hexo的_config.yml文件，找到Deployment章节，做以下修改：（以FrannieYi为用户名为例）123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/FrannieYi/FrannieYi.github.io.git branch: master 以上两步做完后，执行 hexo d如果没有报错，你是幸运的。本人在这个坑里栽了无数次，系统报错 ERROR Deployer not found: Git 最后发现这个错误是因为少运行了一行代码： npm install hexo-deployer-git --save 运行完以上代码终于，本人泪流满面的看到了自己亲手搭建的博客。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yangkunyi.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://yangkunyi.com/tags/github/"}]},{"title":"互联网金融了解","date":"2017-02-27T06:17:03.000Z","path":"2017/02/27/互联网金融了解/","text":"互联网金融学习报告 学习方式 查看百度百科 查看知乎话题精华问题 查看精华博文 含义 互联网金融（ITFIN）就是互联网技术和金融功能的有机结合，依托大数据和云计算在开放的互联网平台上形成的功能化金融业态及其服务体系，包括基于网络平台的金融市场体系、金融服务体系、金融组织体系、金融产品体系以及互联网金融监管体系等，并具有普惠金融、平台金融、信息金融和碎片金融等相异于传统金融的金融模式。 发展模式 众筹 P2P网贷 P2P：对等网络，即对等计算机网络，是一种在对等者（Peer）之间分配任务和工作负载的分布式应用架构，是对等计算模型在应用层形成的一种组网或网络形式。 第三方支付 数字货币（比特币） 大数据金融 信息化金融机构 互联网金融门户 经典案例 融资 四大商业银行推出的网上银行，腾讯推出的微信联合人保财险的手机端支付，淘宝联合天弘基金开发的余额宝，还有包括：易付宝、百付宝、快钱等多家第三方支付平台。 微金融 微金融又称微信金，是2012年左右新兴的一种金融模式。即借助微信等典型的社交媒体平台，为用户提供相对理财，投资，贷款等规模较小的金融行为环境，一般情况下，指的是为中小微企业、创业者、个体工商户、小额投资者等提供的金融服务。日前有第三方平台发布了微信金融平台排名，以其中名列前位的“闪电借款”为例，2015年第三季度财报显示，其闪电借款平台7、8、9三个月撮合交易额分别有1.95亿、2.28亿、2.67亿，增长极其迅猛。 移动支付 以规模庞大的线下POS收单市场来说，越来越多的第三方支付企业对线下收单市场的拓展，未来线下支付将给整个综合支付市场格局带来重要影响。最经典的肯定是支付宝啦。 互联网金融方面的产品网络支付 支付宝 微信 财付通 百度钱包 微博钱包 盛付通 国付宝 网络理财 支付宝.余额宝 招财宝 挖财 点融网 拍拍货 安心贷 翼龙贷款 有利网 人人贷 …… 互联网金融的形态与谱系1.互联网支付（1）互联网支付历程：Musk,Paypal与SpaceX（2）支付宝：从支付工具到场景制造（3）微信支付：从社交场景到支付工具（4）汇付天下：从机票支付到金融布局（5）互联网支付成功秘决：嵌入场景、专注本质 2.互联网货币（1）互联网货币的理论基础：密码学与区块链技术（2）比特币：疯狂炒作背后的深层次逻辑——去中心化（3）区块链技术——下一场盛筵的基础","tags":[{"name":"学习","slug":"学习","permalink":"http://yangkunyi.com/tags/学习/"},{"name":"新媒体","slug":"新媒体","permalink":"http://yangkunyi.com/tags/新媒体/"}]}]