{"meta":{"title":"Yangyi的博客","subtitle":"爱看书的杨杨","description":null,"author":"Frannie Yangyi","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"vue2.0生命周期","slug":"vue2-0生命周期","date":"2017-06-02T02:03:58.000Z","updated":"2017-06-02T02:12:30.626Z","comments":true,"path":"2017/06/02/vue2-0生命周期/","link":"","permalink":"http://yoursite.com/2017/06/02/vue2-0生命周期/","excerpt":"","text":"图解 函数解释 beforeCreate在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。 created实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount在挂载开始之前被调用：相关的 render 函数首次被调用。 mountedel 被新创建的vm.\\$el替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 beforeUpdate数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 updated由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 beforeDestroy实例销毁之前调用。在这一步，实例仍然完全可用。 destroyedVue 实例销毁后调用。调用后，Vue实例指示的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/vue/2.1.3/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message : &quot;Hello!&quot; &#125;, beforeCreate: function () &#123; console.group(&apos;beforeCreate 创建前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot; , &quot;el : &quot; + this.$el); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) &#125;, created: function () &#123; console.group(&apos;created 创建完毕状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, beforeMount: function () &#123; console.group(&apos;beforeMount 挂载前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + (this.$el)); //已被初始化 console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, mounted: function () &#123; console.group(&apos;mounted 挂载结束状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); //已被初始化 console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, beforeUpdate: function () &#123; console.group(&apos;beforeUpdate 更新前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, updated: function () &#123; console.group(&apos;updated 更新完成状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, beforeDestroy: function () &#123; console.group(&apos;beforeDestroy 销毁前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, destroyed: function () &#123; console.group(&apos;destroyed 销毁完成状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用浏览器打开 beforecreated：el 和 data 并未初始化created:完成了 data 数据的初始化，el没有beforeMount：完成了 el 和 data 初始化mounted ：完成渲染 关于更新app.message= &#39;vue&#39;; 关于销毁app.$destroy(); 销毁完成后，我们再重新改变message的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在。可以这么理解，执行了destroy操作，后续就不再受vue控制了。 生命周期函数的一些用法 beforecreate : 举个栗子：可以在这加个loading事件created ：在这结束loading，还做一些初始化，实现函数自执行mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情beforeDestory： 你确认删除XX吗？destoryed ：当前组件已被删除，清空相关内容","categories":[],"tags":[{"name":"vue,javascript,分享","slug":"vue-javascript-分享","permalink":"http://yoursite.com/tags/vue-javascript-分享/"}]},{"title":"坎帕斯学院日常讨论","slug":"坎帕斯学院日常讨论","date":"2017-04-16T08:14:15.000Z","updated":"2017-04-21T02:38:33.657Z","comments":true,"path":"2017/04/16/坎帕斯学院日常讨论/","link":"","permalink":"http://yoursite.com/2017/04/16/坎帕斯学院日常讨论/","excerpt":"话题：width：100%和width：auto的区别","text":"话题：width：100%和width：auto的区别 width：100% 元素宽度等于父级元素的宽度。 width：auto 元素的宽度等于父元素的宽度减去margin，padding，border这些。 高度知识点 子元素的margin和padding百分比知识点根据父元素的width来算。123456789101112131415161718192021222324//test1&lt;style&gt; body&#123; margin:0; padding:0; &#125; .main&#123; width:500px; background:red; &#125; .test&#123; width:auto; padding:20px; margin:10px; border:5px solid blue; background:green; &#125;&lt;/style&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;test&quot;&gt;123&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; test width=父元素width-margin-padding-border 123456789101112131415161718192021222324//test2&lt;style&gt; body&#123; margin:0; padding:0; &#125; .main&#123; display:inline-block; background:red; &#125; .test&#123; width:auto; padding:20px; margin:10px; border:5px solid blue; background:green; &#125;&lt;/style&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;test&quot;&gt;123123123123123&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; test width=123123123123123+margin+padding+border 1234567891011121314151617181920212223242526//test3&lt;style&gt; body&#123; font-size:20px; margin:0; padding:0; &#125; .main&#123; display:inline-block; background:red; width:500px; &#125; .test&#123; width:auto; padding:20px; margin:10px; border:5px solid blue; background:green; &#125;&lt;/style&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;test&quot;&gt;123123123123123&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; test width=500-padding-margin-border这里的500px并不是继承，而是因为div块级元素的影响而来的。 123456789101112131415161718192021222324252627//test4a&lt;style type=&quot;text/css&quot;&gt; body&#123; font-size: 20px; padding: 0; margin: 0; &#125; .first1&#123; background: red; width: 200px; height: 400px; overflow: hidden; &#125; .second1&#123; height: 25%;width: 25%; margin-top: 10%; background-color: green; padding-left: 10%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;first1&quot;&gt; &lt;div class=&quot;second1&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; test width=50,height=100,margin-top=20 2017.4.19 21:00话题：document.getElementByClassName()返回的是什么？ 是一个HTML集合。 集合和数组的区别 HTML集合：一直与文档保持着链接，每次你需要最新的信息时，都会重复执行查询的过程，哪怕只是获取集合里的元素个数，即集合的length属性也是这样。（简单的说就是这个集合会实时改变） 案例：12345var alldivs document.getElementsByTagName(&apos;div&apos;);for(var i=0;i&lt;alldivs.length;i++)&#123; document.body.appendChild(document.createElement(&apos;div&apos;));&#125;//该循环会一直循环下去，因为每次添加一个div之后，alldicvs.length的值也会改变，导致循环条件一直为true，一直循环。 关于闭包和词法作用域 案例：12345678910function foo()&#123; concile.log(a);//2&#125;function bar()&#123; var a=3; foo();&#125;var a=2;bar();//原理：js的运行原理是词法作用域，而非动态作用域，因此当foo函数被调用的时候，对a进行查询的时候会直接在全局作用域中查询。 话题：display：none和visibility：hidden区别？ display：none；有dom树，没有渲染树，也就是说js可以找到display：none。 visibility：hidden；只是将内容隐藏起来了，还是要占位的。 话题：两个inline-block元素在同一行中间的那个间距是多少？ 每个浏览器间距不同。 字体大小不同间距不同。 如何去掉这个空格？ 去掉最底层html标签的空格。 margin为负值。（每个浏览器不同，值不同） 将父级元素的字体大小设置为0。（推荐方案） 注意： 这个间距不仅在水平方向有，在垂直方向也有！ 距离大概是字体大小的1/8（可能会有叠加）。 inline-block元素之间，block和inline-block和inline的元素之间都有间距。","categories":[],"tags":[{"name":"记录，前端，问题，讨论","slug":"记录，前端，问题，讨论","permalink":"http://yoursite.com/tags/记录，前端，问题，讨论/"}]},{"title":"数组","slug":"数组","date":"2017-04-10T11:13:22.000Z","updated":"2017-04-16T06:30:28.492Z","comments":true,"path":"2017/04/10/数组/","link":"","permalink":"http://yoursite.com/2017/04/10/数组/","excerpt":"数组","text":"数组 Array创建实例1234567891011//用构造函数的方法var colors=new Array();var colors=new Array(20);var colors=new Array(&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;);var colors=Array();//可以省略new//用数组字面量表示法var colors=[&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;];var names=[];var values=[1,2,];//不要这样，这样会创建一个包含2或3项的数组var options=[,,,,,]//不要这样，这样会创建一个包含2或6项的数组 检测数组 Array.isArray()确定一个值到底是不是数组转换方法 toString()：返回有由数组中每个值得字符串形式拼接而成的一个以逗号分隔的字符串。 valueOf()：直接返回数组 toLocaleString()：创建一个数组值的以逗号分隔的字符串。 1234567891011121314151617181920212223242526var colors=[&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;];alert(colors.toString()); //gray,green,redalert(colors.valueOf()); //gray,green,redalert(colors); //gray,green,red//最后一行将数组传给alert，alert要求接受字符串，所以后台自动调用头String（）var person1=&#123; toLocaleString:function()&#123; return &quot;Nikolaos&quot;; &#125;, toString:function()&#123; return &quot;Nicholas&quot;; &#125;&#125;;var person2=&#123; toLocaleString:function()&#123; return &quot;Grigorios&quot;; &#125;, toString:function()&#123; return &quot;Greg&quot;; &#125;&#125;;var people=[person1,person2];alert(people); //Nicholas,Gregalert(people.toString()); //Nicholas,Gregalert(people.toLocaleString()); //Nicholas,Grigorios join()方法：可以用其他符号来分隔数组 123var colors=[&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;];alert(colors.join(&quot;,&quot;)); //gray,green,redalert(solors.join(&quot;||&quot;)); //gray||green||red 栈方法 push()方法可以接受任意数量的参数，把他们逐个添加到数组末尾，并返回修改后的数组的长度。 pop()方法则是从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。123456789101112131415var colors=new Array();var count=colors.push(&quot;red&quot;,&quot;green&quot;);alert(count); //2count=colors.push(&quot;black&quot;);alert(count); //3var item=color.pop();alert(item); //&quot;black&quot;;alert(colors.length); //2//可以将栈方法和其它数组方法连用var colors=[&quot;red&quot;,&quot;blue&quot;];colors.push(&quot;brow&quot;);colors.[3]=&quot;black&quot;;alert(colors.length); //4var item=colors.pop();alert(item); //&quot;black&quot; 队列方法 shift()方法能够移除数组中的第一项，并且返回该项，同时将数组长度减1。 unshift()方法能在数组前段端添加任意个项并返回数组长度。12345678var colors=new Array();var count=colors.push(&quot;red&quot;,&quot;green&quot;);alert(count); //2var item=colors.shift();alert(item); //&quot;red&quot;alert(colors.length); //1count=colors.unshift(&quot;black&quot;);alert(count); //2 排序 reverse()方法：反转数组项的顺序。返回值是数组。 sort()方法：按升序排列数字项。（比较的是字符串）返回值是数组。1234567891011121314151617181920var values=[1,2,3,4,5];values.reverse();alert(values); //5,4,3,2,1var values=[0,1,5,10,15];values.sort();alert(values); //0,1,10,15,5//在字符串进行比较的时候5是比10大的，这个时候我们经常让sort方法接受一个比较函数作为参考。//比较函数（升序，改变大于和小于就能变成降序）function campare(value1,value2)&#123; if(value1&lt;value2) return -1; else if(value1&gt;value2) return 1; else return 0;&#125;var values=[0,1,5,10,15];values.sort(campare);alert(values); //0,1,5,10,15 操作方法 concat()方法：创建一个新的数组。复制一遍数组并在末尾添上新的元素。 1234var colors=[&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;];var colors2=colors.contac(&quot;yellow&quot;,[&quot;black&quot;,&quot;brown&quot;]);alert(colors); //gray,green,redalert(colors2); //gray,green,red,yellow,black,brown slice()方法：能够基于当前数组中的一或多个项创建一个新数组。 当有一个参数时：返回从该参数指定位置开始到当前数组末尾的所有项。 如果有两个参数时：返回起始和结束位置之间的项，但不包括结束为止的项。 splice()方法：主要用途是项数组中部插入项。（最强大的数组方法） 删除：需要两个参数，位置和删除项数。例：splice(0,2);删除数组中的前两项。 插入：需要三个参数，起始位置，0（删除的项数）和插入项。例：splice(2,0,&quot;red,&quot;green&quot;)从数组的位置2开始插入字符串”red”和”green”。 替换：需要三个参数，起始位置，要删除的的项数和要插入的任意数量的项。例：splice(2，1，&quot;red&quot;,&quot;green&quot;)删除当前数组位置2的项，然后再从位置2开始插入字符串。位置方法 indexOf()方法：从数组的开头开始向后查找。 lastIndexOf()方法：从数组的末尾开始向前查找。两个方法都接收两个参数，要查找的项和开始查找的起始位置。没找到的情况返回-1，返回值是位置。123456789101112var numbers=[1,2,3,4,5,4,3,2,1];alert(numbers.indexOf(4)); //3alert(numbers.lastIndexOf(4)); //5alert(numbers.indexOf(4，4)); //5alert(numbers.lastIndexOf(4，4)); //3var person=&#123;name:&quot;Nicholas&quot;&#125;;var people=[&#123;name:&quot;Nicholas&quot;&#125;];var morePeople=[people];alert(people.indexOf(person)); //-1alert(morePeople.indexOf(peoson)); //0 迭代方法 every():对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true，否则返回false。 filter():对数组中的每一项运行给定函数，返回该函数会返回true的项组成数组。 forEach():对数组中的每一项运行给定函数，这个方法没有返回值。 map():对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some():对数组中的每一项运行给定函数，如果该函数对任意一项返回true，则返回true。以上方法都不会修改数组中包含的值。都接收三个参数：数组项的值，该项在数组的位置，数组对象本身。1234567891011121314151617181920212223242526272829//every()var numbers=[1,2,3,4,5,4,3,2,1];var everyResult=numbers.every(function(item,index,array)&#123; return (item&gt;2);&#125;);alert(everyResult); //false//some()var numbers=[1,2,3,4,5,4,3,2,1];var someResult=numbers.every(function(item,index,array)&#123; return (item&gt;2);&#125;);alert(someResult); //true//filter()var numbers=[1,2,3,4,5,4,3,2,1];var filterResult=numbers.every(function(item,index,array)&#123; return (item&gt;2);&#125;);alert(filterResult); //[3,4,5,4,3]//map()var numbers=[1,2,3,4,5,4,3,2,1];var mapResult=numbers.every(function(item,index,array)&#123; return item*2;&#125;);alert(mapResult); //[2,4,6,8,10,8,6,4,2]//forEach()var numbers=[1,2,3,4,5,4,3,2,1];numbers.forEach(function(item,index,array)&#123; //执行某些操作&#125;); 归并方法 reduce():从数组的第一个开始，逐个遍历到最后。 reduceRight():从数组最后一个开始，逐个遍历到第一个。 这两个函数接收两个参数：一个在每一项上的调用的函数和（可选的）作为归并基础的初始值。 传给两个函数的函数接收四个参数：前一个值，当前值，项的索引，数组对象。 函数的返回值都会作为第一个参数自动传给下一项。123456789101112//reduce()正向var values=[1,2,3,4,5];var sum=values.reduce(function(prev,cur,index,array)&#123; return prev+cur;&#125;);alert(sum); //15//ruduceRight()反向var values=[1,2,3,4,5];var sum=values.reduceRight(function(prev,cur,index,array)&#123; return prev+cur;&#125;);alert(sum); //15","categories":[],"tags":[{"name":"数组,前端,笔记","slug":"数组-前端-笔记","permalink":"http://yoursite.com/tags/数组-前端-笔记/"}]},{"title":"DOM知识点","slug":"DOM知识点","date":"2017-04-10T11:07:45.000Z","updated":"2017-04-10T11:14:22.584Z","comments":true,"path":"2017/04/10/DOM知识点/","link":"","permalink":"http://yoursite.com/2017/04/10/DOM知识点/","excerpt":"DOM","text":"DOM D：document（文档）O：object（对象）：用户定义对象，内建对象，宿主对象M：model（模型）：“map”，树 节点 元素节点（element node）：body，ul，li……获取元素节点的方法： 通过元素id（getElementById ） 通过标签名（getElementsByTagName） 通过类名（getElementsByClassName） 属性节点（attribute node）&lt;p title=&quot;yang&quot;&gt;hahahahahahha&lt;/p&gt;title=”yang”是一个属性节点属性节点总是包含在元素节点中 文本节点获取和设置属性 getAttribute（获取） 12345//例子var paras=document.getElementsByTagName(&quot;p&quot;);for(var i=0;i&lt;paras.lengeh;i++)&#123; alert(paras[i].getAttribute(&quot;title&quot;));&#125; setAttribute（设置）若属性本不存在，实际就将完成两项操作：1.创建属性，2.设置值。注：并不会改变源文件扽静态内容。 123//例子var shopping=document.getElementById(&quot;purchases&quot;);shopping.setAttribute(&quot;title&quot;,&quot;a list of goods&quot;); 实例：JavaScript图片库 childNodes属性用来获取任何一个元素的所有子元素。 123456//获取body所有子元素个数的函数例子function countBodyChildren()&#123; var body_element=document.getElementsByTagName(&quot;body&quot;)[0]; alert(body_element.childNodes.length);&#125;window.onload=countBodyChildren; nodeType属性 元素节点的nodeType属性值是1。 属性节点的nodeType属性值是2。 文本节点的nodeType属性值是3。alert(body_element.nodeType); nodeValue属性得到和设置一个节点的值。alert(discription.nodeValue); firstChild和lastChild属性这两个属性都是为了个简便且直观的获取对应的元素。 注意点 DOM是一套对文档内容进行抽象和概念化的方法。 变量名中不能包含空格和标点符号（美元$符号除外）。 变量名允许包含字母，数字，美元符号和下划线（但第一个字符不能是数字）。 变量申明实例：my_mood或者myMood（峰驼式camel case：首选）。 Javascript是弱类型语言，不需要对变量进行类型声明。 变量可以包含操作。 字符串可以做拼接操作。 innerHTML属性和documen.write方法都是HTML的专有属性。var message=&quot;I am feeling&quot;+&quot;happy&quot;; 每个元素节点都是一个对象。","categories":[],"tags":[{"name":"DOM,JS,前端","slug":"DOM-JS-前端","permalink":"http://yoursite.com/tags/DOM-JS-前端/"}]},{"title":"BOM知识点","slug":"BOM知识点","date":"2017-04-06T00:56:57.000Z","updated":"2017-04-10T11:06:12.512Z","comments":true,"path":"2017/04/06/BOM知识点/","link":"","permalink":"http://yoursite.com/2017/04/06/BOM知识点/","excerpt":"BOM","text":"BOM 一、window对象1.全局作用域 全局变量会变成window对象的属性。 全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性可以。 123456789var age=29;window.color=&quot;red&quot;;//在IE&lt;9时抛出错误，在其他所有浏览器中都返回falsedelete window.age;//在IE&lt;9时抛出错误，在其他所有浏览器中都返回truedelete window.color;//returns truealert(window.age);//29alert(window.color);//undefined 尝试访问未声明变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明变量是否存在。 窗口关系及框架 除非最高层窗口是通过window.open()打开的，否则其window对象的name属性不会包含任何值。 在使用框架的情况下，浏览器中会存在多个Global对象。 在每个框架中定义的全局变量会自动变成框架中window对象的属性。 由于每个window对象都包含原生类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应但并不相等。 窗口位置 screenLeft/screenTop:分别用于表示相对于屏幕左边和上边的位置。 screenY/screenX:提供相同的窗口位置属性。`` 12var leftPos=(typeof window.screenLeft==&quot;number&quot;)?window.screenLeft:window.screenX;var topPos=(typeof window.screenLeft==&quot;number&quot;)?window.screenTop:window.screenY; 注意：最终无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值。 moveTo()两个参数:移动到什么位置去。 moveBy()两个参数:向什么地方移动。两个函数不适用与框架，只能对最外层的window对象使用。 窗口大小 innerWidth/innnerHeight:返回浏览器本身的尺寸。 outerWidth/outerHeight:返回浏览器本身的尺寸。 document.documentElement.clientWidth/document.documentElement.clientHeight 12345678910111213var pageWidth=window.innerWidth; pageHeight=window.innerHeight;if(typeof pageWidth!=&quot;number&quot;)&#123; if(document.compatMode==&quot;CSS1Compat&quot;)&#123; //通过检查document.compatMode来确定页面是否处于标准模式 pageWidth=document.documentElement.clientWidth; pageHeight=document.documentElement.clientHeight; &#125; else&#123; pageWidth=document.body.clientWidth; pageHeight=document.body.clientHeight; &#125;&#125; resizeTo()两个参数:调整到。 resizeBy()两个参数:接受新窗口与原窗口的宽度和高度之差。两个函数不适用与框架，只能对最外层的window对象使用。 导航和打开窗口 window.open():既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。接收四个参数：1.要加载的URL 2.窗口目标 3.一个特定的字符串 4.一个表示新页面是否取代浏览器历史纪录中当前加载页面的布尔值方法会返回一个指向新窗口的引用。 1.打开窗口 2.安全限制 3.弹出窗口屏蔽程序 1234567891011121314var blocked=false;try&#123; var wroxWin=window.open(&quot;http://www.wrox.com&quot;, &quot;_blank&quot;); if(wroxWin==null)&#123; blocked=true; &#125;&#125;catch(ex)&#123; blocked=true;&#125;if(blocked)&#123; alert(&quot;The popup was blocked!&quot;);&#125; 在任何情况下，以上代码都可以检测出调用window.open()打开的弹出窗口是不是被屏蔽来了。但要注意的是，检测窗口是否被屏蔽只是一方面，它并不会阻止浏览器显示与被屏蔽的弹出窗口有关的消息。 间歇调用和超时调用 JavaScript是单线程语言，但它允许通过设置超时值和间歇值来调度代码在特定的时刻执行。 setTimeout(): 接受两个参数：1.要执行的代码（不建议传字符串，因为可能导致性能损失，建议用函数） 2.以毫秒表示的时间 该方法会返回一个数值ID，表示超时调用。这个超时调用ID是计划执行代码的唯一标识符，可以通过它来取消超时调用。 setInterval(): 与超时调用类似，但是它会按照指定的时间间隔重复执行代码，直到间歇调用被取消或者页面被卸载。 也接受两个参数：1.要执行的代码 2.以毫秒表示的时间 clearTimeout():取消超时调用或者间歇时间调用。 在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。所以，最好不要使用间歇调用。 一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。 123456789101112131415var num=0;var max=10;function incremenetNumber()&#123; num++; //如果执行次数尚未达到max设定的值，则设置另一次超时调用 if(num&lt;max)&#123; setTimeout(incrementNumber,500); &#125; else&#123; alert(&quot;Done!&quot;); &#125;&#125;setTimeout(incrementNumber,500); 系统对话框 alert():向用户显示一个系统对话框，其中包含一个制定的文本和一个OK（确定）按钮。 confirm():向用户显示“警告”对话框，返回true或者flase。 prompt():显示一个“提示”框，用于提示用户输入一些文本。接受两个参数：1.要显示给用户的文本提示 2.文本输入域的默认值。 window.find():显示“查询”对话框。 window.print():显示“打印”对话框。 二、location对象查询字符串参数 解析查询字符串的函数 1234567891011121314151617181920212223242526272829303132function getQueryStringArgs () &#123; // 解析查询字符串 //取得查询字符串并去掉开头的问号 var qs=(location.search.length&gt;0?location.search.substring(1):&quot;&quot;), //保存数据对象 args=&#123;&#125;, //取得每一项 items=qs.length?qs.sqlit(&quot;&amp;&quot;):[], item=null, name=null, value=null, //在for循环中使用 i=0, len=items.length; //逐个将每一项添加到args对象中 for (var i = 0; i &lt; len ; i++) &#123; item=items[i].sqlit(&quot;=&quot;); name=decodeURIComponent(item[0]); value=decodeURIComponent(item[1]); if (name.length) &#123; args[name]=value; &#125; &#125; return args;&#125; 位置操作改变浏览器的位置 assigned()：location.assign(&quot;http://www.wrox.com&quot;); location.href window.location replace()：让用户无法回到前一个页面，历史记录中不会生成新的记录。 raload()：作用是重新加载当前显示的页面。最好将其放在代码的最后一行。 三、navigation对象检查插件 检查插件 123456789101112131415161718192021222324252627282930313233//检查插件（在IE中无效）function hasPlugin (name) &#123; name=name.toLowerCase(); for (var i = 0; i &lt; navigator.plugins.length; i++) &#123; if (navigator.plugins[i].name.toLowerCase().indexOf(name)&gt;-1) &#123; return true; &#125; &#125; return false;&#125;//检测flash//alert(hasPlugin(&quot;Flash&quot;));//检测QuickTime//alert(hasPlugin(&quot;QuickTime&quot;));//检测IE中的插件function hasIEPlugin (name) &#123; try&#123; new ActiveXObject(name); return true; &#125; catch(ex)&#123; return false; &#125;&#125;//检测flash//alert(hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;));//检测QuickTime//alert(hasPlugin(&quot;QuickTime.QuickTime&quot;)); 注册处理程序 registerContentHandler()：接收三个参数：1.要处理的MIME类型。2.可以处理该MIME类型的页面的URL。3.应用程序的名称。 registerProtocolHandler()：接收三个参数：1.要处理的协议。2.处理该协议的页面的URL。3.应用程序的名字。 四、screen对象五、history对象 go() back() forward() lengh属性","categories":[],"tags":[{"name":"BOM,前端,笔记","slug":"BOM-前端-笔记","permalink":"http://yoursite.com/tags/BOM-前端-笔记/"}]},{"title":"动画和HTML5","slug":"动画和HTML5","date":"2017-03-23T06:33:24.000Z","updated":"2017-03-23T06:39:11.819Z","comments":true,"path":"2017/03/23/动画和HTML5/","link":"","permalink":"http://yoursite.com/2017/03/23/动画和HTML5/","excerpt":"用JavaScript实现动画效果","text":"用JavaScript实现动画效果 知识点 position属性： static：默认值，意思是有关元素将按照它们在标记里出现的先后顺序出现在浏览器窗口里。 relative：与static相似，区别是relative的元素还可以（通过应用float属性）从文档的正常显示顺序里脱离出来。 absolute：我们就可以将它摆在“容器”的任何位置。这个容器要么是文档本身，要么是一个有着fixed或absolute属性的父元素。这个元素在原始标记里面出现的位置与它显示位置无关，因为它的显示位置由top，left，right和bottom等属性决定。你可以使用像素或百分比为单位设置这些属性。 overflow属性： visible：不裁剪溢出内容。 hidden：隐藏溢出内容。 scroll：类似鱼hidden，浏览器将对溢出的内容进行隐藏，但显示一个滚动条以便让用户能够滚动看到内容的其他部分。 auto：类似于scroll，但浏览器只在确实发生溢出时才显示滚动条，如果没有溢出就不显示滚动条。时间 setTimeout：能够让某个函数在经过一段预定的时间之后才开始执行。 函数有两个参数：第一个是字符串，执行的函数名；第二个是数值，以毫秒为单位设定了需要经过多长时间才开始执行第一个参数所给出的函数。 setTimeout(&quot;function&quot;,interval) 在绝大多数情况下，将函数调用赋值给一个变量是一个好主意。 varible=setTimeout(&quot;function&quot;,interval) 取消某个正在排队等候执行的函数： clearTimeout(variable) HTML5video： currentTime：返回当前播放的位置，以秒表示； duration：返回媒体的总时长，以秒表示，对于流媒体返回无穷大； * paused：表示媒体是否处于暂停状态； 触发脚本的事件： play：在媒体播放开始时发生； pause：在媒体暂停是发生； loadeddata：在媒体可以从当前播放位置开始播放时发生； ended：在媒体已播放完成而停止时发生； 别忘了给&lt;video&gt;元素叫control属性： &lt;video src=&quot;movie.ogv&quot; control&gt; 表单：新的输入控件类型 email，用于输入电子邮件地址； url，用于输入URL； date，用于输入日期和时间； number，数值； ranger，生成滑动条； search，搜索框； tel，电话号码； color，选择颜色；新的属性 autocomplete，用于为文本（text）输入框添加一组建议的输入项； autofocus，让表单元素自动获得焦点； form，对标签外部的表单元素分组； min，max和step，用在范围（range）和数值（number）输入框中； pattern，定义一个正则表达式，以便验证输入的值； placeholder，在文本输入临时性的提示信息； required，表示必填；","categories":[],"tags":[{"name":"JS,动画,HTML5","slug":"JS-动画-HTML5","permalink":"http://yoursite.com/tags/JS-动画-HTML5/"}]},{"title":"JSON相关内容","slug":"JSON相关内容","date":"2017-03-22T15:02:31.000Z","updated":"2017-03-23T06:39:20.513Z","comments":true,"path":"2017/03/22/JSON相关内容/","link":"","permalink":"http://yoursite.com/2017/03/22/JSON相关内容/","excerpt":"JSON","text":"JSON 知识点 JSON是一种数据结构，不是一种编程语言。 语法（三种类型的值） 简单值：使用JavaScript语法，可以在JSON中表示字符串、数值、布尔值和null，但不支持undefined。 字符串必须用双引号。 没有变量，没有分号。 对象：表示一组无序的键值对儿，每个键值对儿的值可以是简单值，也可以是复杂数据类型。 对象的属性必须加双引号。 没有声明，没有末尾的分号。 一个对象绝不能出项两个同名的属性。 数组：一组有序的值的列表，可以通过数值索引类访问其中的值，数组的值也可以是任意值。 没有变量，没有分号。 解析与序列化JSON可以将JSON数据结构解析为有用的JavaScript对象。 JSON对象 stringify()：将JavaScript对象序列化为JSON字符串。 parse()：将JSON字符串解析为原生的JavaScript值。 序列化选项 stringify()除了要序列化的JavaScript对象外，还可以接收两个参数，用于指定以不同的方式序列化JavaScript对象。一个是参数过滤器（可以是数组，可以是函数），第二个参数是选项，表示是否在JSON字符串中保存缩进。 如果是数组，就返回对象相应的属性。 如果是函数，返回值是undefined将会被忽略。 字符串缩进：第三个参数用于控制结果中的缩进和空白字符串。如果是数字就表示的是每个级别缩进的空格数。 toJSON()方法：（没看懂）。","categories":[],"tags":[{"name":"JSON，前端","slug":"JSON，前端","permalink":"http://yoursite.com/tags/JSON，前端/"}]},{"title":"css选择器、权重及优先级","slug":"css选择器、权重及优先级","date":"2017-03-21T07:11:22.000Z","updated":"2017-03-23T06:39:35.900Z","comments":true,"path":"2017/03/21/css选择器、权重及优先级/","link":"","permalink":"http://yoursite.com/2017/03/21/css选择器、权重及优先级/","excerpt":"遇到的问题","text":"遇到的问题 子元素使用padding会影响父元素。（解决方法是给父元素用padding） 背景图片的设置。（已解决） 分享会（胡小青）CSS选择器、权重及优先级选择器的种类 通配符选择器（＊） id选择器（#ID） 类选择器（.className） 标签选择器(E) 后代选择器（Ｅ Ｆ） 子元素选择器(E&gt;F) 相邻兄弟元素选择器(E + F) 群组选择器（selector1,selector2,…,selectorN） 交集选择器（E.className) 属性选择器 伪类选择器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//html&lt;div id=&quot;share&quot;&gt;id选择器&lt;/div&gt;&lt;div class=&quot;share&quot;&gt;类选择器&lt;/div&gt;&lt;div&gt; &lt;em&gt;标签选择器&lt;/em&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;后代选择器&lt;/p&gt; &lt;p&gt;&lt;span&gt;非直系后代&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;子元素选择器&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;相邻兄弟1&lt;/p&gt; &lt;span&gt;相邻兄弟2&lt;/span&gt;&lt;/div&gt;&lt;div&gt; &lt;h1&gt;群组选择器&lt;/h1&gt; &lt;h2&gt;群组选择器&lt;/h2&gt; &lt;h3&gt;群组选择器&lt;/h3&gt;&lt;/div&gt;//css*&#123; margin: 0; padding: 0;&#125;#share&#123; width: 200px; background: #cfd2d1;&#125;.share&#123; width: 200px; background: #e9eeec; margin-bottom: 10px;&#125;div.share &#123; border: 2px solid #000;&#125;em&#123; background: #f5f6f6;&#125;div p &#123; background: #e9eeec;&#125;div p span&#123; width: 200px; background: #acb1af;&#125;div &gt; p &#123; width: 200px; background: #adcec0;&#125;p + span &#123; width: 200px; background: #9d9e9e;&#125;h1,h2,h3 &#123; width: 200px; background: #afead2;&#125; 属性选择器 属性选择器 功能 E[att] 匹配所有具有att属性的E元素，不考虑它的值。 css2 E[att=val] 匹配所有att属性等于”val”的E元素 css2 E[att~=val] 匹配属性包含val的元素，并设置其样式：注意是val，所以val-ab这样不算 css2 E[att\\ =val] 匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以”val”开头的E元素，主要用于lang属性 css2 E[att^=val] 选择匹配的元素E，E定义了属性att,属性值以val开头的字符串 css3 E[arr$=val] 选择匹配的元素E，E定义了属性att,属性值以val结尾的字符串 css3 E[att*=val] 选择匹配的元素E，E定义了属性att,属性值包含val的字符串，也就是val可以在任意位置 css3 123456789101112131415161718192021222324252627282930//html&lt;a href=&quot;xxx.pdf&quot;&gt;我链接的是PDF文件&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;icon&quot;&gt;我类名是icon&lt;/a&gt;&lt;a href=&quot;#&quot; title=&quot;我的title是more&quot;&gt;我的title是more&lt;/a&gt;&lt;a href=&quot;#&quot; name=&quot;about&quot; lang=&quot;en-zhN&quot;&gt;选择含有about的元素&lt;/a&gt;&lt;a href=&quot;#&quot; name=&quot;about-ab&quot; lang=&quot;en&quot;&gt;选择含有about的元素&lt;/a&gt;&lt;a href=&quot;#&quot; name=&quot;about ab&quot;&gt;选择含有about的元素&lt;/a&gt;//cssa[href=&quot;xxx.pdf&quot;] &#123; border: 1px solid #000;&#125;a[href$=pdf]&#123; background: orange; color: #fff;&#125;a[class^=icon] &#123; background: #55e2a8; color:#fff;&#125;a[title*=more] &#123; background: #7a92e9; color: #fff;&#125;a[name~=about] &#123; background: #55e2a8;&#125;a[lang|=en] &#123; border: 1px solid #000;&#125; 伪类选择器 *动态伪类 锚点伪类 :link 链接访问前状态 :visited 链接访问后状态 :hover 鼠标悬浮链接的状态 :active 激活链接时的状态 伪类的顺序：link - visited -&gt; hover -&gt; active 用户行为伪类 :hover 用于当用户把鼠标移动到元素上面时的效果 :active 用于用户点击元素那一下的效果 :focus用于元素成为焦点，这个经常用在表单元素上 顺序： focus - &gt; hover -&gt; activeIE6下只有&lt;a&gt;支持:hover，IE6,7都不支持:focus、:active 1234567891011121314151617181920212223//html&lt;a href=&quot;#&quot; class=&quot;link&quot;&gt;link效果&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;visited&quot;&gt;visited效果&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;hover&quot;&gt;hover效果&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;active&quot;&gt;active效果&lt;/a&gt;&lt;input type=&quot;text&quot; name=&quot;&quot;&gt;//css.link:link &#123; background: pink;&#125;.visited:visited&#123; background: #cca;&#125;.hover:hover &#123; background: lightblue;&#125;.active:active &#123; background: lightgreen;&#125;input:focus &#123; outline: 2px solid red;&#125; UI元素状态伪类这类伪类主要针对form元素 伪类 功能 适用元素 :enabled 匹配表单中激活的元素 type=”text” :disabled 匹配表单中禁用的元素 type=”text” :checked 匹配表单中被选中的radio（单选框）或checkbox（复选框）元素 type=”radio” ::selection 匹配用户当前选中的元素 123input[type=&quot;radio&quot;]:disabled &#123; background-color: red;&#125; 结构伪类 :first-child* 选择某个元素的第一个子元素,IE6不支持； :last-child* 选择某个元素的最后一个子元素； :nth-child()* 选择某个元素的一个或多个特定的子元素，IE6-8，Firefox3.0不兼容； :nth-child(length)&ensp;&ensp;参数是具体数字 :nth-child(n)&ensp;&ensp;参数是n,n从0开始计算 :nth-child(nlength)&ensp;&ensp;n的倍数选择，n从0开始算 :nth-child(n+length)&ensp;&ensp;选择大于length后面的元素 :nth-child(-n+length)&ensp;&ensp;选择小于length前面的元素 :nth-child(nlength+1)&ensp;&ensp;表示隔几选一 123456789101112131415li:last-child &#123; background: #f9f57a;&#125;li:nth-child(2) &#123; background: #c8cac9;&#125;li:nth-child(2n) &#123; border: 3px solid red;&#125;li:nth-child(n+3) &#123; border: 3px solid yellow;&#125;li:nth-child(-n+3) &#123; border: 3px solid yellow;&#125; :nth-last-child()选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算，IE6-8，Firefox3.0不兼容； :nth-of-type()选择指定的元素,与nth-child类似也可以使用表达式，IE6-8，Firefox3.0不兼容； :nth-last-of-type()选择指定的元素，从元素的最后一个开始计算； :first-of-type选择一个上级元素下的第一个同类子元素，与first-child类似，不过是指定了元素类型； :last-of-type选择一个上级元素的最后一个同类子元素； :only-child选择的元素是它的父元素的唯一一个子元素，兼容到IE9； :only-of-type选择一个元素是它的上级元素的唯一一个相同类型的子元素，IE6-8，Firefox3.0不兼容； :empty选择的元素里面没有任何内容，兼容到IE9； :not()选择不匹配的元素，兼容到IE9； target 匹配文档中特定”id”点击后的效果，兼容到IE9。 1234567891011121314151617181920//html&lt;a href=&quot;#test&quot;&gt;test&lt;/a&gt;&lt;div&gt;第一个div&lt;/div&gt;&lt;p&gt;第一个p&lt;/p&gt;&lt;div id=&quot;test&quot;&gt;第二个div&lt;/div&gt;&lt;p&gt;第二个p&lt;/p&gt;&lt;p&gt;&lt;/p&gt;//cssdiv:not&#123; background-color: lightgrey;&#125;p:empty&#123; height:30px; width:30px; background:pink;&#125;div:target&#123; color:blue;&#125; 伪元素选择器 伪元素 功能 :first-line 匹配元素的第一行 :first-letter 匹配元素的第一个字母 :before 元素之前插入生成的内容 :after 元素之后插入生成的内容 :selecton 改变浏览网页选中文的默认效果 伪元素可以用::也可以用:关于first-letter使用条件比较苛刻，一般只有有兴趣可以参考深入CSS ::first-letter伪元素及其实例 123li::first-letter &#123; font-size: 56px;&#125; 伪类和伪元素的区别&gt; CSS 伪类用于向某些选择器添加特殊的效果。 CSS 伪元素用于将特殊的效果添加到某些选择器。两者都与选择器相关，可以添加一些“特殊”的效果。 区别：&ensp;&ensp;&ensp;&ensp;伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到 伪类 12345678910//html&lt;p&gt; &lt;i&gt;first&lt;/i&gt; &lt;i&gt;second&lt;/i&gt;+&lt;/p&gt;//cssp&gt;i:first-child &#123; color: red&#125; 伪类 :first-child 添加样式到第一个子元素如果我们不使用伪类，而希望达到上述效果，可以这样做： 12345678910//html&lt;p&gt; &lt;i class=&quot;first-child&quot;&gt;first&lt;/i&gt; &lt;i&gt;second&lt;/i&gt;&lt;/p&gt;//css.first-child &#123; color: red&#125; 我们给第一个子元素添加一个类，然后定义这个类的样式。 伪元素：1234567//html&lt;p&gt;I am stephen lee.&lt;/p&gt;//cssp:first-letter &#123; color: red&#125; 伪元素 :first-letter 添加样式到第一个字母那么如果我们不使用伪元素，要达到上述效果，我们可以这样做： 123//html&lt;p&gt; &lt;span&gt;I&lt;/span&gt; am stephen lee.","categories":[],"tags":[{"name":"笔记，分享，前端","slug":"笔记，分享，前端","permalink":"http://yoursite.com/tags/笔记，分享，前端/"}]},{"title":"FirstPassage","slug":"FirstPassage","date":"2017-03-20T13:20:46.000Z","updated":"2017-03-23T06:39:29.196Z","comments":true,"path":"2017/03/20/FirstPassage/","link":"","permalink":"http://yoursite.com/2017/03/20/FirstPassage/","excerpt":"第一篇博文（搭建博客的坑！！！）","text":"第一篇博文（搭建博客的坑！！！） 1.关于Hexo nmp安装Hexo 打开命令行工具，执行如下命令： $ npm install -g hexo 创建文件夹 本人是直接在D盘创建了一个名叫blog的文件夹，在blog中创建了Hexo文件夹。（这个看个人喜好吧，用命令行也未尝不可。） 初始化 在Hexo目录下打开命令行工具，执行： hexo init 之后执行： hexo server 会看到： INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 访问：http://localhost:4000/就可以看到Hexo的初始页面了。 2.关于个人设置 基本信息 本人修改了title、subtitle、author的内容，如下： 1234567# Sitetitle: YangKunyi的博客subtitle: 爱看书的杨杨description:author: FrannieYilanguage:timezone: 第一个坑注意每一个冒号后面都有一个空格 无法生效的写法：title:Drubear的博客有效的写法：title:[空格]Drubear的博客 主题 知乎 - 好看的主题！ 使用git命令在github上clone下自己喜欢的主题，本人使用的是litten的yilia。 配置主题根据clone下来的主题将页面进行个性化设置。可以参考博主给的各种参数。 部署设置 只需简单的执行 hexo d But，重点来了前方巨坑请注意 首先在github上建立一个仓库，名字叫做：[你的用户名].github.io注意，你的用户名必须与你实际的用户名一字不差！ 拥有了个人的GitHubPages后，再回到Hexo的_config.yml文件，找到Deployment章节，做以下修改：（以FrannieYi为用户名为例）123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/FrannieYi/FrannieYi.github.io.git branch: master 以上两步做完后，执行 hexo d如果没有报错，你是幸运的。本人在这个坑里栽了无数次，系统报错 ERROR Deployer not found: Git 最后发现这个错误是因为少运行了一行代码： npm install hexo-deployer-git --save 运行完以上代码终于，本人泪流满面的看到了自己亲手搭建的博客。","categories":[],"tags":[{"name":"hexo,github","slug":"hexo-github","permalink":"http://yoursite.com/tags/hexo-github/"}]}]}