[{"title":"不动产管理复习","date":"2018-01-03T12:10:09.000Z","path":"2018/01/03/不动产管理复习/","text":"今天抽空整理了上个星期的不动产管理的复习题，当作复习吧，毕竟下个周就要考试了。 样品屋不是不动产。 不是定着物的特点：继续附着在建筑物上。 不动产的定义未包含预售屋。 要销售预售屋必须要有建造执照。 不动产物权只要签约就生效(X)；需要登记。 物权优先于债权。 关于地上权：不以支付地租为必要,不以订定租期为必要,地上权之目标为土地。 一坪 = 3.3058平方公尺 一平方公尺 = 0.3025坪 描述土地的词语：面积，位置，形状（密度不是）。 都市计划法包括的内容：乡镇计划，乡街计划，特定区计划。 基地面积100平方公尺,建蔽率50%,总楼地板面积25000平方公尺,容积率为多少?(容积率:楼地板面积除以建蔽率) 500% 容积率500%,基地面积100平方公尺,建蔽率50%,可盖几楼? (容积率除以建蔽率)10楼 从地籍图无法知道市价。 土地的性质不包括：异质性。 预售屋：高风险高报酬（自备款比中古屋少，总价负担重）。 房地产的特性：不可移动性，消费性，投资性。产品一致性不是房地产的特性。 在非都市土地中,山坡地保育区所兴建的房屋会属于何者用地?丙（老丙建）(甲:乡村 乙:乡村 丙:山坡 丁:工业) 所有权类型： 单独持有，分别共有，共同共有。 分别共有的特性：应有部分均等，着重应有部分，可自由处分应有部分。 房地产的声明周期：投资-&gt;生产-&gt;交易-&gt;使用。 共同共有：合伙财产（合伙人），共同财产（夫妻），未分割的遗产（继承）。 不是市地重划的原因：使用为公共交通促进土地合理之需要者（非都市）。 市地重划：经政府选定指定范围办理市地重划；人民申请优先办理；奖励私人自办重划。 市地重划描述错误的：重划后的土地按抽签的方式分配给原土地所有权人（按原位）。 市地重划中,土地所有权人共同负担不可超过? 45% 市地重划的效益：增加土地供给，促进土地利用，提高土地价值。不是为了增进当地人口数。 市地重划（一定是都市土地）的原因：新设都市地区的全部或一部分，实施开发建设；旧都市地区为公共安全促进土地合理需要者；都市土地开发新社区者。 市地重划后土地所有人最少可领回? 55% 桃园航空城属于哪一种征收？ 区段征收 有关区段征收的描述，错误的是：仅适用于都市土地 区段征收：国家因公益需要的征收私有土地；土地征收程序第一步是举办公听会；新设都市地区的全部或一部分，实施开发者可以进行区段征收。 区段征收与市地重划的比较何者错误? 区段征收较公平（区段征收不公平） 一般征收与区段征收之描述何者错误?一般征收之原因不一定要为公共事业需要者（征收的土地一定要用于公共事业）–正确的：区段征收执行较为困难；区段征收公共设施较多样性；市地重划民众参与较多；区段征收的原因是开发建设或者促进土地利用；区段征收以现金、抵债地予以补偿；区段征收就是一定区域内的土地全部征收。 国泰禾 定型化契约是根据消费者保护法定下的。 登记面积超过3%就可以解约了。 预售屋定型化契约不得记载事项：广告仅供参考/使用面积销售等 公寓大厦管理条理的适用描述：建物形态相关 住户权益义务说法错误：不须负担共同壁的管线维修费用（需要） 物业管理范围不包括个人财务管理。 消费者保护法和公平交易法的描述错误的是：广告不实无法依据公交法向业者开罚。 适用于公平交易法：先付订金才可看契约,没有接露重要信息（违反了市场交易秩序） 社会住宅的用意：只租不卖；帮助经济弱势；协助社会弱势。 都市更新不包括：合建。 约定专用部分说明正确的：经约定将共享部分给特定区分所有权人使用 权利变换正确的是：（都市更新）立体分配的概念，重新分配土地和建物 物权具有排他性,请求权,追及性 凉亭是建筑物，门框铁窗是固定物，售票亭不是不动产 使用执照是卖之后才有 区段征收执行比较困难也应该是最后一个手段,公共设施比较多样性(因为政府拿比较多)所以市地重划的公社是比较少的。 保留增收:还不知道做甚么用先保留 区段征收:大规模大面积征收 一并征收:我要征收这边这边有小块一并征收 区段增收:抽签 市地重划:原位 公同共有:双方因法律关系共同持有这个东西","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yangkunyi.com/tags/笔记/"},{"name":"复习","slug":"复习","permalink":"http://yangkunyi.com/tags/复习/"},{"name":"不动产","slug":"不动产","permalink":"http://yangkunyi.com/tags/不动产/"}]},{"title":"WeeklyMind-6","date":"2017-12-30T15:11:06.000Z","path":"2017/12/30/WeeklyMind-6/","text":"2017就这样过了，今天已经是2018年了，想来这一年确实发生了太多的事情，自己的价值观也在这些事情中一次次的改变和塑造着，未来的路在昨天的铺垫中慢慢成型，在今天的过程中慢慢延伸，在明天的憧憬理慢慢向前。这个周开始进入考试复习周，下周三就开始考试了，但自己在假期里显得十分的懒散，可能是因为自己这两天一直在想这一年自己到底干了什么，事情太多，整整两个日记本了，这应该就是自己的成长吧，在这里还是不想太多，就说说这个周。 学习 web课程已经结束了。下周三期末考试，作为自己最不担心的一门课程，只希望自己不要粗心吧。 行销管理的小组报告自己有想好好做出来，做一个成品，之后也可以拿得出手，所以自己把自己当作这个小组的组长，一直在拉着整个报告的进度，但是这个假期还是懈怠了很多，不过假期嘛，大家都没有将心思放在这上面，所以打算回来后继续。 不动产管理课程也结束了，因为元旦下周的课程放掉了，下下周直接考试，这门课也希望自己能不留遗憾的完成，毕竟是缘分让自己选了这门课。 财务管理一直是自己不喜欢又带有些害怕的课程，考试范围也算是出来了，所以只能说努力吧。 西方哲学史也因为假期结课了，最后仍是考试，这门课自己倒不是很担心。 体育课已经结课了，从来不担心的课程，应该是一个不错的成绩。 人际管理课程报告也结束了，还有最后两节课和与一个期末总结就完成了，成绩应该也算理想，报告自己觉得做得也不错。 所有课程都进入尾声，自己在这边的学习生活也只剩下最后的15天了。来到这里就说自己要做点什么，然后度过前一周的新鲜期之后陷入深深的迷茫期，感觉不知道做什么，课程前期比较轻松，大把的时间让自己思考，突然不知道该做些什么，直到找到真正的目的——体验，才真正算是投入了这边的生活，这时候在想这五个多月自己没有辜负，完成了这一次体验的行程，自己也清楚的感受到，除了知识，这一次的体验拓展了自己的太多，就想自己开始说的那样，这段经历也是自己人生路的铺垫。 生活 因为小组报告，自己又认识了一群来自不同地方的朋友。一双眼睛只能看到一个世界，但不同双眼睛就能看到不同的世界，自己在这些朋友的眼睛里又看到了不同的世界，那是自己不曾接触过的，却充满智慧，充满乐趣。 不动产管理的老师请全班的同学吃了披萨，虽然不是老师第一次请吃东西，但是这种氛围自己是第一次感受。从小，在自己的眼里，老师都是要尊敬的，这样自己和老师之间从来都没有向朋友一样亲近过，因为自己在老师面前就是无法将自己视为老师的朋友，但是那个时候我真的没有把筱蓉当作老师来看待，当然不仅仅是因为一顿批萨，而是筱蓉身上散发出来的气场，那种亲和的态度，我也不是说之前的老师不亲和，反正就是个人觉得自己是真的很喜欢筱蓉，也很喜欢她不拘小节的课程。 原校下周就要选课了，自己想来其实也没有太困难，就是物流的课程需要补回来，其余都还好，所以没必要那么担心。 人间一趟，看看太阳。","tags":[{"name":"周记","slug":"周记","permalink":"http://yangkunyi.com/tags/周记/"}]},{"title":"PHP绘图","date":"2017-12-24T04:25:09.000Z","path":"2017/12/24/PHP绘图/","text":"web课程的笔记和一些实例代码。还有一份自定义图形作业，感觉还不错，简单做了一个二维码。（全是画矩形，确实有点无聊了，有空画点有趣的图） PHP绘图1. GD（Graphics Dynamic Library） GD1 / GD2 可以通过phpinfo()来查询 2. 绘图流程1234567891011121314151617181920212223242526272829303132333435// 确定绘画图片的格式// 格式有：jpg，png，gifheader(&quot;Content-type:image/格式&quot;);// 1. 建立一个画布（分配存储空间）$image = ImageCreate(长度,宽度);// 一般画布$image = ImageCreateTrueColor(长度,宽度);// 高清// 2. 建立颜色板$bgcolor=ImageColorAllocate($image,0,255,0);// 默认背景颜色// 3. PHP绘图命令// 点 ImageSetPixel($image,x,y,$color)ImageSetPixel($image,90,40,$textcolor);// 线 ImageLine($image,x1,y1,x2,y2,$color)ImageLine($image,0,0,$bgcolor);// 弧 ImageArc($image,x,y,高,宽,开始角度,结束角度,$color)ImageArc($image,50,25,90,40,0,360,$textcolor1);// 巨型 ImageRectangle($image,x1,y1,x2,y2,$color)ImageRectangle($image,20,10,80,40,$textcolor);// 空心多边形 ImagePolygon($image,$点数组,点数,$color)ImagePolygon($image,$point,count($point)/2,$textcolor);// 实心多边形 ImageFilledPolygon($image,$点数组,点数,$color)ImageFilledPolygon($image,$point,count($point)/2,$textcolor);// 透明 ImageColorTransparent($image,$color)ImageColorTransparent($image,$textcolor);// 文字输出 ImageTTFtext($image,大小,角度,x,y,$color,字体绝对路径,string)ImageTTFtext($image,32,0,0,50,$textcolor,&quot;simhei.ttf&quot;,$string);// 4. 显示/导出 ImageXXX($image[,储存图形的位置和名称])Imagepng($image);// 5. 结束 释放空间ImageDestroy($image); 实例：二维码绘制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;?php // 文件输出图片格式为png header(&quot;Content-type:image/png&quot;); // 建立一个画布 $image = ImageCreate(100,100); // 设定画布的北京颜色 $bgcolor = ImageColorAllocate($image,255,255,255); ImageFill($image,0,0,$bgcolor); // 画笔的颜色 $black = ImageColorAllocate($image,0,0,0); $white = ImageColorAllocate($image,255,255,255); ImageFilledRectangle($image,0,0,28,28,$black); ImageFilledRectangle($image,4,4,24,24,$white); ImageFilledRectangle($image,8,8,20,20,$black); ImageFilledRectangle($image,72,0,500,28,$black); ImageFilledRectangle($image,76,4,96,24,$white); ImageFilledRectangle($image,80,8,92,20,$black); ImageFilledRectangle($image,0,72,28,500,$black); ImageFilledRectangle($image,4,76,24,96,$white); ImageFilledRectangle($image,8,80,20,92,$black); ImageFilledRectangle($image,64,64,84,84,$black); ImageFilledRectangle($image,68,68,80,80,$white); ImageFilledRectangle($image,72,72,76,76,$black); ImageFilledRectangle($image,0,32,20,44,$black); ImageFilledRectangle($image,4,36,8,40,$white); ImageFilledRectangle($image,4,44,12,48,$black); ImageFilledRectangle($image,0,48,4,68,$black); ImageFilledRectangle($image,8,52,12,56,$black); ImageFilledRectangle($image,12,48,20,68,$black); ImageFilledRectangle($image,16,52,20,64,$white); ImageFilledRectangle($image,32,4,36,8,$black); ImageFilledRectangle($image,40,0,44,8,$black); ImageFilledRectangle($image,48,0,52,4,$black); ImageFilledRectangle($image,52,4,56,8,$black); ImageFilledRectangle($image,60,4,64,8,$black); ImageFilledRectangle($image,64,0,68,4,$black); ImageFilledRectangle($image,64,8,68,12,$black); ImageFilledRectangle($image,48,8,52,16,$black); ImageFilledRectangle($image,52,12,56,20,$black); ImageFilledRectangle($image,56,8,60,16,$black); ImageFilledRectangle($image,24,56,32,68,$black); ImageFilledRectangle($image,24,60,28,64,$white); ImageFilledRectangle($image,24,40,28,44,$black); ImageFilledRectangle($image,24,48,28,52,$black); ImageFilledRectangle($image,28,44,32,48,$black); ImageFilledRectangle($image,32,40,36,44,$black); ImageFilledRectangle($image,36,48,44,52,$black); ImageFilledRectangle($image,32,12,44,16,$black); ImageFilledRectangle($image,36,16,40,24,$black); ImageFilledRectangle($image,32,20,36,28,$black); ImageFilledRectangle($image,24,32,40,36,$black); ImageFilledRectangle($image,36,28,48,32,$black); ImageFilledRectangle($image,40,24,44,28,$black); ImageFilledRectangle($image,44,20,68,24,$black); ImageFilledRectangle($image,48,24,52,28,$black); ImageFilledRectangle($image,56,24,60,28,$black); ImageFilledRectangle($image,64,24,68,28,$black); ImageFilledRectangle($image,32,68,36,100,$black); ImageFilledRectangle($image,32,76,36,80,$white); ImageFilledRectangle($image,68,84,84,88,$black); ImageFilledRectangle($image,88,88,92,92,$black); ImageFilledRectangle($image,84,68,88,84,$black); ImageFilledRectangle($image,88,64,92,88,$black); ImageFilledRectangle($image,88,76,92,80,$white); ImageFilledRectangle($image,92,72,96,88,$black); ImageFilledRectangle($image,96,72,100,100,$black); ImageFilledRectangle($image,76,96,96,100,$black); ImageFilledRectangle($image,76,88,80,96,$black); ImageFilledRectangle($image,80,92,88,96,$black); ImageFilledRectangle($image,88,88,92,92,$black); ImageFilledRectangle($image,68,96,72,100,$black); ImageFilledRectangle($image,64,92,68,96,$black); ImageFilledRectangle($image,68,32,72,36,$black); ImageFilledRectangle($image,76,32,80,44,$black); ImageFilledRectangle($image,84,32,88,36,$black); ImageFilledRectangle($image,92,32,96,44,$black); ImageFilledRectangle($image,64,36,68,44,$black); ImageFilledRectangle($image,68,40,72,44,$black); ImageFilledRectangle($image,84,40,88,44,$black); ImageFilledRectangle($image,96,36,100,48,$black); ImageFilledRectangle($image,64,48,76,56,$black); ImageFilledRectangle($image,68,52,80,60,$black); ImageFilledRectangle($image,68,52,76,56,$white); ImageFilledRectangle($image,80,48,84,52,$black); ImageFilledRectangle($image,64,60,72,64,$black); ImageFilledRectangle($image,80,60,88,64,$black); ImageFilledRectangle($image,84,52,88,64,$black); ImageFilledRectangle($image,88,48,100,52,$black); ImageFilledRectangle($image,92,52,96,60,$black); ImageFilledRectangle($image,96,56,100,64,$black); ImageFilledRectangle($image,44,32,48,36,$black); ImageFilledRectangle($image,56,28,64,32,$black); ImageFilledRectangle($image,52,32,60,36,$black); ImageFilledRectangle($image,48,36,56,40,$black); ImageFilledRectangle($image,40,36,44,44,$black); ImageFilledRectangle($image,56,40,64,48,$black); ImageFilledRectangle($image,48,44,52,52,$black); ImageFilledRectangle($image,52,48,56,56,$black); ImageFilledRectangle($image,44,56,64,60,$black); ImageFilledRectangle($image,56,60,60,64,$black); ImageFilledRectangle($image,36,56,40,64,$black); ImageFilledRectangle($image,40,64,44,72,$black); ImageFilledRectangle($image,44,60,48,68,$black); ImageFilledRectangle($image,48,68,56,72,$black); ImageFilledRectangle($image,52,72,56,80,$black); ImageFilledRectangle($image,56,72,60,76,$black); ImageFilledRectangle($image,48,76,52,84,$black); ImageFilledRectangle($image,36,72,40,88,$black); ImageFilledRectangle($image,40,76,44,84,$black); ImageFilledRectangle($image,36,96,40,100,$black); ImageFilledRectangle($image,44,88,48,100,$black); ImageFilledRectangle($image,48,88,52,92,$black); ImageFilledRectangle($image,60,68,64,72,$black); ImageFilledRectangle($image,56,80,64,84,$black); ImageFilledRectangle($image,56,92,60,96,$black); // 形成图像 Imagepng($image); // 释放空间 ImageDestroy($image);?&gt; 结果（扫一扫啊，哈哈哈） 更新图图一12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?php // 一幅随机图 // 文件输出图片格式为png header(&quot;Content-type:image/png&quot;); // 建立一个画布 $image = ImageCreate(500,550); // 设定画布的北京颜色 $bgcolor = ImageColorAllocate($image,0,0,0); ImageFill($image,0,0,$bgcolor); // 画笔的颜色 $black = ImageColorAllocate($image,0,137,167); // 绘画过程 $x2 = 0; for($j = 0;$j &lt; 25; $j++)&#123; // 随机生成圆半径 $radius1 = rand(7,12); // 随机点生成一个实心圆 $x1 = rand(1,499); $y1 = rand(1,499); for($i = 1;$i &lt; $radius1;$i++)&#123; $w = $i; $h = $i; imagearc($image, $x1, $y1, $w, $h, 0, 360, $black); &#125; if($x2 !== 0)&#123; ImageLine($image,$x1,$y1,$x2,$y2,$black); &#125; // 随机生成圆半径 $radius2 = rand(7,12); // 随机再生成一点连接上一点 $x2 = rand(1,499); $y2 = rand(1,499); for($i = 1;$i &lt; $radius2;$i++)&#123; $w = $i; $h = $i; imagearc($image, $x2, $y2, $w, $h, 0, 360, $black); &#125; ImageLine($image,$x1,$y1,$x2,$y2,$black); &#125; // 打出名字 $string = &quot;x1067017 杨坤怡&quot;; ImageTTFtext($image,12,0,360,530,$black,&quot;c:/windows/fonts/FZPXJW.TTF&quot;,$string); // 形成图像 Imagepng($image); // 释放空间 ImageDestroy($image);?&gt; 图二1234567891011121314151617181920212223242526272829303132333435&lt;?php // 一幅随机图 // 文件输出图片格式为png header(&quot;Content-type:image/png&quot;); // 建立一个画布 $image = ImageCreate(400,420); // 设定画布的北京颜色 $bgcolor = ImageColorAllocate($image,55,60,56); ImageFill($image,0,0,$bgcolor); // 画笔的颜色 $black = ImageColorAllocate($image,0,137,108); // 绘画过程 // 随机生成空心三角形 $point=array(); for($j = 1;$j &lt; 10;$j++)&#123; for($i = 1;$i &lt; 4;$i++)&#123; $x = rand(1,399); $y = rand(1,399); array_push($point,$x,$y); &#125; ImagePolygon($image,$point,count($point)/2,$black); &#125; // 打出名字 $string = &quot;x1067017 杨坤怡&quot;; ImageTTFtext($image,12,0,250,410,$black,&quot;c:/windows/fonts/FZPXJW.TTF&quot;,$string); // 形成图像 Imagepng($image); // 释放空间 ImageDestroy($image);?&gt; 图三123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?php // 绘画一个A字母 // 文件输出图片格式为png header(&quot;Content-type:image/png&quot;); // 建立一个画布 $image = ImageCreate(400,400); // 设定画布的北京颜色 $bgcolor = ImageColorAllocate($image,0,0,0); ImageFill($image,0,0,$bgcolor); // 画笔的颜色 $black = ImageColorAllocate($image,241,124,103); // 绘画过程 // for($i = 1;$i &lt; 6;$i++)&#123; // $w = $i * 15; // $h = $i * 15; // imagearc($image, 250, 250, $w, $h, 0, 360, $black); // &#125; $start = 0; $stop = 120; for($i = 1;$i &lt; 13;$i++)&#123; $w = $i * 25; $h = $i * 25; imagearc($image, 200, 200, $w, $h, $start, $stop, $black); $start += 1*$i; $stop -= 1*$i; &#125; $start = 120; $stop = 240; for($i = 1;$i &lt; 13;$i++)&#123; $w = $i * 25; $h = $i * 25; imagearc($image, 200, 200, $w, $h, $start, $stop, $black); $start += 1*$i; $stop -= 1*$i; &#125; $start = 240; $stop = 360; for($i = 1;$i &lt; 13;$i++)&#123; $w = $i * 25; $h = $i * 25; imagearc($image, 200, 200, $w, $h, $start, $stop, $black); $start += 1*$i; $stop -= 1*$i; &#125; // 打出名字 $string = &quot;x1067017 杨坤怡&quot;; ImageTTFtext($image,12,0,250,370,$black,&quot;c:/windows/fonts/FZPXJW.TTF&quot;,$string); // 形成图像 Imagepng($image); // 释放空间 ImageDestroy($image);?&gt;","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yangkunyi.com/tags/笔记/"},{"name":"PHP","slug":"PHP","permalink":"http://yangkunyi.com/tags/PHP/"}]},{"title":"WeeklyMind-5","date":"2017-12-24T04:23:09.000Z","path":"2017/12/24/WeeklyMind-5/","text":"本周开始学习都开始进入最后的报告和复习阶段，不动产报告， 人际关系报告，以及接下来的行销报告和各种总结，然后是期末考试复习，所以这两个周不太有时间自学了。 学习 不动产管理小组报告：可能因为对这边的一些名词不太熟悉，所以报告的时候自己有一点说不清楚，不知道该如何表达自己的想法；不过也是没有准备充分的表现。 人际关系小组报告：我们小组的主题是社交软件对大学生人际关系的影响，自己准备的ying影响的好坏部分，这次就好很多了，自己有事先练习自己不熟悉的稿子，报告的时候就能很顺利的讲下来。 行销管理小组讨论：这样的小组讨论是很重要的我觉得，以后作为一个想要在互联网公司工作的人，这种小组讨论的能力是必须具备的，而自己在讨论中的表现还算行，队友们也很给力，最后分工也很快敲定下来，希望最后的小组报告也能一切顺利。 财务管理和西方哲学史也都剩下最后一节课了，所以要抓紧时间复习了啊！ 生活 本周的天气都不错，前两天很冷，后面都有着充足的阳光。 周四人际关系报告完回寝室的路上，在马路中间和它相遇了，它就好像在那里等我一样，我当时还在看手机，却不经意的一个转头，看见它就那样安静的躺在马路上，心里当时唯一的想法就是不要让来往的车辆压着它了，于是把它带了回来。 今天是平安夜，明天是圣诞节，作为一个不怎么过圣诞节的我来说，吃一个苹果就足够了，还有就是今晚和室友约着去吃火（tang）锅，这可能是自己在这边的最后一顿火锅了吧！ 周五去看了旁边的交大，只是去吃了有名的松饼，所以也没有来得及细看整个学校，唯一的感觉就是看到的建筑都很有设计感。 待更新事项 不动产管理上节课的评价和学期总结 关于台湾的三千字 复习","tags":[{"name":"-周记","slug":"周记","permalink":"http://yangkunyi.com/tags/周记/"}]},{"title":"WeeklyMind-4","date":"2017-12-17T04:52:37.000Z","path":"2017/12/17/WeeklyMind-4/","text":"这个周开始都开始准备各科的报告和总结了，所以不是在写报告就是在做ppt，周五下午有抽空学习node，看了N-blog项目的大概，但是困难出在MongoDB，虽然连上了，项目跑起来了，但是并没有懂其中的原理，之后会继续理解。 学习 web学了PHP的绘画，还画了一个二维码。 不动产管理报告 人际关系报告 完成了毛概 不定期更新微信 生活 进入自己想要的规律状态，但是每天运动量还是太少了，可能是气温太低了，自己也没有想出门。 今天晚上准备去买水果，维生素还是不能少 真的不是很喜欢这边的食物，吃的不是很开心，开始想奶奶做得菜了 昨晚和一个同龄的妹子聊到了父母的期望和自己想做的有偏差，自己将自己想做的都告诉了她，那是因为自己也想像自己所说的那么坚持，坚持做自己想做的事情，父母的期望并不想辜负，尽自己最大的努力去达到他们想看到的样子，但是这并不意味着我不能做自己，这并不是矛盾的关系，很多情况下自己的想法和父母的想法是可以共存的。父母希望自己把心思放在学习上，只不过想自己的成绩能够过得去，那自己在保证了成绩的前提下做的事情父母也会接受的，获许还更可能得到支持。所以我觉得不能把自己的想法和父母的想法完全对立起来吧，换一种看法，就像前面所说的，是可以共存的。 待更进事项 西方哲学整理复习 财务管理复习（考课后题，我就把课后题全做一遍总可以了吧！死记硬背我都给你过了。。。） 行销管理报告，视频，ppt 继续学习英语 已经开始倒数着回去的日子了，是真的想家了吧！","tags":[{"name":"周记","slug":"周记","permalink":"http://yangkunyi.com/tags/周记/"}]},{"title":"NeverLimitYourself","date":"2017-12-14T13:01:57.000Z","path":"2017/12/14/NeverLimitYourself/","text":"看完C菌的视频有感而发，想说一些话！ 自己正是出于这样的原因选择来到台湾交流学习，我想看看那远离我的生活的地方有什么不一样，那里的生活是怎么样的？那里的人是怎么样的？那里的猫也是那么懒吗？… 于是九月四日踏上里人生的第一次飞机之旅，短短三个小时，来到了这个离家一千多千米的岛上。一切都是那么好奇，现在的我已经在这里快四个月了，学习生活也都很顺手了，该体验的自己也都体验到了，再也不会像刚来的前几周那样充满不安的焦虑，或许这就是成长吧。 在申请这个交换机会的时候，自己曾给自己找各种理由，但最后还是只能说：我就是想看看。 自己在最开始的时候焦虑一个是因为陌生环境的压力；另一个原因是自己看到了自己相看的东西之后，心里突然之间有一瞬间感觉空空的，不知道自己之后该做什么了，整个人好像在这里生活着没什么意思了，同时本校也开学了，看着同学们开学的动态，那种叫做孤独的东西一下子就从心里冒了出来。可是别人还在“羡慕”的“恭维”和祝贺自己来到这里，所以自己还要打起精神来应付，为了来这里之前说下的那句：“我想去看看！”没错，那个时候每天都很丧，过得很混沌。 那个时候只有父母算生活动力，想着他们为了让自己出来看看所做的努力，自己真的没理由就这样混沌的过，但同时这种压抑的感觉又让自己整个人感觉很紧绷，所以也是压力吧。自己没有自觉与他们联系的习惯，在本校的时候一个月也是要回家的时候才会联系一下，所以根本不知道平时有什么好跟他们说的。不过为了让他们不担心自己的生活和学习，自己还是学会了每隔两天报告一下平安，是真的只有一个“报”字的报平安。不过母上大人还是想自己的，偶尔会在晚上和自己视频一下，说一下家里的情况，自己也会简单的报告一下自己的近况，虽然自己初中以来就是住校，但这次毕竟隔得比较远，所以其实真的是有些想他们了。 然后终于那句：“意义这种事情只有在做过之后才知道，之前说的意义都是肤浅的认知罢了！”解决了让自己失眠一个周的问题，终于将急躁的心放到了肚子里，开始慢慢享受每一天的生活，早起，看书，上课，写作业，跑步…终于生活算是步入了正轨。 正式抱着这样的心态，中间出去短途旅行了三次，那才叫真的看到了自己看到的，由于马上要期末考试了，所以之后应该不会再出去了。不过这三次的记忆就足以抵上前三个月的努力了，接下来就好好准备课程相关报告和考试吧。 经过这四个月的生活后，那种不知名意义好像快要浮出水面的时候，看到了C菌的Nerver Limit Yourself，自己终于找到了可以表达自己心情的句子： Never limit yourself because of others’ limited imagination; never limit others because of your own limited imagination.— MAE JEMISON ps:如果想了解本人在台湾的更多近况，可以扫描下面的公众号二维码。（可能这就是广告吧。）","tags":[{"name":"日常","slug":"日常","permalink":"http://yangkunyi.com/tags/日常/"},{"name":"随笔记","slug":"随笔记","permalink":"http://yangkunyi.com/tags/随笔记/"},{"name":"观后感","slug":"观后感","permalink":"http://yangkunyi.com/tags/观后感/"}]},{"title":"WeeklyMind-3","date":"2017-12-10T09:30:09.000Z","path":"2017/12/10/WeeklyMind-3/","text":"本周很日常，只是感觉自己有点缺乏锻炼，所以显得不是特别的精神，可能也和天气有关系，开始凉了，自己也没带什么厚衣服，所以没课都不怎么出门的那种。 学习 各科课程进行正常 但并没有完成本校作业 完成了第一次不动产小组报告，虽然内容很尬，但是表现自己还算满意 关于人际关系的人际圈，自己在课堂上画出不同的圈也让自己十分的意外，但这也是自己本身的看法罢了，或许这才是最真实的自己 让自己丧了一天的财务管理期中成绩也是真的令自己心碎啊 了解了一些数据库的知识，应该叫复习了，毕竟之前还是多少学了一点 node要努力了，时间的零碎学起来也是很零碎 生活 这一周缺乏锻炼，怎么感觉又长胖了。。。 稍微一点混沌，可能躺太多 手臂在乒乓球课崴了，一直一点酸疼 吃饭特别不规律！！！这一点下个周一定得改了 对了，微信终于开始了，不过进度貌似不能保证每天，所以自己准备改一下，暂时上学期间频率保持一周两篇吧，如果空闲的周可以多做一点 待更进事项 通信作业的问题回答 还是抽时间把毛概的论文写了吧，毕竟回去可能还真的可以考试呢 node php继续学习","tags":[{"name":"周记","slug":"周记","permalink":"http://yangkunyi.com/tags/周记/"}]},{"title":"用户验证与数据库","date":"2017-12-06T12:22:28.000Z","path":"2017/12/06/用户验证与数据库/","text":"这是今天web课程的笔记，亲自尝试了前面两种验证方式，第三种方式之前也有所接触，还都算比较好理解。后面还有一些数据库的简单解释。 验证用户方法1. HTTP自带的验证 这种方式是利用HTTP所提供的验证头信息来对用户进行身份验证。由于这种凡是对大量的使用者缺乏有效的管理，在用户太多时并没有太大用处，因此少量用户时使用。例如开发人员。 123456789101112131415161718192021222324&lt;?php // 如果 $PHP_AUTH_USER 不等于 &quot;tea&quot;，就进不去网站。 if($_SERVER[&apos;PHP_AUTH_USER&apos;] !=&apos;tea&apos; || $_SERVER[&apos;PHP_AUTH_PW&apos;] !=&apos;ok&apos;)&#123; //通过头部信息告知浏览器验证 header(&apos;WWW-Authenticate: Basic realm=&quot;「需验证」---请输入账户/密码&quot;&apos;); header(&apos;HTTP/1.0 401 Unauthorized&apos;); echo &quot;账号或密码错误。请刷新重新输入。&quot;; //记得要加上 exit() 离开，不然就跟没有验证一样了！ exit(); &#125; /* 如果用户输入正确的账户和密码，下面的 HTML 就会显示 */ ?&gt; &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;&lt;/TlTLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;P&gt;Hello World！&lt;/P&gt; &lt;/BODY&gt; &lt;/HTML&gt; 2. htaccess方式的验证 这种凡是其实时Apche所提供的加强版HTTP验证方式，利用Apche所提供的htpasswd来设定使用者账号和密码。但是任然不适用过多用户。 首先建立用户数据（授权的动作）12345678910111213// 第一次 -c，第二次添加就不需要了c:\\appserv\\apache\\bin&gt; htpasswd -c htusers Tom New password: ←输入用户密码 Re-type new password: ←再次输入 Adding password for user Tomc:\\appserv\\apache\\bin&gt; htpasswd htusers Jack New password: Re-type new password: Adding password for user Jack// 可以将不同的人进行分组，group是群组名称group:Tom Jack 然后在需要权限才可以进入的路径中建.htaccess文档（将已授权和访问地址联系到一起）12345678910111213141516// 显示给用户看的提示AuthName &quot;登陆时需要输入账号和密码「账号」与「密码」&quot; // 验证时不编码AuthType Basic // 之前建立的用户数据AuthUserFile c:\\appserv\\apache\\bin\\htusers #AuthGroupFile c:\\appserv\\apache\\bin\\htgroup // 所有访问的都需要验证require valid-user #require user jollen #require group ieem316 // 定义说拒绝所有，允许个别order deny,allow deny from all #allow from .nthu.edu.tw allow from 140.114.70.31 3. 数据库存储用户数据 最有效，最普遍的做法，将用户的账户和密码存在数据库中，每次登陆到数据库中查找数据，最后返回有无和正确性。 准备工作 登陆的表单 登陆的程序 建好用户的资料库，至少要包括账号和密码 步骤 通过表单获取用户账号与密码 到数据库中查找对应的账号和密码 失败就返回重新获取信息，直到成功为止 1234567891011121314151617181920212223242526// 本程序通过头信息获取的用户的账户和密码&lt;?php // 如果用户沒有输入账户，要求用户重新验证。 IF(!isset($PHP_AUTH_USER))&#123; header(&apos;WWW-Authenticate: Basic realm=&quot;请输入账号和密码&quot;&apos;); header(&apos;HTTP/1.0 401 Unauthorized&apos;); echo &quot;刷新后重新登陆&quot;; exit(); &#125; else&#123; mysql_connect(&quot;localhost&quot;,&quot;admin&quot;,&quot;asdee4&quot;) or die (&quot;无法连接 MySQL&quot;); rnysql_select_db(&quot;members&quot;) or die(&quot;无法连接数据库&quot;); $query=&quot;select id from users where username=&apos;$PHP_AUTH_USER&apos; and password=&apos;$PHP_AUTH_PW&apos;&quot;; $result=mysql_query($query); $n_rows=mysql_num_rows($result); mysql_close(); // 当row&lt;1时，用户账号与密码有错，重新登陆 if($n_rows &lt; 1)&#123; header(&apos;WWW_Authenticate: Basic realm=&quot;请输入账号和密码&quot;&apos;); header(&apos;HTTP/1.0 401 Unauthorized&apos;); echo &quot;刷新重新登陆&quot;; exit(); &#125; &#125; ?&gt; 数据库数据库系统 = 数据库管理系统 + 数据库DBMS（数据库管理系统）：database management system 只是一个软件 作用：资料的管理和维护 DB（数据库）：databaseSQL（structure query language）：结构化查询语句 第一代：89 第二代：92（绝大部分数据库所遵循的规则） 第三代：99（没有成立） DDL（data definition language）：数据库和数据表定义语言 create database table drop database table alter（改变数据库的结构） table DML（data manipulation language）：数据处理语言 select（查询） insert [into]（添加） delete（删除） updata（单个属性的改变） DCL（data control language）：数据库控制语言 grant（授权） revoke（取消授权） 使用者 DBO（database operater） DBA（database administrator）：root/password 简单的结构DB Server（数据库服务器） DB（数据库） table（数据表） record（） field charset 流程 链接数据库 use/create：database create：table/改变资料表里面的数据 数据库操作方法 通过程式（php） 通过命令行 -u：使用者 -h：主机 -p：密码 通过图形界面（软件） PHP &amp; 数据库1. 连接数据库12$db = mysql_connect（数据库主机名称或ip,数据库账号,数据库密码）; or die(&quot;无法连接数据库服务器&quot;); 2. 使用数据库12mysql_ select_db(名称,$db); or die(&quot;无法连接数据库&quot;); 3. 对数据进行操作1$sql = &quot;(此处就是SQL指令)&quot;; 4. 用变量对数据进行存取1$result = mysql_query($sql,$db); 5. 最后关闭数据库 当取到数据的时候就可以关掉了，这样可以降低数据库风险。 1mysql_close($db); 注 sql指令可以大小写，但各种数据库名称和数据表名称要区别大小写。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yangkunyi.com/tags/笔记/"},{"name":"PHP","slug":"PHP","permalink":"http://yangkunyi.com/tags/PHP/"},{"name":"验证","slug":"验证","permalink":"http://yangkunyi.com/tags/验证/"},{"name":"数据库","slug":"数据库","permalink":"http://yangkunyi.com/tags/数据库/"}]},{"title":"坎帕斯学院讨论日常-2","date":"2017-12-03T13:23:28.000Z","path":"2017/12/03/坎帕斯学院日常讨论-2/","text":"这是第二次整理讨论的内容，本次内容有点深奥，值得细嚼慢咽。 名词解释 高并发(High Concurrency) 指通过设计保证系统能够同时并行处理很多请求。 是互联网分布式系统架构设计中必须考虑的因素之一。 高性能(High performance) 目前理解就是提高浏览网页的速度。 高可用(High Availability) 通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。 高扩展性(High Extensibility) 通常和可伸缩性混为一谈.在软件范畴上，是软件系统本身的属性，或者进一步说是设计的属性，代码的属性。 高可维护性(High Maintainability) 是衡量一个系统的可修复(恢复)性和可改进性的难易程度。 接口的高可用性 保证这个接口在任何情况下都可以正确的取到数据。 方案一：每次访问的时候将a接口的数据存在本地，第二次访问的时候接口如果gg了，可以直接在本地获取数据，然后渲染出来；（前提是访问过a接口） 方案二：推oss或者cdn；每次访问了一个接口，然后服务器把返回的数据生成文件推送到一个静态资源服务器上去； 好处：比如某人访问了接口，静态资源服务器就会缓存a里面的数据，这时候gg了，其他人依然可以请求到oss上的数据；（逻辑是前端做到的，但是数据推到oss上是从后台推上去的） oss几乎不可能gg，原因是它只是一个静态资源存储的地方； 默认数据：（假数据）当接口不可用的时候，用这个自己做的数据； 目前企业的解决方案是：先走服务器接口，若是gg了；再访问本地缓存；若没有，则访问oss。 本地缓存 优点： 如果第一次没有访问对应的接口就没有本地缓存； 数据的时效性不够； 缺点： 快，不用通过网络请求； 缓存地点 缓存类型： sessionStorage：只在当次回话有效，不会带到每一个请求里面去； indexDB：浏览器支持度很低，也就是说兼容问题很大； cookie：过期时间可以设置，默认是浏览器当期回话结束失效；cookie很小；每次对应域名是会在每个请求头带过去，浪费资源，所以限制了大小，如果不限制，就会跟上传文件没有区别了，会导致特别慢；对于数据接口，我们不能保证内容有多大，而且每个接口数据都要缓存，所以不能用cookie。 localstorage：没有大小限制； 以上都属于这两种类型： （私有）浏览器缓存：单个用户，你浏览过的页面浏览器缓存起来。 （共享）代理缓存：多个用户，所在公司自己架构的，减少网络拥堵与延迟。 浏览器缓存机制浏览器请求一个资源，是怎么判断取缓存还是找服务器下载？ 状态码304是怎么产生的？ 是因为本地文件设置的信息头部过期了，去服务器拉取，然后服务器告诉我，其实你的文件还尚未过期，让你回自己本地取资源； 状态码200（from cache）是怎么产生的？ 一定是通过了请求并且成功然后返回的状态码，方式get或者post。 以上的问题只是有所了解了，但是关于浏览器的缓存机制还没有系统的了解，自己在看官方文档的时候，感觉有点困惑，所以先在这里埋个种子。","tags":[{"name":"前端","slug":"前端","permalink":"http://yangkunyi.com/tags/前端/"},{"name":"问题","slug":"问题","permalink":"http://yangkunyi.com/tags/问题/"},{"name":"讨论","slug":"讨论","permalink":"http://yangkunyi.com/tags/讨论/"},{"name":"浏览器缓存","slug":"浏览器缓存","permalink":"http://yangkunyi.com/tags/浏览器缓存/"},{"name":"状态码","slug":"状态码","permalink":"http://yangkunyi.com/tags/状态码/"}]},{"title":"WeeklyMind-2","date":"2017-12-02T04:29:09.000Z","path":"2017/12/02/WeeklyMind-2/","text":"忙碌的一周，这都是浪三天的后遗症。上周的周记都在浪中忘记了，但是心情还是很开心的。 总结上两周学习 期中考试和报告全部完成，成绩一般，接下来又要开始准备期末考试了，来台湾三个月了，自己也在想这一趟来的值不值。 课程： 突然对不动产的作业很是上心，希望在同学和老师们面前不丢咱大陆学生的脸 为了行销管理的期中报告，自己也算是呕心沥血了，希望不要太差 西方哲学到康德部分，开始有点抽象到不懂了，还是知识面太狭窄了 财务管理课程让自己彻底对经融课程失望了，自己是真的不适合学习，修这门课都当作了解吧 突然觉得人际交往是一门很重要的课程，既认识了自己，也认识了别人 这两个周因为中间的各种考试和报告，时间有点混乱，所以接下来应该好好计划 其它 http缓存机制的了解，周末希望能理解完 继续学习了php 了解php架构包中如何建wordpress以及评论板块（但是发现自己对数据库的认识还不够，导致在尝试过程中老是出现问题） 生活 上个周末算是很精彩了，一趟三天两夜的旅行回来，也导致了博客的的各种托更。 台南： 赤崁楼 安平古堡 安平树屋 安平老街 高雄 夜市 爱河 真爱码头 西子湾 中山大学 也算是见过真正的浪了！ 待更进事项 12月计划 微信订阅号 各种作业 前端书籍（每天给点时间来做，积累最重要） 今年的最后一个月，完成你年初的计划可好，少年！","tags":[{"name":"周记","slug":"周记","permalink":"http://yangkunyi.com/tags/周记/"}]},{"title":"WeeklyMind-1","date":"2017-11-19T06:11:30.000Z","path":"2017/11/19/WeeklyMind-1/","text":"寻常的一周，不过做了许多的决定，之后每一周也希望自己能坚持做一下简单的总结。 总结上周生活 新买的T恤很喜欢 吃得很随便，但不失营养，老年人一样的生活，哈哈哈 住的寝室，还是比较宅，之后希望有时间，还是多出去走走看看 这周没怎么出门，最近在准备各种考试和期中报告 学习 课程： 人际考试 周三运动会放假 复习财管 其它课程一切照常进行 完成日常作业 其它 申请和绑定了域名 博客主题修改 了解nodeppt 简单的看了一下网易云api（有准备做一个音乐播放器） 待更进事项 复习财管（周三考试） 电商案例分析 人际期中报告 不动产课堂报告 课程小节论文 通信英语ppt 继续学习php 更新博客 日常作业 最后还有锻炼，这个事情还是比较重要的。按照自己的计划腾出锻炼的时间，保持健康，毕竟在这个遥远的地方没有买保险。。。","tags":[{"name":"周记","slug":"周记","permalink":"http://yangkunyi.com/tags/周记/"}]},{"title":"PHP学习笔记","date":"2017-11-17T09:55:52.000Z","path":"2017/11/17/PHP学习笔记/","text":"本文是一些PHP的基础知识，自己看书的时候做的一些笔记。 PHP变量 PHP 语句和 PHP 变量都是区分大小写的。 PHP 没有声明变量的命令。 PHP 是一门弱类型语言 不必向 PHP 声明该变量的数据类型。 PHP会根据变量的值，自动把变量转换为正确的数据类型。 在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称。 作用域局部变量和全局变量 global可以将局部变量提升为全局变量。 PHP将所有全局变量存储在一个名为$GLOBALS[index]的数组中。index保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。 Static作用域 当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除。要做到这一点，请在您第一次声明变量时使用 static 关键字。 参数作用域：属于函数的局部变量。 php中常见的输出语句 echo(): 可以一次输出多个值，多个值之间用逗号分隔。echo是语言结构(language construct)，而并不是真正的函数，因此不能作为表达式的一部分使用。 print(): 函数print()打印一个值（它的参数），如果字符串成功显示则返回true，否则返回false。 print_r(): 可以把字符串和数字简单地打印出来，而数组则以括起来的键和值得列表形式显示，并以Array开头。但print_r()输出布尔值和NULL的结果没有意义，因为都是打印”\\n”。因此用var_dump()函数更适合调试。 var_dump(): 判断一个变量的类型与长度,并输出变量的数值,如果变量有值输的是变量的值并回返数据类型。此函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。 数据类型字符串（String） 双引号串中的内容可以被解释而且替换，而单引号串中的内容总被认为是普通字符。 在单引号串中甚至反斜杠也失去了他的扩展含义（除了插入反斜杠\\和插入单引号\\’）。 所以，当你想在字串中进行变量代换和包含\\n（换行符）等转义序列时，你应该使用双引号。单引号串可以用在其他任何地方，脚本中使用单引号串处理速度会更快些。 整型（Integer） 整数是一个没有小数的数字。 浮点型（Float）-浮点数是带小数部分的数字，或是指数形式。 布尔型（Boolean）数组（Array）对象（Object） 类似于java的类 123456789101112&lt;?php class Car &#123; var $color; function Car($color=&quot;green&quot;) &#123; $this-&gt;color = $color; &#125; function what_color() &#123; return $this-&gt;color; &#125; &#125;?&gt; NULL值 NULL值表示变量没有值。NULL是数据类型为NULL的值。 NULL值指明一个变量是否为空值。同样可用于数据空值和NULL值的区别。 可以通过设置变量值为 NULL 来清空变量数据 字符串函数 strlen(string)函数：返回字符串长度 strpos(seacher,char)函数：查找一个字符串在另一个字符串中第一次出现的位置 数组排序 sort() - 对数组进行升序排列 rsort() - 对数组进行降序排列 asort() - 根据关联数组的值，对数组进行升序排列 ksort() - 根据关联数组的键，对数组进行升序排列 arsort() - 根据关联数组的值，对数组进行降序排列 krsort() - 根据关联数组的键，对数组进行降序排列 PHP 超级全局变量 $GLOBALS：是一个包含了全部变量的全局组合数组。变量的名字就是数组的键。 $_SERVER：是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。 $_REQUEST：用于收集HTML表单提交的数据。 $_POST：被广泛应用于收集表单数据，在HTMLform标签的指定该属性：&quot;method=&quot;post&quot;。 从带有 POST 方法的表单发送的信息，对任何人都是不可见的（不会显示在浏览器的地址栏） 并且对发送信息的量也没有限制。 $_GET：同样被广泛应用于收集表单数据，在HTMLform标签的指定该属性：&quot;method=&quot;get&quot;。$_GET也可以收集URL中发送的数据。 从带有 GET 方法的表单发送的信息，对任何人都是可见的（会显示在浏览器的地址栏） 并且对发送信息的量也有限制。 $_FILES $_ENV $_COOKIE $_SESSION PHP魔术变量 __LINE__：文件中的当前行号。 __FILE__：文件的完整路径和文件名。 __DIR__：文件所在的目录。 __FUNCTION__：函数名称。 __CLASS__：类的名称。 __TRAIT__：trait的名称。 __METHOD__：类方法的名称。 __NAMESPACE__：命名空间的名称。 XSS又叫 CSS (Cross-Site Script) 跨站脚本攻击。恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。 正则 邮箱：/([\\w\\-]+\\@[\\w\\-]+\\.[\\w\\-]+)/ URL：/\\b(?:(?:https?|ftp):\\/\\/|www\\.)[-a-z0-9+&amp;@#\\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\\/%=~_|]/i 只有字母和空格：/^[a-zA-Z ]*$/ Get 与 Post何时用method=”get”？ 在 HTML 表单中使用 method=”get” 时，所有的变量名和值都会显示在 URL 中。 注释：所以在发送密码或其他敏感信息时，不应该使用这个方法！ 然而，正因为变量显示在URL中，因此可以在收藏夹中收藏该页面。在某些情况下，这是很有用的。 注释：HTTP GET 方法不适合大型的变量值。它的值是不能超过 2000 个字符的。 何时用method=”post”？ 从带有 POST 方法的表单发送的信息，对任何人都是不可见的，并且对发送信息的量也没有限制。 然而，由于变量不显示在 URL 中，所以无法把页面加入书签。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yangkunyi.com/tags/笔记/"},{"name":"PHP","slug":"PHP","permalink":"http://yangkunyi.com/tags/PHP/"}]},{"title":"JavaScript调试","date":"2017-11-16T10:38:42.000Z","path":"2017/11/16/JavaScript调试/","text":"本文就想总结一些调试的方法，其实调试是提高效率的重要方法之一，会用正确高效的调试方法，可以事半功倍。 1、最常用console.log（简单数据输出） 这就没有什么好解释的，不过输出也是有技巧的，那就是要格式化，简单说就是要有标志性，只有数据或许会让人不理解，最好是加上前缀 123// exampleconsole.log(&quot;fun&apos;s result---&quot; + fun(2));console.log(&quot;value of a---&quot; + a); 当然可以改变颜色和字体等 2、debugger：断点 与console.log相比，debugger会在执行的过程中停在你想的地方，能够更加直接的看到执行过程。 3、将对象以表格的形式展示console.table() 将对象强制用表格打出来，这样展开的对象键值对应更加清晰 注意firefox有限制，最多显示1000行 4、尝试适配各种机型屏幕大小 这个对开发手机页面很有帮助 其次是可以检查布局问题 5、如何快速找到对应的DOM元素 方法1浏览器的快速选择工具 方法2是通过参数访问，浏览器有将DOM元素进行编号，可以通过$x的方式去访问。（具体后续补充） 6、使用console.time()和console.timeEnd()来记录时间 关注函数运行的时间是提高效率的方法之一 获取某个函数的Stacktrace console.trace() 向Web控制台输出一个堆栈跟踪 将minify的代码还原 {} 快速定位需要debug的函数 debug(funName) 会在执行函数的地方停下来 屏蔽不相关的脚本 注释掉 查看某个函数调用和其参数 monitor(funName) Postman很好用，不过传说Firefox更快 但由于本人喜欢用chrome，所以没有用尝试firefox","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yangkunyi.com/tags/Javascript/"}]},{"title":"域名的购买和绑定","date":"2017-11-15T09:42:30.000Z","path":"2017/11/15/域名的购买和绑定/","text":"终于下定决心，自己在阿里云上购买了域名，开始将自己的博客放到一个更大的“池塘”里面了，之后的学习，希望自己能继续坚持。 购买域名 前期翻看了很多关于在哪里购买域名的博文，最后还是决定就在阿里云买了，原因如下：（其实很早就想买了，但是之前还是觉得自己技术不成熟吧，买了也是浪费，不过现在觉得，买了就有更大的动力学习了） 为了让自己的博客更有识别度 作为一个新手，阿里云的性能已经很够用了 价格一般，作为大学生，还是能负担 阿里云在国内也算有名了吧 购买方法很简单啊，只要去官网就好了阿里云 域名绑定 之前自己的博客是挂在github上面直接用的免费的github pages，为了更有识别度，便买了域名，因为还没有购买服务器，（准备在接下来一年内完成这任务）所以之后项目还是会放在github上。 因此这样的话，绑定域名就很简单了。 域名的解析，在阿里云的后台管理进行如下设置 然后是github项目的重定向 用过github pages的都知道，github赠送的域名是yourgithubname.github.io，而我们现在要做的就是将这个页面重定向到我们申请的域名上去 方法如下： 方法1. 直接更改项目设置中的pages设置，如图： 方法2.在项目的根目录中新建一个CNAME文件，文件的内容就是我们申请的域名： 最后就是等待了（时间长短不定，本人感觉并没有等很久），就可以通过我们自己申请的域名访问项目页面了。","tags":[{"name":"域名","slug":"域名","permalink":"http://yangkunyi.com/tags/域名/"}]},{"title":"学习PHP之环境搭建","date":"2017-09-30T04:02:08.000Z","path":"2017/09/30/学习PHP之环境搭建/","text":"注：因为搭建的是本地的服务器，所以只有自己的电脑开着的时候，才能访问到。 一、注册域名 这是一个免费域名的注册地址www.noip.com，这种网站有很多，只是本人用的这一个，可自由选择。 注册登录即可。（一个简单的域名注册申请，就不再赘述了） 根据自己的ip注册后的结果是这样（要特别注意的是ip地址的填写，不知道自己此刻的ip地址可以用命令行查询；此处的ip地址会根据你使用的网络而改变）： 二、架构包的安装 下载架构包（架构包当然也有很多种，本人使用的是链接中的这个）AppSever8.6.0 安装架构包（跟着流程走就好了，规则就是两个键按左边，三个键按中间，一个键就只能按它咯~）注意安装目录的选择！安装完之后，会有一个这样的目录： 测试：在浏览器地址栏中输入你之前申请的并且与ip地址对应的域名，当看到以下结果，说明你ok了，否则请从头开始=_=（嘿嘿，有问题肯定是某个步骤出了问题，仔细检查）： 此处显示的是，文件夹www中的index.php文件 当然我们希望这些关于服务器的各种信息只有我们自己能看到，而别人看不到，很简单，将文档的名字改成只有你自己知道就好了: 既然index文件已经被我们改掉了，因此可以开始写第一个index文件了，此刻网页会自动显示该文件（之后就可以开始写自己的网页了）： 123456789101112// index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p style=&quot;font-size: 50px;color: #66ccff;&quot;&gt;啦啦啦&lt;/p&gt; &lt;p style=&quot;font-size: 40px;color: red&quot;&gt;完了&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"PHP","slug":"PHP","permalink":"http://yangkunyi.com/tags/PHP/"},{"name":"学习","slug":"学习","permalink":"http://yangkunyi.com/tags/学习/"}]},{"title":"画地为牢","date":"2017-08-04T01:16:39.000Z","path":"2017/08/04/画地为牢/","text":"它是一套规则，这套规则用来管理引擎如何在当前作用域及嵌套的子作用域中根据标识符名称进行变量的查找。 1234if(true) &#123; var num = 10;&#125;console.log(num); 思考：JavaScirpt怎样才会形成作用域？ 函数作用域 就是说，在JavaScript中，在函数里面定义的变量，可以在函数里面被访问，但是在函数外无法访问。 1234var func = function() &#123; var num = 10;&#125;;console.log(num); 1234var func = function() &#123; var num = 10; console.log(num);&#125;; 前面说了，函数可以限定变量的作用域，那么在函数中的函数就成为该作用域的子域。在子域中的代码可以访问到父域中的变量。 12345678var func = function() &#123; var num = 10; var sub_func = function() &#123; console.log(num); &#125;; sub_func();&#125;;func(); 123456789var func = function() &#123; var num = 10; var sub_func = function() &#123; var num = 20; console.log(num); &#125;; sub_func();&#125;;func(); 由此可见访问有一定规则可言。在JavaScript中使用变量，JavaScript解释器首先在当前作用域中搜索是否有该变量的定义，如果有，就是用这个变量；如果没有就到父域中寻找该变量。以此类推，直到最顶级作用域，仍然没有找到就抛出异常”变量未定义”。 123456789(function() &#123; var num = 10; (function() &#123; var num = 20; (function()&#123; console.log(num); &#125;)() &#125;)();&#125;)(); 块级作用域 思考：什么叫块级作用域？ 123456789function outputNumbers(count)&#123; for (var i=0;i&lt;count;i++)&#123; console.log(i); &#125; console.log(i) var i; console.log(i);&#125;outputNumbers(3); 很遗憾，在es6之前，javascript是没有块级作用域的。所以也会因此造成对一些变量值的忽视，从而引起程序运行结果不对。那前辈们遇到这个问题是怎么做的呢？让我们来考考古。 利用函数来实现块级作用域 因为函数是js里唯一具有块级作用域特点的。 123456789function outputNumbers(count)&#123; (function()&#123; for (var i=0;i&lt;count;i++)&#123; console.log(i); &#125; &#125;)(); console.log(i);&#125;outputNumbers(3); 思考：这是不是一个闭包？ 方法类（不建议使用）with 用with从对象创建出的作用域仅在with声明中而非外部作用域中有效。1234567891011121314151617function foo(obj) &#123; with (obj) &#123; var a = 2; &#125;&#125;var o1 = &#123; a: 3&#125;;var o2 = &#123; b: 3&#125;;foo( o1 );console.log( o1.a );foo( o2 );console.log( o2.a );console.log( a ); try/catch1234567try&#123; undefined();//执行一个非法操作来强制制造一个异常&#125;catch(err)&#123; console.log(err)//能够正常执行&#125;console.log(err); ES6中的块级作用域 将代码在函数中隐藏的信息扩展为在块中隐藏起来。 let(不能重复声明) let关键字可以将变量绑定到所在的任意作用域中。 垃圾回收 12345678function process(data)&#123; //在这里做点有趣的事情&#125;&#123;//在这个块中定义的内容完事可以销毁 let someReallyBigData=&#123;...&#125;; process(someReallyBigData);&#125; let循环 1234for(let i=0;i&lt;10;i++)&#123; console.log(i);&#125;console.log(i); const（不能重复声明） 定义一个该块的常量，不能修改值。 12345678910var foo = true;if (foo) &#123; var a = 2; const b = 3; a = 3; b = 4;&#125;console.log(a);console.log(b); 作用域链 因为作用域是一套用于确定在何处以及如何查找变量的规则，我对作用域链的理解就是查找变量所走的路。 建筑 根据这个图来理解，就是查找变量所爬的楼。 树 爬楼太累了，我们再看看用画树的方法再来看看。 绘制规则 作用域链就是对象的数组 全局作用域是0级链，每个对象占一个位置 凡是看到函数延伸一个链出来，一级级展开 访问首先看当前函数，如果没有定义往上一级链检查 如此往复，直到0级链 123456789101112131415161718var num = 10;var func1 = function() &#123; var num = 20; var func2 = function() &#123; var num = 30; console.log(num); &#125;; func2();&#125;;var func2 = function() &#123; var num = 20; var func3 = function() &#123; console.log(num); &#125;; func3();&#125;;func1();func2(); 现场绘制一波 预解析 形成变量提升现象1234567var num = 10;var func = function() &#123; console.log(num); var num = 20; console.log(num);&#125;;func(); 函数提升12345678910var func = function() &#123; console.log(&quot;调用外面的函数&quot;);&#125;;var foo = function() &#123; func(); var func = function() &#123; console.log(&quot;调用内部的函数&quot;); &#125;; func();&#125;; 预解析：在当前作用域下,js运行之前，会把带有var和function关键字的事先声明，并在内存中安排好，然后再从上到下执行js语句。预解析只会发生在通过var定义的变量和function上。 var 只要是通过var定义的，不管是变量，还是函数，都是先赋值undefined，如果是变量，也不管变量有没有赋值，在预解析阶段，都是会被赋值为undefined。 function function进行预解析的时候，不仅是声明而且还定义了，但是它存储的数据的那个空间里面存储的是代码是字符串，没有任何意义。 123function fun() &#123; //代码区&#125;(); 定义一个函数想要立即执行，写成上面的形式是不可行的，在预解释的时候，它把它分解成两部分来对待，第一部分是fun函数，而第二部分是(),一个匿名函数，执行时会报错。如果小括号带参数，如(2)，虽然不会报错，会打印出来2，但并不能把fn执行，也不能当成参数传递给fn函数。 如果你想实现立即执行的函数，可以把要执行的函数放到一对括号里面，对于JavaScript 来说，括弧()里面不能包含语句，所以在这一点上，解析器在解析function关键字的时候，会将相应的代码解析成function表达式，而不是function声明所以，只要将大括号将代码(包括函数部分和在后面加上一对大括号)全部括起来就可以了。 如下： 123(function fun() &#123; //代码区&#125;()); 预解析是发生在当前作用域下的，刚开始的时候，我们预解析的是全局作用域，在js中我们的global就是我们的window。 我们运行函数的时候会生成一个新的私有作用域（每次执行都是新的，执行完成就销毁）这个作用域下我们可以理解为开辟了一个新的内存空间。在这个内存中我们也要执行预解析。当我们的函数执行完成后，这个内存或者作用域就会销毁。 如果在当前作用域下的一个变量没有预解析，就会向它的上一级去找，直到找到window，如果window下也没有定义，就会报错。所以，在函数内通过var定义的变量是局部变量，没有通过var定义的变量是全局变量。 预解析不会在同一个变量上重复的发生，也就是一个变量如果已经在当前作用域下预解析了，不会再重复解析。 等号右边的function不会进行预解析。 预解释是不受其它if或者其它判断条件影响的，也就是说，即使条件不成立，我们里面只要有var或者function也会被预解释。 后面定义的会覆盖前面定义的。 一些例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 例子一if(!(&quot;a&quot; in window))&#123; var a = &quot;李玉华&quot;；&#125;console.log(a);// 例子二function fn()&#123; console.log(&quot;我们是全局的fn&quot;);&#125;function fn2()&#123; console.log(fn); fn = 3; return ; function fn()&#123; console.log(&quot;我是fn2里面的&quot;); &#125;&#125;fn2();// 例子三var n = 0;function a()&#123; var n = 10; function b()&#123; n++; console.log(n); &#125; b(); return b;&#125;var c = a(); c(); console.log(n); // 例子四var n = 99;function outer()&#123; var n = 0; return function inner()&#123; return n++; &#125;&#125;var c = outer(); var num1 = c();var num2 = c();var d = outer();var num3 = d();console.log(c);console.log(num1);console.log(num2);console.log(d);console.log(num3); 总结 作用域就是根据标识符查找变量的一套规则。（路标） 作用域链就是找变量所走的路径。 预解析就是万恶的“VIP”。 注： ReferenceError作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。 参考链接 作用域和作用域链 块级作用域 作用域和原型","tags":[{"name":"分享","slug":"分享","permalink":"http://yangkunyi.com/tags/分享/"},{"name":"作用域","slug":"作用域","permalink":"http://yangkunyi.com/tags/作用域/"},{"name":"作用域链","slug":"作用域链","permalink":"http://yangkunyi.com/tags/作用域链/"},{"name":"预解析","slug":"预解析","permalink":"http://yangkunyi.com/tags/预解析/"}]},{"title":"作用域和原型","date":"2017-08-02T11:29:16.000Z","path":"2017/08/02/作用域和原型/","text":"什么是作用域？ 它是一套规则，这套规则用来管理引擎如何在当前作用域及嵌套的子作用域中根据标识符名称进行变量的查找。 先介绍一下RHS和LHS 这是引擎的两种查找类型 “R”和“L”分别代表赋值操作的右侧和左侧 案例 123456function foo(a)&#123;//对a进行LHS引用2 console.log(a); //对console进行RHS引用3 //对a进行RHS引用4&#125;foo(2);//对foo进行RHS引用1 当变量还没有声明的时候（在任何作用域都找不到该变量），这两种查询的行为是不一样的：LHS查询会在全局作用域中自己创建一个变量。RHS查询会抛出一个ReferenceError错误。 作用域的嵌套 当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。这一就形成了一条作用域链。 案例 12345function foo(a)&#123; console.log(a+b);&#125;var b=2;foo(2);//4 将作用域链比喻成一个建筑 词法作用域 词法作用域是由你写代码时将变量和块作用域写在哪里来决定的。 案例 JavaScript中有两个机制可以“欺骗”词法作用域 eval() 例子： 123456789101112131415function foo(str, a) &#123; eval( str ); // 欺骗！ console.log( a, b );&#125;var b = 2;foo( &quot;var b = 3;&quot;, 1 );//严格模式// function foo(str) &#123;// &quot;use strict&quot;;// eval( str );// console.log( a ); // ReferenceError: a is not defined// &#125;foo( &quot;var a = 2&quot;); with() 例子： 123456789101112131415161718function foo(obj) &#123; with (obj) &#123; var a = 2; &#125; // a = 2;&#125;var o1 = &#123; a: 3&#125;;var o2 = &#123; b: 3&#125;;foo( o1 );console.log( o1.a );foo( o2 );console.log( o2.a );console.log( a ); 函数作用域 在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。 案例 1234567var a=2;function foo()&#123; var a=3; console.log(a);//3&#125;foo();console.log(a);//2 不足之处： 必须声明一个foo函数，这个foo“污染”了所在作用域。 必须显示调用才能运行其中的代码 改进 1234567var a=2;(function foo()&#123; var a=3; console.log(a);//3&#125;)();console.log(a);//2//函数会被当作函数表达式而不是一个标准的函数声明来处理。 匿名函数 优点： 书写起来简单快捷 缺点： 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。 如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用。（callee是arguments对象的一个属性。它可以用于引用该函数的函数体内当前正在执行的函数。） 匿名函数省略了对于代码可读性/可理解性很重要的函数名。 立即执行函数表达式 IIFE(Immediately Invoked Function Expression)：(function foo(){...})() 函数名对IIFE来说不是必须的：(function(){...}()) 进阶用法：当作函数调用并传参数进去。 例子：12 块作用域 块作用域将代码在函数中隐藏的信息扩展为在块中隐藏起来。 思考 12345for(var i=0;i&lt;10;i++)&#123; console.log(i);&#125;console.log(i);//为什么要把一个只在for循环内部使用（至少是应该只在内部使用）的变量i“污染”到整个作用域（不管是函数还是全局）中？ with：用with从对象创建出的作用域仅在with声明中而非外部作用域中有效。 try/catch：例子：try.html let：let关键字可以将变量绑定到所在的任意作用域中。 垃圾回收 12345678function process(data)&#123; //在这里做点有趣的事情&#125;&#123;//在这个块中定义的内容完事可以销毁 let someReallyBigData=&#123;...&#125;; process(someReallyBigData);&#125; let循环 1234for(let i=0;i&lt;10;i++)&#123; console.log(i);&#125;console.log(i);ReferenceError const：定义一个该块的常量，不能修改值。例子： 12345678var person = function(name)&#123; this.name = name&#125;;person.prototype.getName = function()&#123; console.log(this.name);&#125;var zjh = new person(&apos;zhangjiahao&apos;);zjh.getName(); //zhangjiahao 原型[prototype]普通对象和函数对象 JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象。 123456789101112131415161718var o1 = &#123;&#125;; var o2 =new Object();var o3 = new f1();function f1()&#123;&#125;; var f2 = function()&#123;&#125;;var f3 = new Function(&apos;str&apos;,&apos;console.log(str)&apos;);console.log(typeof Object); //function console.log(typeof Function); //function console.log(typeof f1); //function console.log(typeof f2); //function console.log(typeof f3); //function console.log(typeof o1); //object console.log(typeof o2); //object console.log(typeof o3); //object 怎么区分，其实很简单，凡是通过new&nbsp;Function()创建的对象都是函数对象，其他的都是普通对象。f1,f2,归根结底都是通过new&nbsp;Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的。 什么是prototype？ 在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype属性，这个属性指向函数的原型对象。 12345678910111213141516function Person() &#123; Person.prototype.name = &apos;Zaxlct&apos;; Person.prototype.age = 28; Person.protetype.job = &apos;Software Engineer&apos;; Person.prototype.sayName = function() &#123; alert(this.name); &#125;&#125;var person1 = new Person();person1.sayName(); // &apos;Zaxlct&apos;var person2 = new Person();person2.sayName(); // &apos;Zaxlct&apos;console.log(person1.sayname == person2.sayname); //true 只有函数对象才有 prototype 属性 什么是原型对象？ 原型对象，顾名思义，它就是一个普通对象。从现在开始你要牢牢记住原型对象就是 Person.prototype，如果你还是记不住，那就把它想想成一个字母 A： var A = Person.prototype; 12345678Person.prototype = &#123; name: &apos;Zaxlct&apos;, age: 28, job: &apos;Software Engineer&apos;, sayName: function() &#123; alert(this.name); &#125;&#125; 在默认情况下，所有的原型对象都会自动获得一个constructor（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数（Person） 原型对象（Person.prototype）是 构造函数（Person）的一个实例。 那原型对象是用来做什么的呢？举个例子： 12345678var person = function(name)&#123; this.name = name&#125;;person.prototype.getName = function()&#123; return this.name;&#125;var zjh = new person(‘zhangjiahao’);zjh.getName(); //zhangjiahao 从这个例子可以看出，通过给person.prototype设置了一个函数对象的属性，那由person实例（例中：zjh）出来的普通对象就继承了这个属性。所以原型对象的主要作用就是用于继承。 具体是怎么实现的继承，就要讲到下面的原型链了。 什么是原型链？ JS在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做__proto__的内置属性，用于指向创建它的函数对象的原型对象prototype。例如： console.log(zjh.__proto__ === person.prototype) //true 同样，person.prototype对象也有__proto__属性，它指向创建它的函数对象（Object）的prototype console.log(person.prototype.__proto__ === Object.prototype) //true 继续，Object.prototype对象也有__proto__属性，但它比较特殊，为null console.log(Object.prototype.__proto__) //null 我们把这个有proto串起来的直到Object.prototype.proto为null的链叫做原型链。 注 ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。 区分函数声明和表达式最简单的方法是看function关键字出现在声明这哦那个的位置（不仅仅是一行代码，而是整个声明中的位置）。如果function是在声明的第一个词，那么就是一个函数声明，否则就是一个函数表达式。 作用域理解基于《你不知道的Javascript 上卷》 原型理解基于文章原型与原型链","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yangkunyi.com/tags/Javascript/"},{"name":"分享","slug":"分享","permalink":"http://yangkunyi.com/tags/分享/"}]},{"title":"JavaSccript语言精粹","date":"2017-07-20T07:01:07.000Z","path":"2017/07/20/JavaSccript语言精粹/","text":"知识点 字符串是不可变的。一旦被创建就永远无法改变。 typeof运算符产生的值有‘number’ ‘string’ ‘boolean’ ‘undefined’ ‘function’ ‘object’。 一个属性存取表达式用于指定一个对象或数值的属性或元素。 原型连接只有在检索值的时候才被用到。如果我们尝试弃获取对象的某个属性值，但该对象没有此属性名，那么JavaScript会试着从原型对象中获取属性值。如果那个原型对象也没有该属性，那么再从它的原型中寻找，依次类推，只到该过程最后到达终点Object.prototype。如果想要的属性完全不存在于原型练中，那么结果就是undefined值。这个过程为委托。 用for in的方法来遍历一个对象中的所有属性名，属性名出现的顺序是不确定的，因此要对任何可能出现的顺序有所准备。若想自定义顺序最好的方式是避免使用for in，而是通过建立数组的形式将属性存入，然后用for循环从数组中依次获取属性。这样也不用担心可能发掘出原型链中的属性，并且我们按正常的顺序取得了它的值。 最小化使用全局变量的方法之一是为你的应用只创建一个唯一的全局变量。资源都纳入一个名称空间之下，你的程序与其他应用程序、组件或类库之间发生冲突的可能性就会显著降低。 函数对参数值不会进行类型检查：任何类型的值都可以被传递给任何参数。 apply方法让我们构建一个参数数组传递给调用函数。 因为语言的一个设计错误，arguments并不是一个真正的数组。它只是一个“类似数组（array-like）”的对象。arguments拥有一个length属性，但它没有任何数组的方法。 尾递归是一种在函数的最后执行递归调用语句的特殊形式的递归。 作用域的好处是内部函数可以访问定义它们外部函数的参数和变量（除了this和arguments）。 继承的两种服务： 是代码重用的一种形式。（如果一个新的类与一个已经存在的类大部分相似，那么你只需要具体说明其不同点即可。代码重用的模式极为重要，因为它们可以显著的减少软件开发的成本。） 另一个好处是引入了一套类型系统的规范。（由于程序员无需编写显式类型转换的代码，他们的工作量将大大减轻，这是一件很好的事情，因为类型转换会丧失类型系统在安全上的优势。） 构造一个生成对象的函数： 1.创建一个新的对象。 2.有选择地定义私有的实例变量和放方法。 3.给这个新对象扩充方法。 4.返回那个新对象。 数组的length属性的值是这个数组的最大整数属性名加上1，它不一定等于数组里属性的个数。 for in 用来遍历数组的所有属性，但遗憾的是，for in 无法保证属性的顺序。 数组和对象的使用区别：当属性名是小而连续的整数时，你应该使用数组；否则，使用数组。 排序的稳定性是指排序后的数组中相等值的相对位置没有发生改变，而不稳定性排序则会改变相等值的相对位置。 方法篇Array array.concat(item…):产生新的数组，和它类似功能的array.push(item)。 array.join(separator):把一个array构造成一个字符串。 array.pop():移除数组的最后一个元素，并返回这个元素。 array.push(item…):把一个或多个参数item附加到一个数组的尾部。 array.reverse():反转array里的元素的顺序，并返回array本身。 array.shift():移除数组array中的第一个元素，并返回该元素。 array.slice(start,end):对array中的一段做浅复制。 array.sort(comparefn):对array中的内容进行排序。 array.splice(start,deleteCount,item…):从array中移除一个或多个元素，并用新的item替换它们。 array.unshift(item…):像push方法一样，用于把元素添加到数组中，但它是把item插入到array的开始部分，不是尾部。返回array的新的length。 Function function.apply(thisArg,argArray):调用function，传递一个会被绑定到this上的对象和一个可选的数组作为参数。 Number number.toExponential(fractionDigits):把这个number转换成一个指数形式的字符串。 number.toFixed(fractionDigits):把这个number转换成为一个十进制数形式的字符串。可选择参数控制其小数点后的数字位数。 number.toPrecision(precision):把这个number转换成一个十进制数形式的字符串。可选择参数控制数字的精度（0~21）。 number.toString(radix):把这个number转换成字符串。可选择参数控制基数（2~36，默认是10）。 Object object.hasOwnProperty(name):判断属性是否存在，不会检查原型链中的同名属性。 RegExp regexp.exec(string):最强大（和最慢），看书理解。 regexp.test(string):最简单（和最快），匹配就返回true，否则返回false，不要对这个方法使用g标识。 String string.charAt(pos):返回在string中pos位置处的字符。 string。charCodeAt(pos):返回在string中pos位置的字符的字符码位（以整数形式表示）。 string.conecat(string…):把其他的字符串连接在一起来构造一个新的字符串。 string.indexOf(searchString,postion):在string中查找另一个字符串searchString。找到就返回第一个匹配字符的位置，否则返回-1。可选参数position从字符串的哪个位置开始查找。 string.lastIndexOf(searchString,position):从字符串的末尾开始查找。 string.lacaleCompare(that):比较两个字符串。 string.match(regexp):让字符串和一个正则表达式进行匹配。 string.replace(searchValue,replaceValue):对string进行查找和替换操作，并返回一个新的字符串（如果searchValue不是一个带有g标识的正则表达式那就只会替换第一个）。 string.search(regexp):接收一个正则表达式作为对象参数返回匹配的首字符位置。 string.slice(start,end):复制string的一部分来构造一个新的字符串。 string.split(separator,limit):把这个string分割成片段来创建一个字符串数组。 string.substring(start,end):和slice方法一样，只是他不能处理负数参数。 string.toLocaleLowerCase():返回一个新字符串，使用本地化的规则将这个string中所有字母转换成小写格式。 string.toLacaleUpperCase():返回一个新字符串，使用本地化的规则将这个string中所有字母转换成大写格式。 string.toLowerCase():返回一个新的字符串，这个string中所有字母都被转换为小写格式。 string.toUpperCase():返回一个新的字符串，这个strnig中所有字母都被转换为大写格式。 string.fromCharCode(char…):函数根据一串数字编码返回一个字符串。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yangkunyi.com/tags/笔记/"}]},{"title":"vue2.0生命周期","date":"2017-06-02T02:03:58.000Z","path":"2017/06/02/vue2-0生命周期/","text":"图解 函数解释 beforeCreate在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。 created实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount在挂载开始之前被调用：相关的 render 函数首次被调用。 mountedel 被新创建的vm.\\$el替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 beforeUpdate数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 updated由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 beforeDestroy实例销毁之前调用。在这一步，实例仍然完全可用。 destroyedVue 实例销毁后调用。调用后，Vue实例指示的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/vue/2.1.3/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message : &quot;Hello!&quot; &#125;, beforeCreate: function () &#123; console.group(&apos;beforeCreate 创建前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot; , &quot;el : &quot; + this.$el); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) &#125;, created: function () &#123; console.group(&apos;created 创建完毕状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, beforeMount: function () &#123; console.group(&apos;beforeMount 挂载前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + (this.$el)); //已被初始化 console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, mounted: function () &#123; console.group(&apos;mounted 挂载结束状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); //已被初始化 console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, beforeUpdate: function () &#123; console.group(&apos;beforeUpdate 更新前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, updated: function () &#123; console.group(&apos;updated 更新完成状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, beforeDestroy: function () &#123; console.group(&apos;beforeDestroy 销毁前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, destroyed: function () &#123; console.group(&apos;destroyed 销毁完成状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用浏览器打开 beforecreated：el 和 data 并未初始化created:完成了 data 数据的初始化，el没有beforeMount：完成了 el 和 data 初始化mounted ：完成渲染 关于更新app.message= &#39;vue&#39;; 关于销毁app.$destroy(); 销毁完成后，我们再重新改变message的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在。可以这么理解，执行了destroy操作，后续就不再受vue控制了。 生命周期函数的一些用法 beforecreate : 举个栗子：可以在这加个loading事件created ：在这结束loading，还做一些初始化，实现函数自执行mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情beforeDestory： 你确认删除XX吗？destoryed ：当前组件已被删除，清空相关内容","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yangkunyi.com/tags/Javascript/"},{"name":"vue","slug":"vue","permalink":"http://yangkunyi.com/tags/vue/"},{"name":"分享","slug":"分享","permalink":"http://yangkunyi.com/tags/分享/"}]},{"title":"坎帕斯学院日常讨论","date":"2017-04-16T08:14:15.000Z","path":"2017/04/16/坎帕斯学院日常讨论-1/","text":"话题：width：100%和width：auto的区别 width：100% 元素宽度等于父级元素的宽度。 width：auto 元素的宽度等于父元素的宽度减去margin，padding，border这些。 高度知识点 子元素的margin和padding百分比知识点根据父元素的width来算。123456789101112131415161718192021222324//test1&lt;style&gt; body&#123; margin:0; padding:0; &#125; .main&#123; width:500px; background:red; &#125; .test&#123; width:auto; padding:20px; margin:10px; border:5px solid blue; background:green; &#125;&lt;/style&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;test&quot;&gt;123&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; test width=父元素width-margin-padding-border 123456789101112131415161718192021222324//test2&lt;style&gt; body&#123; margin:0; padding:0; &#125; .main&#123; display:inline-block; background:red; &#125; .test&#123; width:auto; padding:20px; margin:10px; border:5px solid blue; background:green; &#125;&lt;/style&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;test&quot;&gt;123123123123123&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; test width=123123123123123+margin+padding+border 1234567891011121314151617181920212223242526//test3&lt;style&gt; body&#123; font-size:20px; margin:0; padding:0; &#125; .main&#123; display:inline-block; background:red; width:500px; &#125; .test&#123; width:auto; padding:20px; margin:10px; border:5px solid blue; background:green; &#125;&lt;/style&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;test&quot;&gt;123123123123123&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; test width=500-padding-margin-border这里的500px并不是继承，而是因为div块级元素的影响而来的。 123456789101112131415161718192021222324252627//test4a&lt;style type=&quot;text/css&quot;&gt; body&#123; font-size: 20px; padding: 0; margin: 0; &#125; .first1&#123; background: red; width: 200px; height: 400px; overflow: hidden; &#125; .second1&#123; height: 25%;width: 25%; margin-top: 10%; background-color: green; padding-left: 10%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;first1&quot;&gt; &lt;div class=&quot;second1&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; test width=50,height=100,margin-top=20 2017.4.19 21:00话题：document.getElementByClassName()返回的是什么？ 是一个HTML集合。 集合和数组的区别 HTML集合：一直与文档保持着链接，每次你需要最新的信息时，都会重复执行查询的过程，哪怕只是获取集合里的元素个数，即集合的length属性也是这样。（简单的说就是这个集合会实时改变） 案例：12345var alldivs document.getElementsByTagName(&apos;div&apos;);for(var i=0;i&lt;alldivs.length;i++)&#123; document.body.appendChild(document.createElement(&apos;div&apos;));&#125;//该循环会一直循环下去，因为每次添加一个div之后，alldicvs.length的值也会改变，导致循环条件一直为true，一直循环。 关于闭包和词法作用域 案例：12345678910function foo()&#123; concile.log(a);//2&#125;function bar()&#123; var a=3; foo();&#125;var a=2;bar();//原理：js的运行原理是词法作用域，而非动态作用域，因此当foo函数被调用的时候，对a进行查询的时候会直接在全局作用域中查询。 话题：display：none和visibility：hidden区别？ display：none；有dom树，没有渲染树，也就是说js可以找到display：none。 visibility：hidden；只是将内容隐藏起来了，还是要占位的。 话题：两个inline-block元素在同一行中间的那个间距是多少？ 每个浏览器间距不同。 字体大小不同间距不同。 如何去掉这个空格？ 去掉最底层html标签的空格。 margin为负值。（每个浏览器不同，值不同） 将父级元素的字体大小设置为0。（推荐方案） 注意： 这个间距不仅在水平方向有，在垂直方向也有！ 距离大概是字体大小的1/8（可能会有叠加）。 inline-block元素之间，block和inline-block和inline的元素之间都有间距。","tags":[{"name":"前端","slug":"前端","permalink":"http://yangkunyi.com/tags/前端/"},{"name":"记录","slug":"记录","permalink":"http://yangkunyi.com/tags/记录/"},{"name":"问题","slug":"问题","permalink":"http://yangkunyi.com/tags/问题/"},{"name":"讨论","slug":"讨论","permalink":"http://yangkunyi.com/tags/讨论/"}]},{"title":"数组","date":"2017-04-10T11:13:22.000Z","path":"2017/04/10/数组/","text":"Array创建实例 1234567891011//用构造函数的方法var colors=new Array();var colors=new Array(20);var colors=new Array(&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;);var colors=Array();//可以省略new//用数组字面量表示法var colors=[&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;];var names=[];var values=[1,2,];//不要这样，这样会创建一个包含2或3项的数组var options=[,,,,,]//不要这样，这样会创建一个包含2或6项的数组 检测数组 Array.isArray()确定一个值到底是不是数组转换方法 toString()：返回有由数组中每个值得字符串形式拼接而成的一个以逗号分隔的字符串。 valueOf()：直接返回数组 toLocaleString()：创建一个数组值的以逗号分隔的字符串。 1234567891011121314151617181920212223242526var colors=[&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;];alert(colors.toString()); //gray,green,redalert(colors.valueOf()); //gray,green,redalert(colors); //gray,green,red//最后一行将数组传给alert，alert要求接受字符串，所以后台自动调用头String（）var person1=&#123; toLocaleString:function()&#123; return &quot;Nikolaos&quot;; &#125;, toString:function()&#123; return &quot;Nicholas&quot;; &#125;&#125;;var person2=&#123; toLocaleString:function()&#123; return &quot;Grigorios&quot;; &#125;, toString:function()&#123; return &quot;Greg&quot;; &#125;&#125;;var people=[person1,person2];alert(people); //Nicholas,Gregalert(people.toString()); //Nicholas,Gregalert(people.toLocaleString()); //Nicholas,Grigorios join()方法：可以用其他符号来分隔数组 123var colors=[&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;];alert(colors.join(&quot;,&quot;)); //gray,green,redalert(solors.join(&quot;||&quot;)); //gray||green||red 栈方法 push()方法可以接受任意数量的参数，把他们逐个添加到数组末尾，并返回修改后的数组的长度。 pop()方法则是从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。123456789101112131415var colors=new Array();var count=colors.push(&quot;red&quot;,&quot;green&quot;);alert(count); //2count=colors.push(&quot;black&quot;);alert(count); //3var item=color.pop();alert(item); //&quot;black&quot;;alert(colors.length); //2//可以将栈方法和其它数组方法连用var colors=[&quot;red&quot;,&quot;blue&quot;];colors.push(&quot;brow&quot;);colors.[3]=&quot;black&quot;;alert(colors.length); //4var item=colors.pop();alert(item); //&quot;black&quot; 队列方法 shift()方法能够移除数组中的第一项，并且返回该项，同时将数组长度减1。 unshift()方法能在数组前段端添加任意个项并返回数组长度。12345678var colors=new Array();var count=colors.push(&quot;red&quot;,&quot;green&quot;);alert(count); //2var item=colors.shift();alert(item); //&quot;red&quot;alert(colors.length); //1count=colors.unshift(&quot;black&quot;);alert(count); //2 排序 reverse()方法：反转数组项的顺序。返回值是数组。 sort()方法：按升序排列数字项。（比较的是字符串）返回值是数组。1234567891011121314151617181920var values=[1,2,3,4,5];values.reverse();alert(values); //5,4,3,2,1var values=[0,1,5,10,15];values.sort();alert(values); //0,1,10,15,5//在字符串进行比较的时候5是比10大的，这个时候我们经常让sort方法接受一个比较函数作为参考。//比较函数（升序，改变大于和小于就能变成降序）function campare(value1,value2)&#123; if(value1&lt;value2) return -1; else if(value1&gt;value2) return 1; else return 0;&#125;var values=[0,1,5,10,15];values.sort(campare);alert(values); //0,1,5,10,15 操作方法 concat()方法：创建一个新的数组。复制一遍数组并在末尾添上新的元素。 1234var colors=[&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;];var colors2=colors.contac(&quot;yellow&quot;,[&quot;black&quot;,&quot;brown&quot;]);alert(colors); //gray,green,redalert(colors2); //gray,green,red,yellow,black,brown slice()方法：能够基于当前数组中的一或多个项创建一个新数组。 当有一个参数时：返回从该参数指定位置开始到当前数组末尾的所有项。 如果有两个参数时：返回起始和结束位置之间的项，但不包括结束为止的项。 splice()方法：主要用途是项数组中部插入项。（最强大的数组方法） 删除：需要两个参数，位置和删除项数。例：splice(0,2);删除数组中的前两项。 插入：需要三个参数，起始位置，0（删除的项数）和插入项。例：splice(2,0,&quot;red,&quot;green&quot;)从数组的位置2开始插入字符串”red”和”green”。 替换：需要三个参数，起始位置，要删除的的项数和要插入的任意数量的项。例：splice(2，1，&quot;red&quot;,&quot;green&quot;)删除当前数组位置2的项，然后再从位置2开始插入字符串。位置方法 indexOf()方法：从数组的开头开始向后查找。 lastIndexOf()方法：从数组的末尾开始向前查找。两个方法都接收两个参数，要查找的项和开始查找的起始位置。没找到的情况返回-1，返回值是位置。123456789101112var numbers=[1,2,3,4,5,4,3,2,1];alert(numbers.indexOf(4)); //3alert(numbers.lastIndexOf(4)); //5alert(numbers.indexOf(4，4)); //5alert(numbers.lastIndexOf(4，4)); //3var person=&#123;name:&quot;Nicholas&quot;&#125;;var people=[&#123;name:&quot;Nicholas&quot;&#125;];var morePeople=[people];alert(people.indexOf(person)); //-1alert(morePeople.indexOf(peoson)); //0 迭代方法 every():对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true，否则返回false。 filter():对数组中的每一项运行给定函数，返回该函数会返回true的项组成数组。 forEach():对数组中的每一项运行给定函数，这个方法没有返回值。 map():对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some():对数组中的每一项运行给定函数，如果该函数对任意一项返回true，则返回true。以上方法都不会修改数组中包含的值。都接收三个参数：数组项的值，该项在数组的位置，数组对象本身。1234567891011121314151617181920212223242526272829//every()var numbers=[1,2,3,4,5,4,3,2,1];var everyResult=numbers.every(function(item,index,array)&#123; return (item&gt;2);&#125;);alert(everyResult); //false//some()var numbers=[1,2,3,4,5,4,3,2,1];var someResult=numbers.every(function(item,index,array)&#123; return (item&gt;2);&#125;);alert(someResult); //true//filter()var numbers=[1,2,3,4,5,4,3,2,1];var filterResult=numbers.every(function(item,index,array)&#123; return (item&gt;2);&#125;);alert(filterResult); //[3,4,5,4,3]//map()var numbers=[1,2,3,4,5,4,3,2,1];var mapResult=numbers.every(function(item,index,array)&#123; return item*2;&#125;);alert(mapResult); //[2,4,6,8,10,8,6,4,2]//forEach()var numbers=[1,2,3,4,5,4,3,2,1];numbers.forEach(function(item,index,array)&#123; //执行某些操作&#125;); 归并方法 reduce():从数组的第一个开始，逐个遍历到最后。 reduceRight():从数组最后一个开始，逐个遍历到第一个。 这两个函数接收两个参数：一个在每一项上的调用的函数和（可选的）作为归并基础的初始值。 传给两个函数的函数接收四个参数：前一个值，当前值，项的索引，数组对象。 函数的返回值都会作为第一个参数自动传给下一项。123456789101112//reduce()正向var values=[1,2,3,4,5];var sum=values.reduce(function(prev,cur,index,array)&#123; return prev+cur;&#125;);alert(sum); //15//ruduceRight()反向var values=[1,2,3,4,5];var sum=values.reduceRight(function(prev,cur,index,array)&#123; return prev+cur;&#125;);alert(sum); //15","tags":[{"name":"前端","slug":"前端","permalink":"http://yangkunyi.com/tags/前端/"},{"name":"笔记","slug":"笔记","permalink":"http://yangkunyi.com/tags/笔记/"},{"name":"数组","slug":"数组","permalink":"http://yangkunyi.com/tags/数组/"}]},{"title":"DOM知识点","date":"2017-04-10T11:07:45.000Z","path":"2017/04/10/DOM知识点/","text":"DOM D：document（文档）O：object（对象）：用户定义对象，内建对象，宿主对象M：model（模型）：“map”，树 节点 元素节点（element node）：body，ul，li……获取元素节点的方法： 通过元素id（getElementById ） 通过标签名（getElementsByTagName） 通过类名（getElementsByClassName） 属性节点（attribute node）&lt;p title=&quot;yang&quot;&gt;hahahahahahha&lt;/p&gt;title=”yang”是一个属性节点属性节点总是包含在元素节点中 文本节点获取和设置属性 getAttribute（获取） 12345//例子var paras=document.getElementsByTagName(&quot;p&quot;);for(var i=0;i&lt;paras.lengeh;i++)&#123; alert(paras[i].getAttribute(&quot;title&quot;));&#125; setAttribute（设置）若属性本不存在，实际就将完成两项操作：1.创建属性，2.设置值。注：并不会改变源文件扽静态内容。 123//例子var shopping=document.getElementById(&quot;purchases&quot;);shopping.setAttribute(&quot;title&quot;,&quot;a list of goods&quot;); 实例：JavaScript图片库 childNodes属性用来获取任何一个元素的所有子元素。 123456//获取body所有子元素个数的函数例子function countBodyChildren()&#123; var body_element=document.getElementsByTagName(&quot;body&quot;)[0]; alert(body_element.childNodes.length);&#125;window.onload=countBodyChildren; nodeType属性 元素节点的nodeType属性值是1。 属性节点的nodeType属性值是2。 文本节点的nodeType属性值是3。alert(body_element.nodeType); nodeValue属性得到和设置一个节点的值。alert(discription.nodeValue); firstChild和lastChild属性这两个属性都是为了个简便且直观的获取对应的元素。 注意点 DOM是一套对文档内容进行抽象和概念化的方法。 变量名中不能包含空格和标点符号（美元$符号除外）。 变量名允许包含字母，数字，美元符号和下划线（但第一个字符不能是数字）。 变量申明实例：my_mood或者myMood（峰驼式camel case：首选）。 Javascript是弱类型语言，不需要对变量进行类型声明。 变量可以包含操作。 字符串可以做拼接操作。 innerHTML属性和documen.write方法都是HTML的专有属性。var message=&quot;I am feeling&quot;+&quot;happy&quot;; 每个元素节点都是一个对象。","tags":[{"name":"前端","slug":"前端","permalink":"http://yangkunyi.com/tags/前端/"},{"name":"DOM","slug":"DOM","permalink":"http://yangkunyi.com/tags/DOM/"},{"name":"JS","slug":"JS","permalink":"http://yangkunyi.com/tags/JS/"}]},{"title":"BOM知识点","date":"2017-04-06T00:56:57.000Z","path":"2017/04/06/BOM知识点/","text":"BOM 一、window对象1.全局作用域 全局变量会变成window对象的属性。 全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性可以。 123456789var age=29;window.color=&quot;red&quot;;//在IE&lt;9时抛出错误，在其他所有浏览器中都返回falsedelete window.age;//在IE&lt;9时抛出错误，在其他所有浏览器中都返回truedelete window.color;//returns truealert(window.age);//29alert(window.color);//undefined 尝试访问未声明变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明变量是否存在。 窗口关系及框架 除非最高层窗口是通过window.open()打开的，否则其window对象的name属性不会包含任何值。 在使用框架的情况下，浏览器中会存在多个Global对象。 在每个框架中定义的全局变量会自动变成框架中window对象的属性。 由于每个window对象都包含原生类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应但并不相等。 窗口位置 screenLeft/screenTop:分别用于表示相对于屏幕左边和上边的位置。 screenY/screenX:提供相同的窗口位置属性。`` 12var leftPos=(typeof window.screenLeft==&quot;number&quot;)?window.screenLeft:window.screenX;var topPos=(typeof window.screenLeft==&quot;number&quot;)?window.screenTop:window.screenY; 注意：最终无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值。 moveTo()两个参数:移动到什么位置去。 moveBy()两个参数:向什么地方移动。两个函数不适用与框架，只能对最外层的window对象使用。 窗口大小 innerWidth/innnerHeight:返回浏览器本身的尺寸。 outerWidth/outerHeight:返回浏览器本身的尺寸。 document.documentElement.clientWidth/document.documentElement.clientHeight 12345678910111213var pageWidth=window.innerWidth; pageHeight=window.innerHeight;if(typeof pageWidth!=&quot;number&quot;)&#123; if(document.compatMode==&quot;CSS1Compat&quot;)&#123; //通过检查document.compatMode来确定页面是否处于标准模式 pageWidth=document.documentElement.clientWidth; pageHeight=document.documentElement.clientHeight; &#125; else&#123; pageWidth=document.body.clientWidth; pageHeight=document.body.clientHeight; &#125;&#125; resizeTo()两个参数:调整到。 resizeBy()两个参数:接受新窗口与原窗口的宽度和高度之差。两个函数不适用与框架，只能对最外层的window对象使用。 导航和打开窗口 window.open():既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。接收四个参数：1.要加载的URL 2.窗口目标 3.一个特定的字符串 4.一个表示新页面是否取代浏览器历史纪录中当前加载页面的布尔值方法会返回一个指向新窗口的引用。 1.打开窗口 2.安全限制 3.弹出窗口屏蔽程序 1234567891011121314var blocked=false;try&#123; var wroxWin=window.open(&quot;http://www.wrox.com&quot;, &quot;_blank&quot;); if(wroxWin==null)&#123; blocked=true; &#125;&#125;catch(ex)&#123; blocked=true;&#125;if(blocked)&#123; alert(&quot;The popup was blocked!&quot;);&#125; 在任何情况下，以上代码都可以检测出调用window.open()打开的弹出窗口是不是被屏蔽来了。但要注意的是，检测窗口是否被屏蔽只是一方面，它并不会阻止浏览器显示与被屏蔽的弹出窗口有关的消息。 间歇调用和超时调用 JavaScript是单线程语言，但它允许通过设置超时值和间歇值来调度代码在特定的时刻执行。 setTimeout(): 接受两个参数：1.要执行的代码（不建议传字符串，因为可能导致性能损失，建议用函数） 2.以毫秒表示的时间 该方法会返回一个数值ID，表示超时调用。这个超时调用ID是计划执行代码的唯一标识符，可以通过它来取消超时调用。 setInterval(): 与超时调用类似，但是它会按照指定的时间间隔重复执行代码，直到间歇调用被取消或者页面被卸载。 也接受两个参数：1.要执行的代码 2.以毫秒表示的时间 clearTimeout():取消超时调用或者间歇时间调用。 在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。所以，最好不要使用间歇调用。 一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。 123456789101112131415var num=0;var max=10;function incremenetNumber()&#123; num++; //如果执行次数尚未达到max设定的值，则设置另一次超时调用 if(num&lt;max)&#123; setTimeout(incrementNumber,500); &#125; else&#123; alert(&quot;Done!&quot;); &#125;&#125;setTimeout(incrementNumber,500); 系统对话框 alert():向用户显示一个系统对话框，其中包含一个制定的文本和一个OK（确定）按钮。 confirm():向用户显示“警告”对话框，返回true或者flase。 prompt():显示一个“提示”框，用于提示用户输入一些文本。接受两个参数：1.要显示给用户的文本提示 2.文本输入域的默认值。 window.find():显示“查询”对话框。 window.print():显示“打印”对话框。 二、location对象查询字符串参数 解析查询字符串的函数 1234567891011121314151617181920212223242526272829303132function getQueryStringArgs () &#123; // 解析查询字符串 //取得查询字符串并去掉开头的问号 var qs=(location.search.length&gt;0?location.search.substring(1):&quot;&quot;), //保存数据对象 args=&#123;&#125;, //取得每一项 items=qs.length?qs.sqlit(&quot;&amp;&quot;):[], item=null, name=null, value=null, //在for循环中使用 i=0, len=items.length; //逐个将每一项添加到args对象中 for (var i = 0; i &lt; len ; i++) &#123; item=items[i].sqlit(&quot;=&quot;); name=decodeURIComponent(item[0]); value=decodeURIComponent(item[1]); if (name.length) &#123; args[name]=value; &#125; &#125; return args;&#125; 位置操作改变浏览器的位置 assigned()：location.assign(&quot;http://www.wrox.com&quot;); location.href window.location replace()：让用户无法回到前一个页面，历史记录中不会生成新的记录。 raload()：作用是重新加载当前显示的页面。最好将其放在代码的最后一行。 三、navigation对象检查插件 检查插件 123456789101112131415161718192021222324252627282930313233//检查插件（在IE中无效）function hasPlugin (name) &#123; name=name.toLowerCase(); for (var i = 0; i &lt; navigator.plugins.length; i++) &#123; if (navigator.plugins[i].name.toLowerCase().indexOf(name)&gt;-1) &#123; return true; &#125; &#125; return false;&#125;//检测flash//alert(hasPlugin(&quot;Flash&quot;));//检测QuickTime//alert(hasPlugin(&quot;QuickTime&quot;));//检测IE中的插件function hasIEPlugin (name) &#123; try&#123; new ActiveXObject(name); return true; &#125; catch(ex)&#123; return false; &#125;&#125;//检测flash//alert(hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;));//检测QuickTime//alert(hasPlugin(&quot;QuickTime.QuickTime&quot;)); 注册处理程序 registerContentHandler()：接收三个参数：1.要处理的MIME类型。2.可以处理该MIME类型的页面的URL。3.应用程序的名称。 registerProtocolHandler()：接收三个参数：1.要处理的协议。2.处理该协议的页面的URL。3.应用程序的名字。 四、screen对象五、history对象 go() back() forward() lengh属性","tags":[{"name":"BOM","slug":"BOM","permalink":"http://yangkunyi.com/tags/BOM/"},{"name":"前端","slug":"前端","permalink":"http://yangkunyi.com/tags/前端/"},{"name":"笔记","slug":"笔记","permalink":"http://yangkunyi.com/tags/笔记/"}]},{"title":"动画和HTML5","date":"2017-03-23T06:33:24.000Z","path":"2017/03/23/动画和HTML5/","text":"用JavaScript实现动画效果 知识点 position属性： static：默认值，意思是有关元素将按照它们在标记里出现的先后顺序出现在浏览器窗口里。 relative：与static相似，区别是relative的元素还可以（通过应用float属性）从文档的正常显示顺序里脱离出来。 absolute：我们就可以将它摆在“容器”的任何位置。这个容器要么是文档本身，要么是一个有着fixed或absolute属性的父元素。这个元素在原始标记里面出现的位置与它显示位置无关，因为它的显示位置由top，left，right和bottom等属性决定。你可以使用像素或百分比为单位设置这些属性。 overflow属性： visible：不裁剪溢出内容。 hidden：隐藏溢出内容。 scroll：类似鱼hidden，浏览器将对溢出的内容进行隐藏，但显示一个滚动条以便让用户能够滚动看到内容的其他部分。 auto：类似于scroll，但浏览器只在确实发生溢出时才显示滚动条，如果没有溢出就不显示滚动条。时间 setTimeout：能够让某个函数在经过一段预定的时间之后才开始执行。 函数有两个参数：第一个是字符串，执行的函数名；第二个是数值，以毫秒为单位设定了需要经过多长时间才开始执行第一个参数所给出的函数。 setTimeout(&quot;function&quot;,interval) 在绝大多数情况下，将函数调用赋值给一个变量是一个好主意。 varible=setTimeout(&quot;function&quot;,interval) 取消某个正在排队等候执行的函数： clearTimeout(variable) HTML5video： currentTime：返回当前播放的位置，以秒表示； duration：返回媒体的总时长，以秒表示，对于流媒体返回无穷大； * paused：表示媒体是否处于暂停状态； 触发脚本的事件： play：在媒体播放开始时发生； pause：在媒体暂停是发生； loadeddata：在媒体可以从当前播放位置开始播放时发生； ended：在媒体已播放完成而停止时发生； 别忘了给&lt;video&gt;元素叫control属性： &lt;video src=&quot;movie.ogv&quot; control&gt; 表单：新的输入控件类型 email，用于输入电子邮件地址； url，用于输入URL； date，用于输入日期和时间； number，数值； ranger，生成滑动条； search，搜索框； tel，电话号码； color，选择颜色；新的属性 autocomplete，用于为文本（text）输入框添加一组建议的输入项； autofocus，让表单元素自动获得焦点； form，对标签外部的表单元素分组； min，max和step，用在范围（range）和数值（number）输入框中； pattern，定义一个正则表达式，以便验证输入的值； placeholder，在文本输入临时性的提示信息； required，表示必填；","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yangkunyi.com/tags/Javascript/"},{"name":"动画","slug":"动画","permalink":"http://yangkunyi.com/tags/动画/"},{"name":"HTML5","slug":"HTML5","permalink":"http://yangkunyi.com/tags/HTML5/"}]},{"title":"JSON相关内容","date":"2017-03-22T15:02:31.000Z","path":"2017/03/22/JSON相关内容/","text":"JSON 知识点 JSON是一种数据结构，不是一种编程语言。 语法（三种类型的值） 简单值：使用JavaScript语法，可以在JSON中表示字符串、数值、布尔值和null，但不支持undefined。 字符串必须用双引号。 没有变量，没有分号。 对象：表示一组无序的键值对儿，每个键值对儿的值可以是简单值，也可以是复杂数据类型。 对象的属性必须加双引号。 没有声明，没有末尾的分号。 一个对象绝不能出项两个同名的属性。 数组：一组有序的值的列表，可以通过数值索引类访问其中的值，数组的值也可以是任意值。 没有变量，没有分号。 解析与序列化JSON可以将JSON数据结构解析为有用的JavaScript对象。 JSON对象 stringify()：将JavaScript对象序列化为JSON字符串。 parse()：将JSON字符串解析为原生的JavaScript值。 序列化选项 stringify()除了要序列化的JavaScript对象外，还可以接收两个参数，用于指定以不同的方式序列化JavaScript对象。一个是参数过滤器（可以是数组，可以是函数），第二个参数是选项，表示是否在JSON字符串中保存缩进。 如果是数组，就返回对象相应的属性。 如果是函数，返回值是undefined将会被忽略。 字符串缩进：第三个参数用于控制结果中的缩进和空白字符串。如果是数字就表示的是每个级别缩进的空格数。 toJSON()方法：（没看懂）。","tags":[{"name":"前端","slug":"前端","permalink":"http://yangkunyi.com/tags/前端/"},{"name":"JSON","slug":"JSON","permalink":"http://yangkunyi.com/tags/JSON/"}]},{"title":"css选择器、权重及优先级","date":"2017-03-21T07:11:22.000Z","path":"2017/03/21/css选择器、权重及优先级/","text":"遇到的问题 子元素使用padding会影响父元素。（解决方法是给父元素用padding） 背景图片的设置。（已解决） 分享会（胡小青）CSS选择器、权重及优先级选择器的种类 通配符选择器（＊） id选择器（#ID） 类选择器（.className） 标签选择器(E) 后代选择器（Ｅ Ｆ） 子元素选择器(E&gt;F) 相邻兄弟元素选择器(E + F) 群组选择器（selector1,selector2,…,selectorN） 交集选择器（E.className) 属性选择器 伪类选择器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//html&lt;div id=&quot;share&quot;&gt;id选择器&lt;/div&gt;&lt;div class=&quot;share&quot;&gt;类选择器&lt;/div&gt;&lt;div&gt; &lt;em&gt;标签选择器&lt;/em&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;后代选择器&lt;/p&gt; &lt;p&gt;&lt;span&gt;非直系后代&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;子元素选择器&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;相邻兄弟1&lt;/p&gt; &lt;span&gt;相邻兄弟2&lt;/span&gt;&lt;/div&gt;&lt;div&gt; &lt;h1&gt;群组选择器&lt;/h1&gt; &lt;h2&gt;群组选择器&lt;/h2&gt; &lt;h3&gt;群组选择器&lt;/h3&gt;&lt;/div&gt;//css*&#123; margin: 0; padding: 0;&#125;#share&#123; width: 200px; background: #cfd2d1;&#125;.share&#123; width: 200px; background: #e9eeec; margin-bottom: 10px;&#125;div.share &#123; border: 2px solid #000;&#125;em&#123; background: #f5f6f6;&#125;div p &#123; background: #e9eeec;&#125;div p span&#123; width: 200px; background: #acb1af;&#125;div &gt; p &#123; width: 200px; background: #adcec0;&#125;p + span &#123; width: 200px; background: #9d9e9e;&#125;h1,h2,h3 &#123; width: 200px; background: #afead2;&#125; 属性选择器 属性选择器 功能 E[att] 匹配所有具有att属性的E元素，不考虑它的值。 css2 E[att=val] 匹配所有att属性等于”val”的E元素 css2 E[att~=val] 匹配属性包含val的元素，并设置其样式：注意是val，所以val-ab这样不算 css2 E[att\\ =val] 匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以”val”开头的E元素，主要用于lang属性 css2 E[att^=val] 选择匹配的元素E，E定义了属性att,属性值以val开头的字符串 css3 E[arr$=val] 选择匹配的元素E，E定义了属性att,属性值以val结尾的字符串 css3 E[att*=val] 选择匹配的元素E，E定义了属性att,属性值包含val的字符串，也就是val可以在任意位置 css3 123456789101112131415161718192021222324252627282930//html&lt;a href=&quot;xxx.pdf&quot;&gt;我链接的是PDF文件&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;icon&quot;&gt;我类名是icon&lt;/a&gt;&lt;a href=&quot;#&quot; title=&quot;我的title是more&quot;&gt;我的title是more&lt;/a&gt;&lt;a href=&quot;#&quot; name=&quot;about&quot; lang=&quot;en-zhN&quot;&gt;选择含有about的元素&lt;/a&gt;&lt;a href=&quot;#&quot; name=&quot;about-ab&quot; lang=&quot;en&quot;&gt;选择含有about的元素&lt;/a&gt;&lt;a href=&quot;#&quot; name=&quot;about ab&quot;&gt;选择含有about的元素&lt;/a&gt;//cssa[href=&quot;xxx.pdf&quot;] &#123; border: 1px solid #000;&#125;a[href$=pdf]&#123; background: orange; color: #fff;&#125;a[class^=icon] &#123; background: #55e2a8; color:#fff;&#125;a[title*=more] &#123; background: #7a92e9; color: #fff;&#125;a[name~=about] &#123; background: #55e2a8;&#125;a[lang|=en] &#123; border: 1px solid #000;&#125; 伪类选择器 *动态伪类 锚点伪类 :link 链接访问前状态 :visited 链接访问后状态 :hover 鼠标悬浮链接的状态 :active 激活链接时的状态 伪类的顺序：link - visited -&gt; hover -&gt; active 用户行为伪类 :hover 用于当用户把鼠标移动到元素上面时的效果 :active 用于用户点击元素那一下的效果 :focus用于元素成为焦点，这个经常用在表单元素上 顺序： focus - &gt; hover -&gt; activeIE6下只有&lt;a&gt;支持:hover，IE6,7都不支持:focus、:active 1234567891011121314151617181920212223//html&lt;a href=&quot;#&quot; class=&quot;link&quot;&gt;link效果&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;visited&quot;&gt;visited效果&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;hover&quot;&gt;hover效果&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;active&quot;&gt;active效果&lt;/a&gt;&lt;input type=&quot;text&quot; name=&quot;&quot;&gt;//css.link:link &#123; background: pink;&#125;.visited:visited&#123; background: #cca;&#125;.hover:hover &#123; background: lightblue;&#125;.active:active &#123; background: lightgreen;&#125;input:focus &#123; outline: 2px solid red;&#125; UI元素状态伪类这类伪类主要针对form元素 伪类 功能 适用元素 :enabled 匹配表单中激活的元素 type=”text” :disabled 匹配表单中禁用的元素 type=”text” :checked 匹配表单中被选中的radio（单选框）或checkbox（复选框）元素 type=”radio” ::selection 匹配用户当前选中的元素 123input[type=&quot;radio&quot;]:disabled &#123; background-color: red;&#125; 结构伪类 :first-child* 选择某个元素的第一个子元素,IE6不支持； :last-child* 选择某个元素的最后一个子元素； :nth-child()* 选择某个元素的一个或多个特定的子元素，IE6-8，Firefox3.0不兼容； :nth-child(length)&ensp;&ensp;参数是具体数字 :nth-child(n)&ensp;&ensp;参数是n,n从0开始计算 :nth-child(nlength)&ensp;&ensp;n的倍数选择，n从0开始算 :nth-child(n+length)&ensp;&ensp;选择大于length后面的元素 :nth-child(-n+length)&ensp;&ensp;选择小于length前面的元素 :nth-child(nlength+1)&ensp;&ensp;表示隔几选一 123456789101112131415li:last-child &#123; background: #f9f57a;&#125;li:nth-child(2) &#123; background: #c8cac9;&#125;li:nth-child(2n) &#123; border: 3px solid red;&#125;li:nth-child(n+3) &#123; border: 3px solid yellow;&#125;li:nth-child(-n+3) &#123; border: 3px solid yellow;&#125; :nth-last-child()选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算，IE6-8，Firefox3.0不兼容； :nth-of-type()选择指定的元素,与nth-child类似也可以使用表达式，IE6-8，Firefox3.0不兼容； :nth-last-of-type()选择指定的元素，从元素的最后一个开始计算； :first-of-type选择一个上级元素下的第一个同类子元素，与first-child类似，不过是指定了元素类型； :last-of-type选择一个上级元素的最后一个同类子元素； :only-child选择的元素是它的父元素的唯一一个子元素，兼容到IE9； :only-of-type选择一个元素是它的上级元素的唯一一个相同类型的子元素，IE6-8，Firefox3.0不兼容； :empty选择的元素里面没有任何内容，兼容到IE9； :not()选择不匹配的元素，兼容到IE9； target 匹配文档中特定”id”点击后的效果，兼容到IE9。 1234567891011121314151617181920//html&lt;a href=&quot;#test&quot;&gt;test&lt;/a&gt;&lt;div&gt;第一个div&lt;/div&gt;&lt;p&gt;第一个p&lt;/p&gt;&lt;div id=&quot;test&quot;&gt;第二个div&lt;/div&gt;&lt;p&gt;第二个p&lt;/p&gt;&lt;p&gt;&lt;/p&gt;//cssdiv:not&#123; background-color: lightgrey;&#125;p:empty&#123; height:30px; width:30px; background:pink;&#125;div:target&#123; color:blue;&#125; 伪元素选择器 伪元素 功能 :first-line 匹配元素的第一行 :first-letter 匹配元素的第一个字母 :before 元素之前插入生成的内容 :after 元素之后插入生成的内容 :selecton 改变浏览网页选中文的默认效果 伪元素可以用::也可以用:关于first-letter使用条件比较苛刻，一般只有有兴趣可以参考深入CSS ::first-letter伪元素及其实例 123li::first-letter &#123; font-size: 56px;&#125; 伪类和伪元素的区别&gt; CSS 伪类用于向某些选择器添加特殊的效果。 CSS 伪元素用于将特殊的效果添加到某些选择器。两者都与选择器相关，可以添加一些“特殊”的效果。 区别：&ensp;&ensp;&ensp;&ensp;伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到 伪类 12345678910//html&lt;p&gt; &lt;i&gt;first&lt;/i&gt; &lt;i&gt;second&lt;/i&gt;+&lt;/p&gt;//cssp&gt;i:first-child &#123; color: red&#125; 伪类 :first-child 添加样式到第一个子元素如果我们不使用伪类，而希望达到上述效果，可以这样做： 12345678910//html&lt;p&gt; &lt;i class=&quot;first-child&quot;&gt;first&lt;/i&gt; &lt;i&gt;second&lt;/i&gt;&lt;/p&gt;//css.first-child &#123; color: red&#125; 我们给第一个子元素添加一个类，然后定义这个类的样式。 伪元素：1234567//html&lt;p&gt;I am stephen lee.&lt;/p&gt;//cssp:first-letter &#123; color: red&#125; 伪元素 :first-letter 添加样式到第一个字母那么如果我们不使用伪元素，要达到上述效果，我们可以这样做： 123//html&lt;p&gt; &lt;span&gt;I&lt;/span&gt; am stephen lee.","tags":[{"name":"前端","slug":"前端","permalink":"http://yangkunyi.com/tags/前端/"},{"name":"笔记","slug":"笔记","permalink":"http://yangkunyi.com/tags/笔记/"},{"name":"分享","slug":"分享","permalink":"http://yangkunyi.com/tags/分享/"}]},{"title":"FirstPassage","date":"2017-03-20T13:20:46.000Z","path":"2017/03/20/FirstPassage/","text":"第一篇博文（搭建博客的坑！！！） 1.关于Hexo nmp安装Hexo 打开命令行工具，执行如下命令： $ npm install -g hexo 创建文件夹 本人是直接在D盘创建了一个名叫blog的文件夹，在blog中创建了Hexo文件夹。（这个看个人喜好吧，用命令行也未尝不可。） 初始化 在Hexo目录下打开命令行工具，执行： hexo init 之后执行： hexo server 会看到： INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 访问：http://localhost:4000/就可以看到Hexo的初始页面了。 2.关于个人设置 基本信息 本人修改了title、subtitle、author的内容，如下： 1234567# Sitetitle: YangKunyi的博客subtitle: 爱看书的杨杨description:author: FrannieYilanguage:timezone: 第一个坑注意每一个冒号后面都有一个空格 无法生效的写法：title:Drubear的博客有效的写法：title:[空格]Drubear的博客 主题 知乎 - 好看的主题！ 使用git命令在github上clone下自己喜欢的主题，本人使用的是litten的yilia。 配置主题根据clone下来的主题将页面进行个性化设置。可以参考博主给的各种参数。 部署设置 只需简单的执行 hexo d But，重点来了前方巨坑请注意 首先在github上建立一个仓库，名字叫做：[你的用户名].github.io注意，你的用户名必须与你实际的用户名一字不差！ 拥有了个人的GitHubPages后，再回到Hexo的_config.yml文件，找到Deployment章节，做以下修改：（以FrannieYi为用户名为例）123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/FrannieYi/FrannieYi.github.io.git branch: master 以上两步做完后，执行 hexo d如果没有报错，你是幸运的。本人在这个坑里栽了无数次，系统报错 ERROR Deployer not found: Git 最后发现这个错误是因为少运行了一行代码： npm install hexo-deployer-git --save 运行完以上代码终于，本人泪流满面的看到了自己亲手搭建的博客。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yangkunyi.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://yangkunyi.com/tags/github/"}]}]