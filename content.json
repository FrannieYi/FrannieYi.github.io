[{"title":"WeeklyMind-1","date":"2017-11-19T06:11:30.000Z","path":"2017/11/19/WeeklyMind-1/","text":"寻常的一周，不过做了许多的决定，之后每一周也希望自己能坚持做一下简单的总结。 总结上周生活 新买的T恤很喜欢 吃得很随便，但不失营养，老年人一样的生活，哈哈哈 住的寝室，还是比较宅，之后希望有时间，还是多出去走走看看 这周没怎么出门，最近在准备各种考试和期中报告 学习 课程： 人际考试 周三运动会放假 复习财管 其它课程一切照常进行 完成日常作业 其它 申请和绑定了域名 博客主题修改 了解nodeppt 简单的看了一下网易云api（有准备做一个音乐播放器） 待更进事项 复习财管（周三考试） 电商案例分析 人际期中报告 不动产课堂报告 课程小节论文 通信英语ppt 继续学习php 更新博客 日常作业 最后还有锻炼，这个事情还是比较重要的。按照自己的计划腾出锻炼的时间，保持健康，毕竟在这个遥远的地方没有买保险。。。","tags":[{"name":"周记","slug":"周记","permalink":"http://yoursite.com/tags/周记/"}]},{"title":"PHP学习笔记","date":"2017-11-17T09:55:52.000Z","path":"2017/11/17/PHP学习笔记/","text":"本文是一些PHP的基础知识，自己看书的时候做的一些笔记。 PHP变量 PHP 语句和 PHP 变量都是区分大小写的。 PHP 没有声明变量的命令。 PHP 是一门弱类型语言 不必向 PHP 声明该变量的数据类型。 PHP会根据变量的值，自动把变量转换为正确的数据类型。 在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称。 作用域局部变量和全局变量 global可以将局部变量提升为全局变量。 PHP将所有全局变量存储在一个名为$GLOBALS[index]的数组中。index保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。 Static作用域 当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除。要做到这一点，请在您第一次声明变量时使用 static 关键字。 参数作用域：属于函数的局部变量。 php中常见的输出语句 echo(): 可以一次输出多个值，多个值之间用逗号分隔。echo是语言结构(language construct)，而并不是真正的函数，因此不能作为表达式的一部分使用。 print(): 函数print()打印一个值（它的参数），如果字符串成功显示则返回true，否则返回false。 print_r(): 可以把字符串和数字简单地打印出来，而数组则以括起来的键和值得列表形式显示，并以Array开头。但print_r()输出布尔值和NULL的结果没有意义，因为都是打印”\\n”。因此用var_dump()函数更适合调试。 var_dump(): 判断一个变量的类型与长度,并输出变量的数值,如果变量有值输的是变量的值并回返数据类型。此函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。 数据类型字符串（String） 双引号串中的内容可以被解释而且替换，而单引号串中的内容总被认为是普通字符。 在单引号串中甚至反斜杠也失去了他的扩展含义（除了插入反斜杠\\和插入单引号\\’）。 所以，当你想在字串中进行变量代换和包含\\n（换行符）等转义序列时，你应该使用双引号。单引号串可以用在其他任何地方，脚本中使用单引号串处理速度会更快些。 整型（Integer） 整数是一个没有小数的数字。 浮点型（Float）-浮点数是带小数部分的数字，或是指数形式。 布尔型（Boolean）数组（Array）对象（Object） 类似于java的类 123456789101112&lt;?php class Car &#123; var $color; function Car($color=&quot;green&quot;) &#123; $this-&gt;color = $color; &#125; function what_color() &#123; return $this-&gt;color; &#125; &#125;?&gt; NULL值 NULL值表示变量没有值。NULL是数据类型为NULL的值。 NULL值指明一个变量是否为空值。同样可用于数据空值和NULL值的区别。 可以通过设置变量值为 NULL 来清空变量数据 字符串函数 strlen(string)函数：返回字符串长度 strpos(seacher,char)函数：查找一个字符串在另一个字符串中第一次出现的位置 数组排序 sort() - 对数组进行升序排列 rsort() - 对数组进行降序排列 asort() - 根据关联数组的值，对数组进行升序排列 ksort() - 根据关联数组的键，对数组进行升序排列 arsort() - 根据关联数组的值，对数组进行降序排列 krsort() - 根据关联数组的键，对数组进行降序排列 PHP 超级全局变量 $GLOBALS：是一个包含了全部变量的全局组合数组。变量的名字就是数组的键。 $_SERVER：是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。 $_REQUEST：用于收集HTML表单提交的数据。 $_POST：被广泛应用于收集表单数据，在HTMLform标签的指定该属性：&quot;method=&quot;post&quot;。 从带有 POST 方法的表单发送的信息，对任何人都是不可见的（不会显示在浏览器的地址栏） 并且对发送信息的量也没有限制。 $_GET：同样被广泛应用于收集表单数据，在HTMLform标签的指定该属性：&quot;method=&quot;get&quot;。$_GET也可以收集URL中发送的数据。 从带有 GET 方法的表单发送的信息，对任何人都是可见的（会显示在浏览器的地址栏） 并且对发送信息的量也有限制。 $_FILES $_ENV $_COOKIE $_SESSION PHP魔术变量 __LINE__：文件中的当前行号。 __FILE__：文件的完整路径和文件名。 __DIR__：文件所在的目录。 __FUNCTION__：函数名称。 __CLASS__：类的名称。 __TRAIT__：trait的名称。 __METHOD__：类方法的名称。 __NAMESPACE__：命名空间的名称。 XSS又叫 CSS (Cross-Site Script) 跨站脚本攻击。恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。 正则 邮箱：/([\\w\\-]+\\@[\\w\\-]+\\.[\\w\\-]+)/ URL：/\\b(?:(?:https?|ftp):\\/\\/|www\\.)[-a-z0-9+&amp;@#\\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\\/%=~_|]/i 只有字母和空格：/^[a-zA-Z ]*$/ Get 与 Post何时用method=”get”？ 在 HTML 表单中使用 method=”get” 时，所有的变量名和值都会显示在 URL 中。 注释：所以在发送密码或其他敏感信息时，不应该使用这个方法！ 然而，正因为变量显示在URL中，因此可以在收藏夹中收藏该页面。在某些情况下，这是很有用的。 注释：HTTP GET 方法不适合大型的变量值。它的值是不能超过 2000 个字符的。 何时用method=”post”？ 从带有 POST 方法的表单发送的信息，对任何人都是不可见的，并且对发送信息的量也没有限制。 然而，由于变量不显示在 URL 中，所以无法把页面加入书签。","tags":[{"name":"PHP,笔记","slug":"PHP-笔记","permalink":"http://yoursite.com/tags/PHP-笔记/"}]},{"title":"JavaScript调试","date":"2017-11-16T10:38:42.000Z","path":"2017/11/16/JavaScript调试/","text":"本文就想总结一些调试的方法，其实调试是提高效率的重要方法之一，会用正确高效的调试方法，可以事半功倍。 1、最常用console.log（简单数据输出） 这就没有什么好解释的，不过输出也是有技巧的，那就是要格式化，简单说就是要有标志性，只有数据或许会让人不理解，最好是加上前缀 123// exampleconsole.log(&quot;fun&apos;s result---&quot; + fun(2));console.log(&quot;value of a---&quot; + a); 当然可以改变颜色和字体等 2、debugger：断点 与console.log相比，debugger会在执行的过程中停在你想的地方，能够更加直接的看到执行过程。 3、将对象以表格的形式展示console.table() 将对象强制用表格打出来，这样展开的对象键值对应更加清晰 注意firefox有限制，最多显示1000行 4、尝试适配各种机型屏幕大小 这个对开发手机页面很有帮助 其次是可以检查布局问题 5、如何快速找到对应的DOM元素 方法1浏览器的快速选择工具 方法2是通过参数访问，浏览器有将DOM元素进行编号，可以通过$x的方式去访问。（具体后续补充） 6、使用console.time()和console.timeEnd()来记录时间 关注函数运行的时间是提高效率的方法之一 获取某个函数的Stacktrace console.trace() 向Web控制台输出一个堆栈跟踪 将minify的代码还原 {} 快速定位需要debug的函数 debug(funName) 会在执行函数的地方停下来 屏蔽不相关的脚本 注释掉 查看某个函数调用和其参数 monitor(funName) Postman很好用，不过传说Firefox更快 但由于本人喜欢用chrome，所以没有用尝试firefox","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"域名的购买和绑定","date":"2017-11-15T09:42:30.000Z","path":"2017/11/15/域名的购买和绑定/","text":"终于下定决心，自己在阿里云上购买了域名，开始将自己的博客放到一个更大的“池塘”里面了，之后的学习，希望自己能继续坚持。 购买域名 前期翻看了很多关于在哪里购买域名的博文，最后还是决定就在阿里云买了，原因如下：（其实很早就想买了，但是之前还是觉得自己技术不成熟吧，买了也是浪费，不过现在觉得，买了就有更大的动力学习了） 为了让自己的博客更有识别度 作为一个新手，阿里云的性能已经很够用了 价格一般，作为大学生，还是能负担 阿里云在国内也算有名了吧 购买方法很简单啊，只要去官网就好了阿里云 域名绑定 之前自己的博客是挂在github上面直接用的免费的github pages，为了更有识别度，便买了域名，因为还没有购买服务器，（准备在接下来一年内完成这任务）所以之后项目还是会放在github上。 因此这样的话，绑定域名就很简单了。 域名的解析，在阿里云的后台管理进行如下设置 然后是github项目的重定向 用过github pages的都知道，github赠送的域名是yourgithubname.github.io，而我们现在要做的就是将这个页面重定向到我们申请的域名上去 方法如下： 方法1. 直接更改项目设置中的pages设置，如图： 方法2.在项目的根目录中新建一个CNAME文件，文件的内容就是我们申请的域名： 最后就是等待了（时间长短不定，本人感觉并没有等很久），就可以通过我们自己申请的域名访问项目页面了。","tags":[{"name":"域名","slug":"域名","permalink":"http://yoursite.com/tags/域名/"}]},{"title":"学习PHP之环境搭建","date":"2017-09-30T04:02:08.000Z","path":"2017/09/30/学习PHP之环境搭建/","text":"搭建本地服务器 注：因为搭建的是本地的服务器，所以只有自己的电脑开着的时候，才能访问到。 一、注册域名 这是一个免费域名的注册地址www.noip.com，这种网站有很多，只是本人用的这一个，可自由选择。 注册登录即可。（一个简单的域名注册申请，就不再赘述了） 根据自己的ip注册后的结果是这样（要特别注意的是ip地址的填写，不知道自己此刻的ip地址可以用命令行查询；此处的ip地址会根据你使用的网络而改变）： 二、架构包的安装 下载架构包（架构包当然也有很多种，本人使用的是链接中的这个）AppSever8.6.0 安装架构包（跟着流程走就好了，规则就是两个键按左边，三个键按中间，一个键就只能按它咯~）注意安装目录的选择！安装完之后，会有一个这样的目录： 测试：在浏览器地址栏中输入你之前申请的并且与ip地址对应的域名，当看到以下结果，说明你ok了，否则请从头开始=_=（嘿嘿，有问题肯定是某个步骤出了问题，仔细检查）： 此处显示的是，文件夹www中的index.php文件 当然我们希望这些关于服务器的各种信息只有我们自己能看到，而别人看不到，很简单，将文档的名字改成只有你自己知道就好了: 既然index文件已经被我们改掉了，因此可以开始写第一个index文件了，此刻网页会自动显示该文件（之后就可以开始写自己的网页了）： 123456789101112// index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p style=&quot;font-size: 50px;color: #66ccff;&quot;&gt;啦啦啦&lt;/p&gt; &lt;p style=&quot;font-size: 40px;color: red&quot;&gt;完了&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"PHP, 学习","slug":"PHP-学习","permalink":"http://yoursite.com/tags/PHP-学习/"}]},{"title":"画地为牢","date":"2017-08-04T01:16:39.000Z","path":"2017/08/04/画地为牢/","text":"作用域 它是一套规则，这套规则用来管理引擎如何在当前作用域及嵌套的子作用域中根据标识符名称进行变量的查找。 1234if(true) &#123; var num = 10;&#125;console.log(num); 思考：JavaScirpt怎样才会形成作用域？ 函数作用域 就是说，在JavaScript中，在函数里面定义的变量，可以在函数里面被访问，但是在函数外无法访问。 1234var func = function() &#123; var num = 10;&#125;;console.log(num); 1234var func = function() &#123; var num = 10; console.log(num);&#125;; 前面说了，函数可以限定变量的作用域，那么在函数中的函数就成为该作用域的子域。在子域中的代码可以访问到父域中的变量。 12345678var func = function() &#123; var num = 10; var sub_func = function() &#123; console.log(num); &#125;; sub_func();&#125;;func(); 123456789var func = function() &#123; var num = 10; var sub_func = function() &#123; var num = 20; console.log(num); &#125;; sub_func();&#125;;func(); 由此可见访问有一定规则可言。在JavaScript中使用变量，JavaScript解释器首先在当前作用域中搜索是否有该变量的定义，如果有，就是用这个变量；如果没有就到父域中寻找该变量。以此类推，直到最顶级作用域，仍然没有找到就抛出异常”变量未定义”。 123456789(function() &#123; var num = 10; (function() &#123; var num = 20; (function()&#123; console.log(num); &#125;)() &#125;)();&#125;)(); 块级作用域 思考：什么叫块级作用域？ 123456789function outputNumbers(count)&#123; for (var i=0;i&lt;count;i++)&#123; console.log(i); &#125; console.log(i) var i; console.log(i);&#125;outputNumbers(3); 很遗憾，在es6之前，javascript是没有块级作用域的。所以也会因此造成对一些变量值的忽视，从而引起程序运行结果不对。那前辈们遇到这个问题是怎么做的呢？让我们来考考古。 利用函数来实现块级作用域 因为函数是js里唯一具有块级作用域特点的。 123456789function outputNumbers(count)&#123; (function()&#123; for (var i=0;i&lt;count;i++)&#123; console.log(i); &#125; &#125;)(); console.log(i);&#125;outputNumbers(3); 思考：这是不是一个闭包？ 方法类（不建议使用）with 用with从对象创建出的作用域仅在with声明中而非外部作用域中有效。1234567891011121314151617function foo(obj) &#123; with (obj) &#123; var a = 2; &#125;&#125;var o1 = &#123; a: 3&#125;;var o2 = &#123; b: 3&#125;;foo( o1 );console.log( o1.a );foo( o2 );console.log( o2.a );console.log( a ); try/catch1234567try&#123; undefined();//执行一个非法操作来强制制造一个异常&#125;catch(err)&#123; console.log(err)//能够正常执行&#125;console.log(err); ES6中的块级作用域 将代码在函数中隐藏的信息扩展为在块中隐藏起来。 let(不能重复声明) let关键字可以将变量绑定到所在的任意作用域中。 垃圾回收 12345678function process(data)&#123; //在这里做点有趣的事情&#125;&#123;//在这个块中定义的内容完事可以销毁 let someReallyBigData=&#123;...&#125;; process(someReallyBigData);&#125; let循环 1234for(let i=0;i&lt;10;i++)&#123; console.log(i);&#125;console.log(i); const（不能重复声明） 定义一个该块的常量，不能修改值。 12345678910var foo = true;if (foo) &#123; var a = 2; const b = 3; a = 3; b = 4;&#125;console.log(a);console.log(b); 作用域链 因为作用域是一套用于确定在何处以及如何查找变量的规则，我对作用域链的理解就是查找变量所走的路。 建筑 根据这个图来理解，就是查找变量所爬的楼。 树 爬楼太累了，我们再看看用画树的方法再来看看。 绘制规则 作用域链就是对象的数组 全局作用域是0级链，每个对象占一个位置 凡是看到函数延伸一个链出来，一级级展开 访问首先看当前函数，如果没有定义往上一级链检查 如此往复，直到0级链 123456789101112131415161718var num = 10;var func1 = function() &#123; var num = 20; var func2 = function() &#123; var num = 30; console.log(num); &#125;; func2();&#125;;var func2 = function() &#123; var num = 20; var func3 = function() &#123; console.log(num); &#125;; func3();&#125;;func1();func2(); 现场绘制一波 预解析 形成变量提升现象1234567var num = 10;var func = function() &#123; console.log(num); var num = 20; console.log(num);&#125;;func(); 函数提升12345678910var func = function() &#123; console.log(&quot;调用外面的函数&quot;);&#125;;var foo = function() &#123; func(); var func = function() &#123; console.log(&quot;调用内部的函数&quot;); &#125;; func();&#125;; 预解析：在当前作用域下,js运行之前，会把带有var和function关键字的事先声明，并在内存中安排好，然后再从上到下执行js语句。预解析只会发生在通过var定义的变量和function上。 var 只要是通过var定义的，不管是变量，还是函数，都是先赋值undefined，如果是变量，也不管变量有没有赋值，在预解析阶段，都是会被赋值为undefined。 function function进行预解析的时候，不仅是声明而且还定义了，但是它存储的数据的那个空间里面存储的是代码是字符串，没有任何意义。 123function fun() &#123; //代码区&#125;(); 定义一个函数想要立即执行，写成上面的形式是不可行的，在预解释的时候，它把它分解成两部分来对待，第一部分是fun函数，而第二部分是(),一个匿名函数，执行时会报错。如果小括号带参数，如(2)，虽然不会报错，会打印出来2，但并不能把fn执行，也不能当成参数传递给fn函数。 如果你想实现立即执行的函数，可以把要执行的函数放到一对括号里面，对于JavaScript 来说，括弧()里面不能包含语句，所以在这一点上，解析器在解析function关键字的时候，会将相应的代码解析成function表达式，而不是function声明所以，只要将大括号将代码(包括函数部分和在后面加上一对大括号)全部括起来就可以了。 如下： 123(function fun() &#123; //代码区&#125;()); 预解析是发生在当前作用域下的，刚开始的时候，我们预解析的是全局作用域，在js中我们的global就是我们的window。 我们运行函数的时候会生成一个新的私有作用域（每次执行都是新的，执行完成就销毁）这个作用域下我们可以理解为开辟了一个新的内存空间。在这个内存中我们也要执行预解析。当我们的函数执行完成后，这个内存或者作用域就会销毁。 如果在当前作用域下的一个变量没有预解析，就会向它的上一级去找，直到找到window，如果window下也没有定义，就会报错。所以，在函数内通过var定义的变量是局部变量，没有通过var定义的变量是全局变量。 预解析不会在同一个变量上重复的发生，也就是一个变量如果已经在当前作用域下预解析了，不会再重复解析。 等号右边的function不会进行预解析。 预解释是不受其它if或者其它判断条件影响的，也就是说，即使条件不成立，我们里面只要有var或者function也会被预解释。 后面定义的会覆盖前面定义的。 一些例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 例子一if(!(&quot;a&quot; in window))&#123; var a = &quot;李玉华&quot;；&#125;console.log(a);// 例子二function fn()&#123; console.log(&quot;我们是全局的fn&quot;);&#125;function fn2()&#123; console.log(fn); fn = 3; return ; function fn()&#123; console.log(&quot;我是fn2里面的&quot;); &#125;&#125;fn2();// 例子三var n = 0;function a()&#123; var n = 10; function b()&#123; n++; console.log(n); &#125; b(); return b;&#125;var c = a(); c(); console.log(n); // 例子四var n = 99;function outer()&#123; var n = 0; return function inner()&#123; return n++; &#125;&#125;var c = outer(); var num1 = c();var num2 = c();var d = outer();var num3 = d();console.log(c);console.log(num1);console.log(num2);console.log(d);console.log(num3); 总结 作用域就是根据标识符查找变量的一套规则。（路标） 作用域链就是找变量所走的路径。 预解析就是万恶的“VIP”。 注： ReferenceError作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。 参考链接 作用域和作用域链 块级作用域 作用域和原型","tags":[{"name":"分享,作用域,作用域链,预解析","slug":"分享-作用域-作用域链-预解析","permalink":"http://yoursite.com/tags/分享-作用域-作用域链-预解析/"}]},{"title":"作用域和原型","date":"2017-08-02T11:29:16.000Z","path":"2017/08/02/作用域和原型/","text":"作用域什么是作用域？ 它是一套规则，这套规则用来管理引擎如何在当前作用域及嵌套的子作用域中根据标识符名称进行变量的查找。 先介绍一下RHS和LHS 这是引擎的两种查找类型 “R”和“L”分别代表赋值操作的右侧和左侧 案例 123456function foo(a)&#123;//对a进行LHS引用2 console.log(a); //对console进行RHS引用3 //对a进行RHS引用4&#125;foo(2);//对foo进行RHS引用1 当变量还没有声明的时候（在任何作用域都找不到该变量），这两种查询的行为是不一样的：LHS查询会在全局作用域中自己创建一个变量。RHS查询会抛出一个ReferenceError错误。 作用域的嵌套 当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。这一就形成了一条作用域链。 案例 12345function foo(a)&#123; console.log(a+b);&#125;var b=2;foo(2);//4 将作用域链比喻成一个建筑 词法作用域 词法作用域是由你写代码时将变量和块作用域写在哪里来决定的。 案例 JavaScript中有两个机制可以“欺骗”词法作用域 eval() 例子： 123456789101112131415function foo(str, a) &#123; eval( str ); // 欺骗！ console.log( a, b );&#125;var b = 2;foo( &quot;var b = 3;&quot;, 1 );//严格模式// function foo(str) &#123;// &quot;use strict&quot;;// eval( str );// console.log( a ); // ReferenceError: a is not defined// &#125;foo( &quot;var a = 2&quot;); with() 例子： 123456789101112131415161718function foo(obj) &#123; with (obj) &#123; var a = 2; &#125; // a = 2;&#125;var o1 = &#123; a: 3&#125;;var o2 = &#123; b: 3&#125;;foo( o1 );console.log( o1.a );foo( o2 );console.log( o2.a );console.log( a ); 函数作用域 在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。 案例 1234567var a=2;function foo()&#123; var a=3; console.log(a);//3&#125;foo();console.log(a);//2 不足之处： 必须声明一个foo函数，这个foo“污染”了所在作用域。 必须显示调用才能运行其中的代码 改进 1234567var a=2;(function foo()&#123; var a=3; console.log(a);//3&#125;)();console.log(a);//2//函数会被当作函数表达式而不是一个标准的函数声明来处理。 匿名函数 优点： 书写起来简单快捷 缺点： 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。 如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用。（callee是arguments对象的一个属性。它可以用于引用该函数的函数体内当前正在执行的函数。） 匿名函数省略了对于代码可读性/可理解性很重要的函数名。 立即执行函数表达式 IIFE(Immediately Invoked Function Expression)：(function foo(){...})() 函数名对IIFE来说不是必须的：(function(){...}()) 进阶用法：当作函数调用并传参数进去。 例子：12 块作用域 块作用域将代码在函数中隐藏的信息扩展为在块中隐藏起来。 思考 12345for(var i=0;i&lt;10;i++)&#123; console.log(i);&#125;console.log(i);//为什么要把一个只在for循环内部使用（至少是应该只在内部使用）的变量i“污染”到整个作用域（不管是函数还是全局）中？ with：用with从对象创建出的作用域仅在with声明中而非外部作用域中有效。 try/catch：例子：try.html let：let关键字可以将变量绑定到所在的任意作用域中。 垃圾回收 12345678function process(data)&#123; //在这里做点有趣的事情&#125;&#123;//在这个块中定义的内容完事可以销毁 let someReallyBigData=&#123;...&#125;; process(someReallyBigData);&#125; let循环 1234for(let i=0;i&lt;10;i++)&#123; console.log(i);&#125;console.log(i);ReferenceError const：定义一个该块的常量，不能修改值。例子： 12345678var person = function(name)&#123; this.name = name&#125;;person.prototype.getName = function()&#123; console.log(this.name);&#125;var zjh = new person(&apos;zhangjiahao&apos;);zjh.getName(); //zhangjiahao 原型[prototype]普通对象和函数对象 JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象。 123456789101112131415161718var o1 = &#123;&#125;; var o2 =new Object();var o3 = new f1();function f1()&#123;&#125;; var f2 = function()&#123;&#125;;var f3 = new Function(&apos;str&apos;,&apos;console.log(str)&apos;);console.log(typeof Object); //function console.log(typeof Function); //function console.log(typeof f1); //function console.log(typeof f2); //function console.log(typeof f3); //function console.log(typeof o1); //object console.log(typeof o2); //object console.log(typeof o3); //object 怎么区分，其实很简单，凡是通过new&nbsp;Function()创建的对象都是函数对象，其他的都是普通对象。f1,f2,归根结底都是通过new&nbsp;Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的。 什么是prototype？ 在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype属性，这个属性指向函数的原型对象。 12345678910111213141516function Person() &#123; Person.prototype.name = &apos;Zaxlct&apos;; Person.prototype.age = 28; Person.protetype.job = &apos;Software Engineer&apos;; Person.prototype.sayName = function() &#123; alert(this.name); &#125;&#125;var person1 = new Person();person1.sayName(); // &apos;Zaxlct&apos;var person2 = new Person();person2.sayName(); // &apos;Zaxlct&apos;console.log(person1.sayname == person2.sayname); //true 只有函数对象才有 prototype 属性 什么是原型对象？ 原型对象，顾名思义，它就是一个普通对象。从现在开始你要牢牢记住原型对象就是 Person.prototype，如果你还是记不住，那就把它想想成一个字母 A： var A = Person.prototype; 12345678Person.prototype = &#123; name: &apos;Zaxlct&apos;, age: 28, job: &apos;Software Engineer&apos;, sayName: function() &#123; alert(this.name); &#125;&#125; 在默认情况下，所有的原型对象都会自动获得一个constructor（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数（Person） 原型对象（Person.prototype）是 构造函数（Person）的一个实例。 那原型对象是用来做什么的呢？举个例子： 12345678var person = function(name)&#123; this.name = name&#125;;person.prototype.getName = function()&#123; return this.name;&#125;var zjh = new person(‘zhangjiahao’);zjh.getName(); //zhangjiahao 从这个例子可以看出，通过给person.prototype设置了一个函数对象的属性，那由person实例（例中：zjh）出来的普通对象就继承了这个属性。所以原型对象的主要作用就是用于继承。 具体是怎么实现的继承，就要讲到下面的原型链了。 什么是原型链？ JS在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做__proto__的内置属性，用于指向创建它的函数对象的原型对象prototype。例如： console.log(zjh.__proto__ === person.prototype) //true 同样，person.prototype对象也有__proto__属性，它指向创建它的函数对象（Object）的prototype console.log(person.prototype.__proto__ === Object.prototype) //true 继续，Object.prototype对象也有__proto__属性，但它比较特殊，为null console.log(Object.prototype.__proto__) //null 我们把这个有proto串起来的直到Object.prototype.proto为null的链叫做原型链。 注 ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。 区分函数声明和表达式最简单的方法是看function关键字出现在声明这哦那个的位置（不仅仅是一行代码，而是整个声明中的位置）。如果function是在声明的第一个词，那么就是一个函数声明，否则就是一个函数表达式。 作用域理解基于《你不知道的Javascript 上卷》 原型理解基于文章原型与原型链","tags":[{"name":"分享,javascript","slug":"分享-javascript","permalink":"http://yoursite.com/tags/分享-javascript/"}]},{"title":"JavaSccript语言精粹","date":"2017-07-20T07:01:07.000Z","path":"2017/07/20/JavaSccript语言精粹/","text":"知识点 字符串是不可变的。一旦被创建就永远无法改变。 typeof运算符产生的值有‘number’ ‘string’ ‘boolean’ ‘undefined’ ‘function’ ‘object’。 一个属性存取表达式用于指定一个对象或数值的属性或元素。 原型连接只有在检索值的时候才被用到。如果我们尝试弃获取对象的某个属性值，但该对象没有此属性名，那么JavaScript会试着从原型对象中获取属性值。如果那个原型对象也没有该属性，那么再从它的原型中寻找，依次类推，只到该过程最后到达终点Object.prototype。如果想要的属性完全不存在于原型练中，那么结果就是undefined值。这个过程为委托。 用for in的方法来遍历一个对象中的所有属性名，属性名出现的顺序是不确定的，因此要对任何可能出现的顺序有所准备。若想自定义顺序最好的方式是避免使用for in，而是通过建立数组的形式将属性存入，然后用for循环从数组中依次获取属性。这样也不用担心可能发掘出原型链中的属性，并且我们按正常的顺序取得了它的值。 最小化使用全局变量的方法之一是为你的应用只创建一个唯一的全局变量。资源都纳入一个名称空间之下，你的程序与其他应用程序、组件或类库之间发生冲突的可能性就会显著降低。 函数对参数值不会进行类型检查：任何类型的值都可以被传递给任何参数。 apply方法让我们构建一个参数数组传递给调用函数。 因为语言的一个设计错误，arguments并不是一个真正的数组。它只是一个“类似数组（array-like）”的对象。arguments拥有一个length属性，但它没有任何数组的方法。 尾递归是一种在函数的最后执行递归调用语句的特殊形式的递归。 作用域的好处是内部函数可以访问定义它们外部函数的参数和变量（除了this和arguments）。 继承的两种服务： 是代码重用的一种形式。（如果一个新的类与一个已经存在的类大部分相似，那么你只需要具体说明其不同点即可。代码重用的模式极为重要，因为它们可以显著的减少软件开发的成本。） 另一个好处是引入了一套类型系统的规范。（由于程序员无需编写显式类型转换的代码，他们的工作量将大大减轻，这是一件很好的事情，因为类型转换会丧失类型系统在安全上的优势。） 构造一个生成对象的函数： 1.创建一个新的对象。 2.有选择地定义私有的实例变量和放方法。 3.给这个新对象扩充方法。 4.返回那个新对象。 数组的length属性的值是这个数组的最大整数属性名加上1，它不一定等于数组里属性的个数。 for in 用来遍历数组的所有属性，但遗憾的是，for in 无法保证属性的顺序。 数组和对象的使用区别：当属性名是小而连续的整数时，你应该使用数组；否则，使用数组。 排序的稳定性是指排序后的数组中相等值的相对位置没有发生改变，而不稳定性排序则会改变相等值的相对位置。 方法篇Array array.concat(item…):产生新的数组，和它类似功能的array.push(item)。 array.join(separator):把一个array构造成一个字符串。 array.pop():移除数组的最后一个元素，并返回这个元素。 array.push(item…):把一个或多个参数item附加到一个数组的尾部。 array.reverse():反转array里的元素的顺序，并返回array本身。 array.shift():移除数组array中的第一个元素，并返回该元素。 array.slice(start,end):对array中的一段做浅复制。 array.sort(comparefn):对array中的内容进行排序。 array.splice(start,deleteCount,item…):从array中移除一个或多个元素，并用新的item替换它们。 array.unshift(item…):像push方法一样，用于把元素添加到数组中，但它是把item插入到array的开始部分，不是尾部。返回array的新的length。 Function function.apply(thisArg,argArray):调用function，传递一个会被绑定到this上的对象和一个可选的数组作为参数。 Number number.toExponential(fractionDigits):把这个number转换成一个指数形式的字符串。 number.toFixed(fractionDigits):把这个number转换成为一个十进制数形式的字符串。可选择参数控制其小数点后的数字位数。 number.toPrecision(precision):把这个number转换成一个十进制数形式的字符串。可选择参数控制数字的精度（0~21）。 number.toString(radix):把这个number转换成字符串。可选择参数控制基数（2~36，默认是10）。 Object object.hasOwnProperty(name):判断属性是否存在，不会检查原型链中的同名属性。 RegExp regexp.exec(string):最强大（和最慢），看书理解。 regexp.test(string):最简单（和最快），匹配就返回true，否则返回false，不要对这个方法使用g标识。 String string.charAt(pos):返回在string中pos位置处的字符。 string。charCodeAt(pos):返回在string中pos位置的字符的字符码位（以整数形式表示）。 string.conecat(string…):把其他的字符串连接在一起来构造一个新的字符串。 string.indexOf(searchString,postion):在string中查找另一个字符串searchString。找到就返回第一个匹配字符的位置，否则返回-1。可选参数position从字符串的哪个位置开始查找。 string.lastIndexOf(searchString,position):从字符串的末尾开始查找。 string.lacaleCompare(that):比较两个字符串。 string.match(regexp):让字符串和一个正则表达式进行匹配。 string.replace(searchValue,replaceValue):对string进行查找和替换操作，并返回一个新的字符串（如果searchValue不是一个带有g标识的正则表达式那就只会替换第一个）。 string.search(regexp):接收一个正则表达式作为对象参数返回匹配的首字符位置。 string.slice(start,end):复制string的一部分来构造一个新的字符串。 string.split(separator,limit):把这个string分割成片段来创建一个字符串数组。 string.substring(start,end):和slice方法一样，只是他不能处理负数参数。 string.toLocaleLowerCase():返回一个新字符串，使用本地化的规则将这个string中所有字母转换成小写格式。 string.toLacaleUpperCase():返回一个新字符串，使用本地化的规则将这个string中所有字母转换成大写格式。 string.toLowerCase():返回一个新的字符串，这个string中所有字母都被转换为小写格式。 string.toUpperCase():返回一个新的字符串，这个strnig中所有字母都被转换为大写格式。 string.fromCharCode(char…):函数根据一串数字编码返回一个字符串。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"vue2.0生命周期","date":"2017-06-02T02:03:58.000Z","path":"2017/06/02/vue2-0生命周期/","text":"图解 函数解释 beforeCreate在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。 created实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount在挂载开始之前被调用：相关的 render 函数首次被调用。 mountedel 被新创建的vm.\\$el替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 beforeUpdate数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 updated由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 beforeDestroy实例销毁之前调用。在这一步，实例仍然完全可用。 destroyedVue 实例销毁后调用。调用后，Vue实例指示的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/vue/2.1.3/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message : &quot;Hello!&quot; &#125;, beforeCreate: function () &#123; console.group(&apos;beforeCreate 创建前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot; , &quot;el : &quot; + this.$el); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) &#125;, created: function () &#123; console.group(&apos;created 创建完毕状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, beforeMount: function () &#123; console.group(&apos;beforeMount 挂载前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + (this.$el)); //已被初始化 console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, mounted: function () &#123; console.group(&apos;mounted 挂载结束状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); //已被初始化 console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, beforeUpdate: function () &#123; console.group(&apos;beforeUpdate 更新前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, updated: function () &#123; console.group(&apos;updated 更新完成状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, beforeDestroy: function () &#123; console.group(&apos;beforeDestroy 销毁前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, destroyed: function () &#123; console.group(&apos;destroyed 销毁完成状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用浏览器打开 beforecreated：el 和 data 并未初始化created:完成了 data 数据的初始化，el没有beforeMount：完成了 el 和 data 初始化mounted ：完成渲染 关于更新app.message= &#39;vue&#39;; 关于销毁app.$destroy(); 销毁完成后，我们再重新改变message的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在。可以这么理解，执行了destroy操作，后续就不再受vue控制了。 生命周期函数的一些用法 beforecreate : 举个栗子：可以在这加个loading事件created ：在这结束loading，还做一些初始化，实现函数自执行mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情beforeDestory： 你确认删除XX吗？destoryed ：当前组件已被删除，清空相关内容","tags":[{"name":"vue,javascript,分享","slug":"vue-javascript-分享","permalink":"http://yoursite.com/tags/vue-javascript-分享/"}]},{"title":"坎帕斯学院日常讨论","date":"2017-04-16T08:14:15.000Z","path":"2017/04/16/坎帕斯学院日常讨论/","text":"话题：width：100%和width：auto的区别 width：100% 元素宽度等于父级元素的宽度。 width：auto 元素的宽度等于父元素的宽度减去margin，padding，border这些。 高度知识点 子元素的margin和padding百分比知识点根据父元素的width来算。123456789101112131415161718192021222324//test1&lt;style&gt; body&#123; margin:0; padding:0; &#125; .main&#123; width:500px; background:red; &#125; .test&#123; width:auto; padding:20px; margin:10px; border:5px solid blue; background:green; &#125;&lt;/style&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;test&quot;&gt;123&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; test width=父元素width-margin-padding-border 123456789101112131415161718192021222324//test2&lt;style&gt; body&#123; margin:0; padding:0; &#125; .main&#123; display:inline-block; background:red; &#125; .test&#123; width:auto; padding:20px; margin:10px; border:5px solid blue; background:green; &#125;&lt;/style&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;test&quot;&gt;123123123123123&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; test width=123123123123123+margin+padding+border 1234567891011121314151617181920212223242526//test3&lt;style&gt; body&#123; font-size:20px; margin:0; padding:0; &#125; .main&#123; display:inline-block; background:red; width:500px; &#125; .test&#123; width:auto; padding:20px; margin:10px; border:5px solid blue; background:green; &#125;&lt;/style&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;test&quot;&gt;123123123123123&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; test width=500-padding-margin-border这里的500px并不是继承，而是因为div块级元素的影响而来的。 123456789101112131415161718192021222324252627//test4a&lt;style type=&quot;text/css&quot;&gt; body&#123; font-size: 20px; padding: 0; margin: 0; &#125; .first1&#123; background: red; width: 200px; height: 400px; overflow: hidden; &#125; .second1&#123; height: 25%;width: 25%; margin-top: 10%; background-color: green; padding-left: 10%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;first1&quot;&gt; &lt;div class=&quot;second1&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; test width=50,height=100,margin-top=20 2017.4.19 21:00话题：document.getElementByClassName()返回的是什么？ 是一个HTML集合。 集合和数组的区别 HTML集合：一直与文档保持着链接，每次你需要最新的信息时，都会重复执行查询的过程，哪怕只是获取集合里的元素个数，即集合的length属性也是这样。（简单的说就是这个集合会实时改变） 案例：12345var alldivs document.getElementsByTagName(&apos;div&apos;);for(var i=0;i&lt;alldivs.length;i++)&#123; document.body.appendChild(document.createElement(&apos;div&apos;));&#125;//该循环会一直循环下去，因为每次添加一个div之后，alldicvs.length的值也会改变，导致循环条件一直为true，一直循环。 关于闭包和词法作用域 案例：12345678910function foo()&#123; concile.log(a);//2&#125;function bar()&#123; var a=3; foo();&#125;var a=2;bar();//原理：js的运行原理是词法作用域，而非动态作用域，因此当foo函数被调用的时候，对a进行查询的时候会直接在全局作用域中查询。 话题：display：none和visibility：hidden区别？ display：none；有dom树，没有渲染树，也就是说js可以找到display：none。 visibility：hidden；只是将内容隐藏起来了，还是要占位的。 话题：两个inline-block元素在同一行中间的那个间距是多少？ 每个浏览器间距不同。 字体大小不同间距不同。 如何去掉这个空格？ 去掉最底层html标签的空格。 margin为负值。（每个浏览器不同，值不同） 将父级元素的字体大小设置为0。（推荐方案） 注意： 这个间距不仅在水平方向有，在垂直方向也有！ 距离大概是字体大小的1/8（可能会有叠加）。 inline-block元素之间，block和inline-block和inline的元素之间都有间距。","tags":[{"name":"记录，前端，问题，讨论","slug":"记录，前端，问题，讨论","permalink":"http://yoursite.com/tags/记录，前端，问题，讨论/"}]},{"title":"数组","date":"2017-04-10T11:13:22.000Z","path":"2017/04/10/数组/","text":"数组 Array创建实例1234567891011//用构造函数的方法var colors=new Array();var colors=new Array(20);var colors=new Array(&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;);var colors=Array();//可以省略new//用数组字面量表示法var colors=[&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;];var names=[];var values=[1,2,];//不要这样，这样会创建一个包含2或3项的数组var options=[,,,,,]//不要这样，这样会创建一个包含2或6项的数组 检测数组 Array.isArray()确定一个值到底是不是数组转换方法 toString()：返回有由数组中每个值得字符串形式拼接而成的一个以逗号分隔的字符串。 valueOf()：直接返回数组 toLocaleString()：创建一个数组值的以逗号分隔的字符串。 1234567891011121314151617181920212223242526var colors=[&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;];alert(colors.toString()); //gray,green,redalert(colors.valueOf()); //gray,green,redalert(colors); //gray,green,red//最后一行将数组传给alert，alert要求接受字符串，所以后台自动调用头String（）var person1=&#123; toLocaleString:function()&#123; return &quot;Nikolaos&quot;; &#125;, toString:function()&#123; return &quot;Nicholas&quot;; &#125;&#125;;var person2=&#123; toLocaleString:function()&#123; return &quot;Grigorios&quot;; &#125;, toString:function()&#123; return &quot;Greg&quot;; &#125;&#125;;var people=[person1,person2];alert(people); //Nicholas,Gregalert(people.toString()); //Nicholas,Gregalert(people.toLocaleString()); //Nicholas,Grigorios join()方法：可以用其他符号来分隔数组 123var colors=[&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;];alert(colors.join(&quot;,&quot;)); //gray,green,redalert(solors.join(&quot;||&quot;)); //gray||green||red 栈方法 push()方法可以接受任意数量的参数，把他们逐个添加到数组末尾，并返回修改后的数组的长度。 pop()方法则是从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。123456789101112131415var colors=new Array();var count=colors.push(&quot;red&quot;,&quot;green&quot;);alert(count); //2count=colors.push(&quot;black&quot;);alert(count); //3var item=color.pop();alert(item); //&quot;black&quot;;alert(colors.length); //2//可以将栈方法和其它数组方法连用var colors=[&quot;red&quot;,&quot;blue&quot;];colors.push(&quot;brow&quot;);colors.[3]=&quot;black&quot;;alert(colors.length); //4var item=colors.pop();alert(item); //&quot;black&quot; 队列方法 shift()方法能够移除数组中的第一项，并且返回该项，同时将数组长度减1。 unshift()方法能在数组前段端添加任意个项并返回数组长度。12345678var colors=new Array();var count=colors.push(&quot;red&quot;,&quot;green&quot;);alert(count); //2var item=colors.shift();alert(item); //&quot;red&quot;alert(colors.length); //1count=colors.unshift(&quot;black&quot;);alert(count); //2 排序 reverse()方法：反转数组项的顺序。返回值是数组。 sort()方法：按升序排列数字项。（比较的是字符串）返回值是数组。1234567891011121314151617181920var values=[1,2,3,4,5];values.reverse();alert(values); //5,4,3,2,1var values=[0,1,5,10,15];values.sort();alert(values); //0,1,10,15,5//在字符串进行比较的时候5是比10大的，这个时候我们经常让sort方法接受一个比较函数作为参考。//比较函数（升序，改变大于和小于就能变成降序）function campare(value1,value2)&#123; if(value1&lt;value2) return -1; else if(value1&gt;value2) return 1; else return 0;&#125;var values=[0,1,5,10,15];values.sort(campare);alert(values); //0,1,5,10,15 操作方法 concat()方法：创建一个新的数组。复制一遍数组并在末尾添上新的元素。 1234var colors=[&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;];var colors2=colors.contac(&quot;yellow&quot;,[&quot;black&quot;,&quot;brown&quot;]);alert(colors); //gray,green,redalert(colors2); //gray,green,red,yellow,black,brown slice()方法：能够基于当前数组中的一或多个项创建一个新数组。 当有一个参数时：返回从该参数指定位置开始到当前数组末尾的所有项。 如果有两个参数时：返回起始和结束位置之间的项，但不包括结束为止的项。 splice()方法：主要用途是项数组中部插入项。（最强大的数组方法） 删除：需要两个参数，位置和删除项数。例：splice(0,2);删除数组中的前两项。 插入：需要三个参数，起始位置，0（删除的项数）和插入项。例：splice(2,0,&quot;red,&quot;green&quot;)从数组的位置2开始插入字符串”red”和”green”。 替换：需要三个参数，起始位置，要删除的的项数和要插入的任意数量的项。例：splice(2，1，&quot;red&quot;,&quot;green&quot;)删除当前数组位置2的项，然后再从位置2开始插入字符串。位置方法 indexOf()方法：从数组的开头开始向后查找。 lastIndexOf()方法：从数组的末尾开始向前查找。两个方法都接收两个参数，要查找的项和开始查找的起始位置。没找到的情况返回-1，返回值是位置。123456789101112var numbers=[1,2,3,4,5,4,3,2,1];alert(numbers.indexOf(4)); //3alert(numbers.lastIndexOf(4)); //5alert(numbers.indexOf(4，4)); //5alert(numbers.lastIndexOf(4，4)); //3var person=&#123;name:&quot;Nicholas&quot;&#125;;var people=[&#123;name:&quot;Nicholas&quot;&#125;];var morePeople=[people];alert(people.indexOf(person)); //-1alert(morePeople.indexOf(peoson)); //0 迭代方法 every():对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true，否则返回false。 filter():对数组中的每一项运行给定函数，返回该函数会返回true的项组成数组。 forEach():对数组中的每一项运行给定函数，这个方法没有返回值。 map():对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some():对数组中的每一项运行给定函数，如果该函数对任意一项返回true，则返回true。以上方法都不会修改数组中包含的值。都接收三个参数：数组项的值，该项在数组的位置，数组对象本身。1234567891011121314151617181920212223242526272829//every()var numbers=[1,2,3,4,5,4,3,2,1];var everyResult=numbers.every(function(item,index,array)&#123; return (item&gt;2);&#125;);alert(everyResult); //false//some()var numbers=[1,2,3,4,5,4,3,2,1];var someResult=numbers.every(function(item,index,array)&#123; return (item&gt;2);&#125;);alert(someResult); //true//filter()var numbers=[1,2,3,4,5,4,3,2,1];var filterResult=numbers.every(function(item,index,array)&#123; return (item&gt;2);&#125;);alert(filterResult); //[3,4,5,4,3]//map()var numbers=[1,2,3,4,5,4,3,2,1];var mapResult=numbers.every(function(item,index,array)&#123; return item*2;&#125;);alert(mapResult); //[2,4,6,8,10,8,6,4,2]//forEach()var numbers=[1,2,3,4,5,4,3,2,1];numbers.forEach(function(item,index,array)&#123; //执行某些操作&#125;); 归并方法 reduce():从数组的第一个开始，逐个遍历到最后。 reduceRight():从数组最后一个开始，逐个遍历到第一个。 这两个函数接收两个参数：一个在每一项上的调用的函数和（可选的）作为归并基础的初始值。 传给两个函数的函数接收四个参数：前一个值，当前值，项的索引，数组对象。 函数的返回值都会作为第一个参数自动传给下一项。123456789101112//reduce()正向var values=[1,2,3,4,5];var sum=values.reduce(function(prev,cur,index,array)&#123; return prev+cur;&#125;);alert(sum); //15//ruduceRight()反向var values=[1,2,3,4,5];var sum=values.reduceRight(function(prev,cur,index,array)&#123; return prev+cur;&#125;);alert(sum); //15","tags":[{"name":"数组,前端,笔记","slug":"数组-前端-笔记","permalink":"http://yoursite.com/tags/数组-前端-笔记/"}]},{"title":"DOM知识点","date":"2017-04-10T11:07:45.000Z","path":"2017/04/10/DOM知识点/","text":"DOM D：document（文档）O：object（对象）：用户定义对象，内建对象，宿主对象M：model（模型）：“map”，树 节点 元素节点（element node）：body，ul，li……获取元素节点的方法： 通过元素id（getElementById ） 通过标签名（getElementsByTagName） 通过类名（getElementsByClassName） 属性节点（attribute node）&lt;p title=&quot;yang&quot;&gt;hahahahahahha&lt;/p&gt;title=”yang”是一个属性节点属性节点总是包含在元素节点中 文本节点获取和设置属性 getAttribute（获取） 12345//例子var paras=document.getElementsByTagName(&quot;p&quot;);for(var i=0;i&lt;paras.lengeh;i++)&#123; alert(paras[i].getAttribute(&quot;title&quot;));&#125; setAttribute（设置）若属性本不存在，实际就将完成两项操作：1.创建属性，2.设置值。注：并不会改变源文件扽静态内容。 123//例子var shopping=document.getElementById(&quot;purchases&quot;);shopping.setAttribute(&quot;title&quot;,&quot;a list of goods&quot;); 实例：JavaScript图片库 childNodes属性用来获取任何一个元素的所有子元素。 123456//获取body所有子元素个数的函数例子function countBodyChildren()&#123; var body_element=document.getElementsByTagName(&quot;body&quot;)[0]; alert(body_element.childNodes.length);&#125;window.onload=countBodyChildren; nodeType属性 元素节点的nodeType属性值是1。 属性节点的nodeType属性值是2。 文本节点的nodeType属性值是3。alert(body_element.nodeType); nodeValue属性得到和设置一个节点的值。alert(discription.nodeValue); firstChild和lastChild属性这两个属性都是为了个简便且直观的获取对应的元素。 注意点 DOM是一套对文档内容进行抽象和概念化的方法。 变量名中不能包含空格和标点符号（美元$符号除外）。 变量名允许包含字母，数字，美元符号和下划线（但第一个字符不能是数字）。 变量申明实例：my_mood或者myMood（峰驼式camel case：首选）。 Javascript是弱类型语言，不需要对变量进行类型声明。 变量可以包含操作。 字符串可以做拼接操作。 innerHTML属性和documen.write方法都是HTML的专有属性。var message=&quot;I am feeling&quot;+&quot;happy&quot;; 每个元素节点都是一个对象。","tags":[{"name":"DOM,JS,前端","slug":"DOM-JS-前端","permalink":"http://yoursite.com/tags/DOM-JS-前端/"}]},{"title":"BOM知识点","date":"2017-04-06T00:56:57.000Z","path":"2017/04/06/BOM知识点/","text":"BOM 一、window对象1.全局作用域 全局变量会变成window对象的属性。 全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性可以。 123456789var age=29;window.color=&quot;red&quot;;//在IE&lt;9时抛出错误，在其他所有浏览器中都返回falsedelete window.age;//在IE&lt;9时抛出错误，在其他所有浏览器中都返回truedelete window.color;//returns truealert(window.age);//29alert(window.color);//undefined 尝试访问未声明变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明变量是否存在。 窗口关系及框架 除非最高层窗口是通过window.open()打开的，否则其window对象的name属性不会包含任何值。 在使用框架的情况下，浏览器中会存在多个Global对象。 在每个框架中定义的全局变量会自动变成框架中window对象的属性。 由于每个window对象都包含原生类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应但并不相等。 窗口位置 screenLeft/screenTop:分别用于表示相对于屏幕左边和上边的位置。 screenY/screenX:提供相同的窗口位置属性。`` 12var leftPos=(typeof window.screenLeft==&quot;number&quot;)?window.screenLeft:window.screenX;var topPos=(typeof window.screenLeft==&quot;number&quot;)?window.screenTop:window.screenY; 注意：最终无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值。 moveTo()两个参数:移动到什么位置去。 moveBy()两个参数:向什么地方移动。两个函数不适用与框架，只能对最外层的window对象使用。 窗口大小 innerWidth/innnerHeight:返回浏览器本身的尺寸。 outerWidth/outerHeight:返回浏览器本身的尺寸。 document.documentElement.clientWidth/document.documentElement.clientHeight 12345678910111213var pageWidth=window.innerWidth; pageHeight=window.innerHeight;if(typeof pageWidth!=&quot;number&quot;)&#123; if(document.compatMode==&quot;CSS1Compat&quot;)&#123; //通过检查document.compatMode来确定页面是否处于标准模式 pageWidth=document.documentElement.clientWidth; pageHeight=document.documentElement.clientHeight; &#125; else&#123; pageWidth=document.body.clientWidth; pageHeight=document.body.clientHeight; &#125;&#125; resizeTo()两个参数:调整到。 resizeBy()两个参数:接受新窗口与原窗口的宽度和高度之差。两个函数不适用与框架，只能对最外层的window对象使用。 导航和打开窗口 window.open():既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。接收四个参数：1.要加载的URL 2.窗口目标 3.一个特定的字符串 4.一个表示新页面是否取代浏览器历史纪录中当前加载页面的布尔值方法会返回一个指向新窗口的引用。 1.打开窗口 2.安全限制 3.弹出窗口屏蔽程序 1234567891011121314var blocked=false;try&#123; var wroxWin=window.open(&quot;http://www.wrox.com&quot;, &quot;_blank&quot;); if(wroxWin==null)&#123; blocked=true; &#125;&#125;catch(ex)&#123; blocked=true;&#125;if(blocked)&#123; alert(&quot;The popup was blocked!&quot;);&#125; 在任何情况下，以上代码都可以检测出调用window.open()打开的弹出窗口是不是被屏蔽来了。但要注意的是，检测窗口是否被屏蔽只是一方面，它并不会阻止浏览器显示与被屏蔽的弹出窗口有关的消息。 间歇调用和超时调用 JavaScript是单线程语言，但它允许通过设置超时值和间歇值来调度代码在特定的时刻执行。 setTimeout(): 接受两个参数：1.要执行的代码（不建议传字符串，因为可能导致性能损失，建议用函数） 2.以毫秒表示的时间 该方法会返回一个数值ID，表示超时调用。这个超时调用ID是计划执行代码的唯一标识符，可以通过它来取消超时调用。 setInterval(): 与超时调用类似，但是它会按照指定的时间间隔重复执行代码，直到间歇调用被取消或者页面被卸载。 也接受两个参数：1.要执行的代码 2.以毫秒表示的时间 clearTimeout():取消超时调用或者间歇时间调用。 在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。所以，最好不要使用间歇调用。 一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。 123456789101112131415var num=0;var max=10;function incremenetNumber()&#123; num++; //如果执行次数尚未达到max设定的值，则设置另一次超时调用 if(num&lt;max)&#123; setTimeout(incrementNumber,500); &#125; else&#123; alert(&quot;Done!&quot;); &#125;&#125;setTimeout(incrementNumber,500); 系统对话框 alert():向用户显示一个系统对话框，其中包含一个制定的文本和一个OK（确定）按钮。 confirm():向用户显示“警告”对话框，返回true或者flase。 prompt():显示一个“提示”框，用于提示用户输入一些文本。接受两个参数：1.要显示给用户的文本提示 2.文本输入域的默认值。 window.find():显示“查询”对话框。 window.print():显示“打印”对话框。 二、location对象查询字符串参数 解析查询字符串的函数 1234567891011121314151617181920212223242526272829303132function getQueryStringArgs () &#123; // 解析查询字符串 //取得查询字符串并去掉开头的问号 var qs=(location.search.length&gt;0?location.search.substring(1):&quot;&quot;), //保存数据对象 args=&#123;&#125;, //取得每一项 items=qs.length?qs.sqlit(&quot;&amp;&quot;):[], item=null, name=null, value=null, //在for循环中使用 i=0, len=items.length; //逐个将每一项添加到args对象中 for (var i = 0; i &lt; len ; i++) &#123; item=items[i].sqlit(&quot;=&quot;); name=decodeURIComponent(item[0]); value=decodeURIComponent(item[1]); if (name.length) &#123; args[name]=value; &#125; &#125; return args;&#125; 位置操作改变浏览器的位置 assigned()：location.assign(&quot;http://www.wrox.com&quot;); location.href window.location replace()：让用户无法回到前一个页面，历史记录中不会生成新的记录。 raload()：作用是重新加载当前显示的页面。最好将其放在代码的最后一行。 三、navigation对象检查插件 检查插件 123456789101112131415161718192021222324252627282930313233//检查插件（在IE中无效）function hasPlugin (name) &#123; name=name.toLowerCase(); for (var i = 0; i &lt; navigator.plugins.length; i++) &#123; if (navigator.plugins[i].name.toLowerCase().indexOf(name)&gt;-1) &#123; return true; &#125; &#125; return false;&#125;//检测flash//alert(hasPlugin(&quot;Flash&quot;));//检测QuickTime//alert(hasPlugin(&quot;QuickTime&quot;));//检测IE中的插件function hasIEPlugin (name) &#123; try&#123; new ActiveXObject(name); return true; &#125; catch(ex)&#123; return false; &#125;&#125;//检测flash//alert(hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;));//检测QuickTime//alert(hasPlugin(&quot;QuickTime.QuickTime&quot;)); 注册处理程序 registerContentHandler()：接收三个参数：1.要处理的MIME类型。2.可以处理该MIME类型的页面的URL。3.应用程序的名称。 registerProtocolHandler()：接收三个参数：1.要处理的协议。2.处理该协议的页面的URL。3.应用程序的名字。 四、screen对象五、history对象 go() back() forward() lengh属性","tags":[{"name":"BOM,前端,笔记","slug":"BOM-前端-笔记","permalink":"http://yoursite.com/tags/BOM-前端-笔记/"}]},{"title":"动画和HTML5","date":"2017-03-23T06:33:24.000Z","path":"2017/03/23/动画和HTML5/","text":"用JavaScript实现动画效果 知识点 position属性： static：默认值，意思是有关元素将按照它们在标记里出现的先后顺序出现在浏览器窗口里。 relative：与static相似，区别是relative的元素还可以（通过应用float属性）从文档的正常显示顺序里脱离出来。 absolute：我们就可以将它摆在“容器”的任何位置。这个容器要么是文档本身，要么是一个有着fixed或absolute属性的父元素。这个元素在原始标记里面出现的位置与它显示位置无关，因为它的显示位置由top，left，right和bottom等属性决定。你可以使用像素或百分比为单位设置这些属性。 overflow属性： visible：不裁剪溢出内容。 hidden：隐藏溢出内容。 scroll：类似鱼hidden，浏览器将对溢出的内容进行隐藏，但显示一个滚动条以便让用户能够滚动看到内容的其他部分。 auto：类似于scroll，但浏览器只在确实发生溢出时才显示滚动条，如果没有溢出就不显示滚动条。时间 setTimeout：能够让某个函数在经过一段预定的时间之后才开始执行。 函数有两个参数：第一个是字符串，执行的函数名；第二个是数值，以毫秒为单位设定了需要经过多长时间才开始执行第一个参数所给出的函数。 setTimeout(&quot;function&quot;,interval) 在绝大多数情况下，将函数调用赋值给一个变量是一个好主意。 varible=setTimeout(&quot;function&quot;,interval) 取消某个正在排队等候执行的函数： clearTimeout(variable) HTML5video： currentTime：返回当前播放的位置，以秒表示； duration：返回媒体的总时长，以秒表示，对于流媒体返回无穷大； * paused：表示媒体是否处于暂停状态； 触发脚本的事件： play：在媒体播放开始时发生； pause：在媒体暂停是发生； loadeddata：在媒体可以从当前播放位置开始播放时发生； ended：在媒体已播放完成而停止时发生； 别忘了给&lt;video&gt;元素叫control属性： &lt;video src=&quot;movie.ogv&quot; control&gt; 表单：新的输入控件类型 email，用于输入电子邮件地址； url，用于输入URL； date，用于输入日期和时间； number，数值； ranger，生成滑动条； search，搜索框； tel，电话号码； color，选择颜色；新的属性 autocomplete，用于为文本（text）输入框添加一组建议的输入项； autofocus，让表单元素自动获得焦点； form，对标签外部的表单元素分组； min，max和step，用在范围（range）和数值（number）输入框中； pattern，定义一个正则表达式，以便验证输入的值； placeholder，在文本输入临时性的提示信息； required，表示必填；","tags":[{"name":"JS,动画,HTML5","slug":"JS-动画-HTML5","permalink":"http://yoursite.com/tags/JS-动画-HTML5/"}]},{"title":"JSON相关内容","date":"2017-03-22T15:02:31.000Z","path":"2017/03/22/JSON相关内容/","text":"JSON 知识点 JSON是一种数据结构，不是一种编程语言。 语法（三种类型的值） 简单值：使用JavaScript语法，可以在JSON中表示字符串、数值、布尔值和null，但不支持undefined。 字符串必须用双引号。 没有变量，没有分号。 对象：表示一组无序的键值对儿，每个键值对儿的值可以是简单值，也可以是复杂数据类型。 对象的属性必须加双引号。 没有声明，没有末尾的分号。 一个对象绝不能出项两个同名的属性。 数组：一组有序的值的列表，可以通过数值索引类访问其中的值，数组的值也可以是任意值。 没有变量，没有分号。 解析与序列化JSON可以将JSON数据结构解析为有用的JavaScript对象。 JSON对象 stringify()：将JavaScript对象序列化为JSON字符串。 parse()：将JSON字符串解析为原生的JavaScript值。 序列化选项 stringify()除了要序列化的JavaScript对象外，还可以接收两个参数，用于指定以不同的方式序列化JavaScript对象。一个是参数过滤器（可以是数组，可以是函数），第二个参数是选项，表示是否在JSON字符串中保存缩进。 如果是数组，就返回对象相应的属性。 如果是函数，返回值是undefined将会被忽略。 字符串缩进：第三个参数用于控制结果中的缩进和空白字符串。如果是数字就表示的是每个级别缩进的空格数。 toJSON()方法：（没看懂）。","tags":[{"name":"JSON，前端","slug":"JSON，前端","permalink":"http://yoursite.com/tags/JSON，前端/"}]},{"title":"css选择器、权重及优先级","date":"2017-03-21T07:11:22.000Z","path":"2017/03/21/css选择器、权重及优先级/","text":"遇到的问题 子元素使用padding会影响父元素。（解决方法是给父元素用padding） 背景图片的设置。（已解决） 分享会（胡小青）CSS选择器、权重及优先级选择器的种类 通配符选择器（＊） id选择器（#ID） 类选择器（.className） 标签选择器(E) 后代选择器（Ｅ Ｆ） 子元素选择器(E&gt;F) 相邻兄弟元素选择器(E + F) 群组选择器（selector1,selector2,…,selectorN） 交集选择器（E.className) 属性选择器 伪类选择器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//html&lt;div id=&quot;share&quot;&gt;id选择器&lt;/div&gt;&lt;div class=&quot;share&quot;&gt;类选择器&lt;/div&gt;&lt;div&gt; &lt;em&gt;标签选择器&lt;/em&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;后代选择器&lt;/p&gt; &lt;p&gt;&lt;span&gt;非直系后代&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;子元素选择器&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;相邻兄弟1&lt;/p&gt; &lt;span&gt;相邻兄弟2&lt;/span&gt;&lt;/div&gt;&lt;div&gt; &lt;h1&gt;群组选择器&lt;/h1&gt; &lt;h2&gt;群组选择器&lt;/h2&gt; &lt;h3&gt;群组选择器&lt;/h3&gt;&lt;/div&gt;//css*&#123; margin: 0; padding: 0;&#125;#share&#123; width: 200px; background: #cfd2d1;&#125;.share&#123; width: 200px; background: #e9eeec; margin-bottom: 10px;&#125;div.share &#123; border: 2px solid #000;&#125;em&#123; background: #f5f6f6;&#125;div p &#123; background: #e9eeec;&#125;div p span&#123; width: 200px; background: #acb1af;&#125;div &gt; p &#123; width: 200px; background: #adcec0;&#125;p + span &#123; width: 200px; background: #9d9e9e;&#125;h1,h2,h3 &#123; width: 200px; background: #afead2;&#125; 属性选择器 属性选择器 功能 E[att] 匹配所有具有att属性的E元素，不考虑它的值。 css2 E[att=val] 匹配所有att属性等于”val”的E元素 css2 E[att~=val] 匹配属性包含val的元素，并设置其样式：注意是val，所以val-ab这样不算 css2 E[att\\ =val] 匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以”val”开头的E元素，主要用于lang属性 css2 E[att^=val] 选择匹配的元素E，E定义了属性att,属性值以val开头的字符串 css3 E[arr$=val] 选择匹配的元素E，E定义了属性att,属性值以val结尾的字符串 css3 E[att*=val] 选择匹配的元素E，E定义了属性att,属性值包含val的字符串，也就是val可以在任意位置 css3 123456789101112131415161718192021222324252627282930//html&lt;a href=&quot;xxx.pdf&quot;&gt;我链接的是PDF文件&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;icon&quot;&gt;我类名是icon&lt;/a&gt;&lt;a href=&quot;#&quot; title=&quot;我的title是more&quot;&gt;我的title是more&lt;/a&gt;&lt;a href=&quot;#&quot; name=&quot;about&quot; lang=&quot;en-zhN&quot;&gt;选择含有about的元素&lt;/a&gt;&lt;a href=&quot;#&quot; name=&quot;about-ab&quot; lang=&quot;en&quot;&gt;选择含有about的元素&lt;/a&gt;&lt;a href=&quot;#&quot; name=&quot;about ab&quot;&gt;选择含有about的元素&lt;/a&gt;//cssa[href=&quot;xxx.pdf&quot;] &#123; border: 1px solid #000;&#125;a[href$=pdf]&#123; background: orange; color: #fff;&#125;a[class^=icon] &#123; background: #55e2a8; color:#fff;&#125;a[title*=more] &#123; background: #7a92e9; color: #fff;&#125;a[name~=about] &#123; background: #55e2a8;&#125;a[lang|=en] &#123; border: 1px solid #000;&#125; 伪类选择器 *动态伪类 锚点伪类 :link 链接访问前状态 :visited 链接访问后状态 :hover 鼠标悬浮链接的状态 :active 激活链接时的状态 伪类的顺序：link - visited -&gt; hover -&gt; active 用户行为伪类 :hover 用于当用户把鼠标移动到元素上面时的效果 :active 用于用户点击元素那一下的效果 :focus用于元素成为焦点，这个经常用在表单元素上 顺序： focus - &gt; hover -&gt; activeIE6下只有&lt;a&gt;支持:hover，IE6,7都不支持:focus、:active 1234567891011121314151617181920212223//html&lt;a href=&quot;#&quot; class=&quot;link&quot;&gt;link效果&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;visited&quot;&gt;visited效果&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;hover&quot;&gt;hover效果&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;active&quot;&gt;active效果&lt;/a&gt;&lt;input type=&quot;text&quot; name=&quot;&quot;&gt;//css.link:link &#123; background: pink;&#125;.visited:visited&#123; background: #cca;&#125;.hover:hover &#123; background: lightblue;&#125;.active:active &#123; background: lightgreen;&#125;input:focus &#123; outline: 2px solid red;&#125; UI元素状态伪类这类伪类主要针对form元素 伪类 功能 适用元素 :enabled 匹配表单中激活的元素 type=”text” :disabled 匹配表单中禁用的元素 type=”text” :checked 匹配表单中被选中的radio（单选框）或checkbox（复选框）元素 type=”radio” ::selection 匹配用户当前选中的元素 123input[type=&quot;radio&quot;]:disabled &#123; background-color: red;&#125; 结构伪类 :first-child* 选择某个元素的第一个子元素,IE6不支持； :last-child* 选择某个元素的最后一个子元素； :nth-child()* 选择某个元素的一个或多个特定的子元素，IE6-8，Firefox3.0不兼容； :nth-child(length)&ensp;&ensp;参数是具体数字 :nth-child(n)&ensp;&ensp;参数是n,n从0开始计算 :nth-child(nlength)&ensp;&ensp;n的倍数选择，n从0开始算 :nth-child(n+length)&ensp;&ensp;选择大于length后面的元素 :nth-child(-n+length)&ensp;&ensp;选择小于length前面的元素 :nth-child(nlength+1)&ensp;&ensp;表示隔几选一 123456789101112131415li:last-child &#123; background: #f9f57a;&#125;li:nth-child(2) &#123; background: #c8cac9;&#125;li:nth-child(2n) &#123; border: 3px solid red;&#125;li:nth-child(n+3) &#123; border: 3px solid yellow;&#125;li:nth-child(-n+3) &#123; border: 3px solid yellow;&#125; :nth-last-child()选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算，IE6-8，Firefox3.0不兼容； :nth-of-type()选择指定的元素,与nth-child类似也可以使用表达式，IE6-8，Firefox3.0不兼容； :nth-last-of-type()选择指定的元素，从元素的最后一个开始计算； :first-of-type选择一个上级元素下的第一个同类子元素，与first-child类似，不过是指定了元素类型； :last-of-type选择一个上级元素的最后一个同类子元素； :only-child选择的元素是它的父元素的唯一一个子元素，兼容到IE9； :only-of-type选择一个元素是它的上级元素的唯一一个相同类型的子元素，IE6-8，Firefox3.0不兼容； :empty选择的元素里面没有任何内容，兼容到IE9； :not()选择不匹配的元素，兼容到IE9； target 匹配文档中特定”id”点击后的效果，兼容到IE9。 1234567891011121314151617181920//html&lt;a href=&quot;#test&quot;&gt;test&lt;/a&gt;&lt;div&gt;第一个div&lt;/div&gt;&lt;p&gt;第一个p&lt;/p&gt;&lt;div id=&quot;test&quot;&gt;第二个div&lt;/div&gt;&lt;p&gt;第二个p&lt;/p&gt;&lt;p&gt;&lt;/p&gt;//cssdiv:not&#123; background-color: lightgrey;&#125;p:empty&#123; height:30px; width:30px; background:pink;&#125;div:target&#123; color:blue;&#125; 伪元素选择器 伪元素 功能 :first-line 匹配元素的第一行 :first-letter 匹配元素的第一个字母 :before 元素之前插入生成的内容 :after 元素之后插入生成的内容 :selecton 改变浏览网页选中文的默认效果 伪元素可以用::也可以用:关于first-letter使用条件比较苛刻，一般只有有兴趣可以参考深入CSS ::first-letter伪元素及其实例 123li::first-letter &#123; font-size: 56px;&#125; 伪类和伪元素的区别&gt; CSS 伪类用于向某些选择器添加特殊的效果。 CSS 伪元素用于将特殊的效果添加到某些选择器。两者都与选择器相关，可以添加一些“特殊”的效果。 区别：&ensp;&ensp;&ensp;&ensp;伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到 伪类 12345678910//html&lt;p&gt; &lt;i&gt;first&lt;/i&gt; &lt;i&gt;second&lt;/i&gt;+&lt;/p&gt;//cssp&gt;i:first-child &#123; color: red&#125; 伪类 :first-child 添加样式到第一个子元素如果我们不使用伪类，而希望达到上述效果，可以这样做： 12345678910//html&lt;p&gt; &lt;i class=&quot;first-child&quot;&gt;first&lt;/i&gt; &lt;i&gt;second&lt;/i&gt;&lt;/p&gt;//css.first-child &#123; color: red&#125; 我们给第一个子元素添加一个类，然后定义这个类的样式。 伪元素：1234567//html&lt;p&gt;I am stephen lee.&lt;/p&gt;//cssp:first-letter &#123; color: red&#125; 伪元素 :first-letter 添加样式到第一个字母那么如果我们不使用伪元素，要达到上述效果，我们可以这样做： 123//html&lt;p&gt; &lt;span&gt;I&lt;/span&gt; am stephen lee.","tags":[{"name":"笔记，分享，前端","slug":"笔记，分享，前端","permalink":"http://yoursite.com/tags/笔记，分享，前端/"}]},{"title":"FirstPassage","date":"2017-03-20T13:20:46.000Z","path":"2017/03/20/FirstPassage/","text":"第一篇博文（搭建博客的坑！！！） 1.关于Hexo nmp安装Hexo 打开命令行工具，执行如下命令： $ npm install -g hexo 创建文件夹 本人是直接在D盘创建了一个名叫blog的文件夹，在blog中创建了Hexo文件夹。（这个看个人喜好吧，用命令行也未尝不可。） 初始化 在Hexo目录下打开命令行工具，执行： hexo init 之后执行： hexo server 会看到： INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 访问：http://localhost:4000/就可以看到Hexo的初始页面了。 2.关于个人设置 基本信息 本人修改了title、subtitle、author的内容，如下： 1234567# Sitetitle: YangKunyi的博客subtitle: 爱看书的杨杨description:author: FrannieYilanguage:timezone: 第一个坑注意每一个冒号后面都有一个空格 无法生效的写法：title:Drubear的博客有效的写法：title:[空格]Drubear的博客 主题 知乎 - 好看的主题！ 使用git命令在github上clone下自己喜欢的主题，本人使用的是litten的yilia。 配置主题根据clone下来的主题将页面进行个性化设置。可以参考博主给的各种参数。 部署设置 只需简单的执行 hexo d But，重点来了前方巨坑请注意 首先在github上建立一个仓库，名字叫做：[你的用户名].github.io注意，你的用户名必须与你实际的用户名一字不差！ 拥有了个人的GitHubPages后，再回到Hexo的_config.yml文件，找到Deployment章节，做以下修改：（以FrannieYi为用户名为例）123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/FrannieYi/FrannieYi.github.io.git branch: master 以上两步做完后，执行 hexo d如果没有报错，你是幸运的。本人在这个坑里栽了无数次，系统报错 ERROR Deployer not found: Git 最后发现这个错误是因为少运行了一行代码： npm install hexo-deployer-git --save 运行完以上代码终于，本人泪流满面的看到了自己亲手搭建的博客。","tags":[{"name":"hexo,github","slug":"hexo-github","permalink":"http://yoursite.com/tags/hexo-github/"}]}]