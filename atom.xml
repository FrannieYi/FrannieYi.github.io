<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨坤怡</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yangkunyi.com/"/>
  <updated>2017-12-10T11:35:18.462Z</updated>
  <id>http://yangkunyi.com/</id>
  
  <author>
    <name>杨坤怡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WeeklyMind-3</title>
    <link href="http://yangkunyi.com/2017/12/10/WeeklyMind-3/"/>
    <id>http://yangkunyi.com/2017/12/10/WeeklyMind-3/</id>
    <published>2017-12-10T09:30:09.000Z</published>
    <updated>2017-12-10T11:35:18.462Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本周很日常，只是感觉自己有点缺乏锻炼，所以显得不是特别的精神，可能也和天气有关系，开始凉了，自己也没带什么厚衣服，所以没课都不怎么出门的那种。</p></blockquote><a id="more"></a><h4 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h4><ul><li>各科课程进行正常</li><li>但并没有完成本校作业</li><li>完成了第一次不动产小组报告，虽然内容很尬，但是表现自己还算满意</li><li>关于人际关系的人际圈，自己在课堂上画出不同的圈也让自己十分的意外，但这也是自己本身的看法罢了，或许这才是最真实的自己</li><li>让自己丧了一天的财务管理期中成绩也是真的令自己心碎啊</li><li>了解了一些数据库的知识，应该叫复习了，毕竟之前还是多少学了一点</li><li>node要努力了，时间的零碎学起来也是很零碎</li></ul><h4 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h4><ul><li>这一周缺乏锻炼，怎么感觉又长胖了。。。</li><li>稍微一点混沌，可能躺太多</li><li>手臂在乒乓球课崴了，一直一点酸疼</li><li>吃饭特别不规律！！！这一点下个周一定得改了</li><li>对了，微信终于开始了，不过进度貌似不能保证每天，所以自己准备改一下，暂时上学期间频率保持一周两篇吧，如果空闲的周可以多做一点</li></ul><h4 id="待更进事项"><a href="#待更进事项" class="headerlink" title="待更进事项"></a>待更进事项</h4><ul><li>通信作业的问题回答</li><li>还是抽时间把毛概的论文写了吧，毕竟回去可能还真的可以考试呢</li><li>node</li><li>php继续学习</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本周很日常，只是感觉自己有点缺乏锻炼，所以显得不是特别的精神，可能也和天气有关系，开始凉了，自己也没带什么厚衣服，所以没课都不怎么出门的那种。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="周记" scheme="http://yangkunyi.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>用户验证与数据库</title>
    <link href="http://yangkunyi.com/2017/12/06/%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yangkunyi.com/2017/12/06/用户验证与数据库/</id>
    <published>2017-12-06T12:22:28.000Z</published>
    <updated>2017-12-06T12:25:46.194Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是今天web课程的笔记，亲自尝试了前面两种验证方式，第三种方式之前也有所接触，还都算比较好理解。后面还有一些数据库的简单解释。</p></blockquote><a id="more"></a><h2 id="验证用户方法"><a href="#验证用户方法" class="headerlink" title="验证用户方法"></a>验证用户方法</h2><h3 id="1-HTTP自带的验证"><a href="#1-HTTP自带的验证" class="headerlink" title="1. HTTP自带的验证"></a>1. HTTP自带的验证</h3><blockquote><p>这种方式是利用HTTP所提供的验证头信息来对用户进行身份验证。由于这种凡是对大量的使用者缺乏有效的管理，在用户太多时并没有太大用处，因此少量用户时使用。例如开发人员。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;?php </div><div class="line">    // 如果 $PHP_AUTH_USER 不等于 &quot;tea&quot;，就进不去网站。 </div><div class="line">    if($_SERVER[&apos;PHP_AUTH_USER&apos;] !=&apos;tea&apos; || $_SERVER[&apos;PHP_AUTH_PW&apos;] !=&apos;ok&apos;)&#123; </div><div class="line">    //通过头部信息告知浏览器验证</div><div class="line">    header(&apos;WWW-Authenticate: Basic realm=&quot;「需验证」---请输入账户/密码&quot;&apos;); </div><div class="line">    header(&apos;HTTP/1.0 401 Unauthorized&apos;); </div><div class="line">    echo &quot;账号或密码错误。请刷新重新输入。&quot;; </div><div class="line">    </div><div class="line">    //记得要加上 exit() 离开，不然就跟没有验证一样了！ </div><div class="line">    exit(); </div><div class="line">    &#125; </div><div class="line">    /* </div><div class="line">    如果用户输入正确的账户和密码，下面的 HTML 就会显示 </div><div class="line">    */ </div><div class="line">    ?&gt; </div><div class="line">&lt;HTML&gt; </div><div class="line">    &lt;HEAD&gt; </div><div class="line">        &lt;TITLE&gt;&lt;/TlTLE&gt; </div><div class="line">    &lt;/HEAD&gt; </div><div class="line"></div><div class="line">    &lt;BODY&gt; </div><div class="line">        &lt;P&gt;Hello World！&lt;/P&gt; </div><div class="line">    &lt;/BODY&gt; </div><div class="line">&lt;/HTML&gt;</div></pre></td></tr></table></figure><h3 id="2-htaccess方式的验证"><a href="#2-htaccess方式的验证" class="headerlink" title="2. htaccess方式的验证"></a>2. <code>htaccess</code>方式的验证</h3><blockquote><p>这种凡是其实时Apche所提供的加强版HTTP验证方式，利用Apche所提供的<code>htpasswd</code>来设定使用者账号和密码。但是任然不适用过多用户。</p></blockquote><h4 id="首先建立用户数据（授权的动作）"><a href="#首先建立用户数据（授权的动作）" class="headerlink" title="首先建立用户数据（授权的动作）"></a>首先建立用户数据（授权的动作）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 第一次 -c，第二次添加就不需要了</div><div class="line">c:\appserv\apache\bin&gt; htpasswd -c htusers Tom </div><div class="line">New password: ←输入用户密码 </div><div class="line">Re-type new password: ←再次输入 </div><div class="line">Adding password for user Tom</div><div class="line"></div><div class="line">c:\appserv\apache\bin&gt; htpasswd htusers Jack </div><div class="line">New password: </div><div class="line">Re-type new password: </div><div class="line">Adding password for user Jack</div><div class="line"></div><div class="line">// 可以将不同的人进行分组，group是群组名称</div><div class="line">group:Tom Jack</div></pre></td></tr></table></figure><h4 id="然后在需要权限才可以进入的路径中建-htaccess文档（将已授权和访问地址联系到一起）"><a href="#然后在需要权限才可以进入的路径中建-htaccess文档（将已授权和访问地址联系到一起）" class="headerlink" title="然后在需要权限才可以进入的路径中建.htaccess文档（将已授权和访问地址联系到一起）"></a>然后在需要权限才可以进入的路径中建<code>.htaccess</code>文档（将已授权和访问地址联系到一起）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 显示给用户看的提示</div><div class="line">AuthName &quot;登陆时需要输入账号和密码「账号」与「密码」&quot; </div><div class="line">// 验证时不编码</div><div class="line">AuthType Basic </div><div class="line">// 之前建立的用户数据</div><div class="line">AuthUserFile c:\appserv\apache\bin\htusers </div><div class="line">#AuthGroupFile c:\appserv\apache\bin\htgroup </div><div class="line">// 所有访问的都需要验证</div><div class="line">require valid-user </div><div class="line">#require user jollen </div><div class="line">#require group ieem316 </div><div class="line">// 定义说拒绝所有，允许个别</div><div class="line">order deny,allow </div><div class="line">deny from all </div><div class="line">#allow from .nthu.edu.tw </div><div class="line">allow from 140.114.70.31</div></pre></td></tr></table></figure><h3 id="3-数据库存储用户数据"><a href="#3-数据库存储用户数据" class="headerlink" title="3. 数据库存储用户数据"></a>3. 数据库存储用户数据</h3><blockquote><p>最有效，最普遍的做法，将用户的账户和密码存在数据库中，每次登陆到数据库中查找数据，最后返回有无和正确性。</p></blockquote><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol><li>登陆的表单</li><li>登陆的程序</li><li>建好用户的资料库，至少要包括账号和密码</li></ol><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>通过表单获取用户账号与密码</li><li>到数据库中查找对应的账号和密码</li><li>失败就返回重新获取信息，直到成功为止</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 本程序通过头信息获取的用户的账户和密码</div><div class="line">&lt;?php </div><div class="line">    // 如果用户沒有输入账户，要求用户重新验证。 </div><div class="line">    IF(!isset($PHP_AUTH_USER))&#123; </div><div class="line">        header(&apos;WWW-Authenticate: Basic realm=&quot;请输入账号和密码&quot;&apos;); </div><div class="line">        header(&apos;HTTP/1.0 401 Unauthorized&apos;); </div><div class="line">        echo &quot;刷新后重新登陆&quot;; </div><div class="line">        exit(); </div><div class="line">    &#125;</div><div class="line">    else&#123; </div><div class="line">        mysql_connect(&quot;localhost&quot;,&quot;admin&quot;,&quot;asdee4&quot;) or die (&quot;无法连接 MySQL&quot;); </div><div class="line">        rnysql_select_db(&quot;members&quot;) or die(&quot;无法连接数据库&quot;); </div><div class="line">        $query=&quot;select id from users where username=&apos;$PHP_AUTH_USER&apos; and </div><div class="line">        password=&apos;$PHP_AUTH_PW&apos;&quot;; </div><div class="line">        $result=mysql_query($query); </div><div class="line">        $n_rows=mysql_num_rows($result); </div><div class="line">        mysql_close(); </div><div class="line">        // 当row&lt;1时，用户账号与密码有错，重新登陆</div><div class="line">        if($n_rows &lt; 1)&#123; </div><div class="line">            header(&apos;WWW_Authenticate: Basic realm=&quot;请输入账号和密码&quot;&apos;); </div><div class="line">            header(&apos;HTTP/1.0 401 Unauthorized&apos;); </div><div class="line">            echo &quot;刷新重新登陆&quot;; </div><div class="line">            exit(); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">?&gt;</div></pre></td></tr></table></figure><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="数据库系统-数据库管理系统-数据库"><a href="#数据库系统-数据库管理系统-数据库" class="headerlink" title="数据库系统 = 数据库管理系统 + 数据库"></a>数据库系统 = 数据库管理系统 + 数据库</h3><h4 id="DBMS（数据库管理系统）：database-management-system"><a href="#DBMS（数据库管理系统）：database-management-system" class="headerlink" title="DBMS（数据库管理系统）：database management system"></a>DBMS（数据库管理系统）：database management system</h4><ul><li>只是一个软件</li><li>作用：资料的管理和维护</li></ul><h4 id="DB（数据库）：database"><a href="#DB（数据库）：database" class="headerlink" title="DB（数据库）：database"></a>DB（数据库）：database</h4><h3 id="SQL（structure-query-language）：结构化查询语句"><a href="#SQL（structure-query-language）：结构化查询语句" class="headerlink" title="SQL（structure query language）：结构化查询语句"></a>SQL（structure query language）：结构化查询语句</h3><ul><li>第一代：89</li><li>第二代：92（绝大部分数据库所遵循的规则）</li><li>第三代：99（没有成立）</li></ul><h4 id="DDL（data-definition-language）：数据库和数据表定义语言"><a href="#DDL（data-definition-language）：数据库和数据表定义语言" class="headerlink" title="DDL（data definition language）：数据库和数据表定义语言"></a>DDL（data definition language）：数据库和数据表定义语言</h4><ul><li>create<ul><li>database</li><li>table</li></ul></li><li>drop<ul><li>database</li><li>table</li></ul></li><li>alter（改变数据库的结构）<ul><li>table</li></ul></li></ul><h4 id="DML（data-manipulation-language）：数据处理语言"><a href="#DML（data-manipulation-language）：数据处理语言" class="headerlink" title="DML（data manipulation language）：数据处理语言"></a>DML（data manipulation language）：数据处理语言</h4><ul><li>select（查询）</li><li>insert [into]（添加）</li><li>delete（删除）</li><li>updata（单个属性的改变）</li></ul><h4 id="DCL（data-control-language）：数据库控制语言"><a href="#DCL（data-control-language）：数据库控制语言" class="headerlink" title="DCL（data control language）：数据库控制语言"></a>DCL（data control language）：数据库控制语言</h4><ul><li>grant（授权）</li><li>revoke（取消授权）</li></ul><h3 id="使用者"><a href="#使用者" class="headerlink" title="使用者"></a>使用者</h3><ul><li>DBO（database operater）</li><li>DBA（database administrator）：root/password</li></ul><h3 id="简单的结构"><a href="#简单的结构" class="headerlink" title="简单的结构"></a>简单的结构</h3><pre><code>DB Server（数据库服务器） DB（数据库）  table（数据表）   record（）    field     charset</code></pre><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol><li>链接数据库</li><li>use/create：database</li><li>create：table/改变资料表里面的数据</li></ol><h3 id="数据库操作方法"><a href="#数据库操作方法" class="headerlink" title="数据库操作方法"></a>数据库操作方法</h3><ul><li>通过程式（php）</li><li>通过命令行<ul><li>-u：使用者</li><li>-h：主机</li><li>-p：密码</li></ul></li><li>通过图形界面（软件）</li></ul><h3 id="PHP-amp-数据库"><a href="#PHP-amp-数据库" class="headerlink" title="PHP &amp; 数据库"></a>PHP &amp; 数据库</h3><h4 id="1-连接数据库"><a href="#1-连接数据库" class="headerlink" title="1. 连接数据库"></a>1. 连接数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$db = mysql_connect（数据库主机名称或ip,数据库账号,数据库密码）;</div><div class="line">      or die(&quot;无法连接数据库服务器&quot;);</div></pre></td></tr></table></figure><h4 id="2-使用数据库"><a href="#2-使用数据库" class="headerlink" title="2. 使用数据库"></a>2. 使用数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql_ select_db(名称,$db);</div><div class="line">    or die(&quot;无法连接数据库&quot;);</div></pre></td></tr></table></figure><h4 id="3-对数据进行操作"><a href="#3-对数据进行操作" class="headerlink" title="3. 对数据进行操作"></a>3. 对数据进行操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sql = &quot;(此处就是SQL指令)&quot;;</div></pre></td></tr></table></figure><h4 id="4-用变量对数据进行存取"><a href="#4-用变量对数据进行存取" class="headerlink" title="4. 用变量对数据进行存取"></a>4. 用变量对数据进行存取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$result = mysql_query($sql,$db);</div></pre></td></tr></table></figure><h4 id="5-最后关闭数据库"><a href="#5-最后关闭数据库" class="headerlink" title="5. 最后关闭数据库"></a>5. 最后关闭数据库</h4><blockquote><p>当取到数据的时候就可以关掉了，这样可以降低数据库风险。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql_close($db);</div></pre></td></tr></table></figure><h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><ul><li>sql指令可以大小写，但各种数据库名称和数据表名称要区别大小写。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是今天web课程的笔记，亲自尝试了前面两种验证方式，第三种方式之前也有所接触，还都算比较好理解。后面还有一些数据库的简单解释。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yangkunyi.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="PHP" scheme="http://yangkunyi.com/tags/PHP/"/>
    
      <category term="验证" scheme="http://yangkunyi.com/tags/%E9%AA%8C%E8%AF%81/"/>
    
      <category term="数据库" scheme="http://yangkunyi.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>坎帕斯学院讨论日常-2</title>
    <link href="http://yangkunyi.com/2017/12/03/%E5%9D%8E%E5%B8%95%E6%96%AF%E5%AD%A6%E9%99%A2%E6%97%A5%E5%B8%B8%E8%AE%A8%E8%AE%BA-2/"/>
    <id>http://yangkunyi.com/2017/12/03/坎帕斯学院日常讨论-2/</id>
    <published>2017-12-03T13:23:28.000Z</published>
    <updated>2017-12-03T13:25:19.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是第二次整理讨论的内容，本次内容有点深奥，值得细嚼慢咽。<br><a id="more"></a></p></blockquote><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul><li>高并发(High Concurrency)<ul><li>指通过设计保证系统能够同时并行处理很多请求。</li><li>是互联网分布式系统架构设计中必须考虑的因素之一。</li></ul></li><li>高性能(High performance)<ul><li>目前理解就是提高浏览网页的速度。</li></ul></li><li>高可用(High Availability)<ul><li>通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。</li></ul></li><li>高扩展性(High Extensibility)<ul><li>通常和可伸缩性混为一谈.在软件范畴上，是软件系统本身的属性，或者进一步说是设计的属性，代码的属性。 </li></ul></li><li>高可维护性(High Maintainability)<ul><li>是衡量一个系统的可修复(恢复)性和可改进性的难易程度。</li></ul></li></ul><h3 id="接口的高可用性"><a href="#接口的高可用性" class="headerlink" title="接口的高可用性"></a>接口的高可用性</h3><blockquote><p>保证这个接口在任何情况下都可以正确的取到数据。</p></blockquote><ul><li>方案一：每次访问的时候将a接口的数据存在本地，第二次访问的时候接口如果gg了，可以直接在本地获取数据，然后渲染出来；（前提是访问过a接口）</li><li>方案二：推oss或者cdn；每次访问了一个接口，然后服务器把返回的数据生成文件推送到一个静态资源服务器上去；<ul><li>好处：比如某人访问了接口，静态资源服务器就会缓存a里面的数据，这时候gg了，其他人依然可以请求到oss上的数据；（逻辑是前端做到的，但是数据推到oss上是从后台推上去的）</li><li>oss几乎不可能gg，原因是它只是一个静态资源存储的地方；</li></ul></li><li>默认数据：（假数据）当接口不可用的时候，用这个自己做的数据；</li></ul><blockquote><p>目前企业的解决方案是：先走服务器接口，若是gg了；再访问本地缓存；若没有，则访问oss。</p></blockquote><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><ul><li>优点：<ul><li>如果第一次没有访问对应的接口就没有本地缓存；</li><li>数据的时效性不够；</li></ul></li><li>缺点：<ul><li>快，不用通过网络请求；</li></ul></li></ul><h4 id="缓存地点"><a href="#缓存地点" class="headerlink" title="缓存地点"></a>缓存地点</h4><ul><li>缓存类型：<ul><li><code>sessionStorage</code>：只在当次回话有效，不会带到每一个请求里面去；</li><li><code>indexDB</code>：浏览器支持度很低，也就是说兼容问题很大；</li><li><code>cookie</code>：过期时间可以设置，默认是浏览器当期回话结束失效；cookie很小；每次对应域名是会在每个请求头带过去，浪费资源，所以限制了大小，如果不限制，就会跟上传文件没有区别了，会导致特别慢；对于数据接口，我们不能保证内容有多大，而且每个接口数据都要缓存，所以不能用cookie。</li><li><code>localstorage</code>：没有大小限制；</li></ul></li></ul><blockquote><p>以上都属于这两种类型：</p><ol><li>（私有）浏览器缓存：单个用户，你浏览过的页面浏览器缓存起来。</li><li>（共享）代理缓存：多个用户，所在公司自己架构的，减少网络拥堵与延迟。</li></ol></blockquote><h3 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h3><h4 id="浏览器请求一个资源，是怎么判断取缓存还是找服务器下载？"><a href="#浏览器请求一个资源，是怎么判断取缓存还是找服务器下载？" class="headerlink" title="浏览器请求一个资源，是怎么判断取缓存还是找服务器下载？"></a>浏览器请求一个资源，是怎么判断取缓存还是找服务器下载？</h4><p><img src="http://otn4ut2th.bkt.clouddn.com/blog201211281402438011.png" alt="浏览器缓存"></p><h4 id="状态码304是怎么产生的？"><a href="#状态码304是怎么产生的？" class="headerlink" title="状态码304是怎么产生的？"></a>状态码304是怎么产生的？</h4><ul><li>是因为本地文件设置的信息头部过期了，去服务器拉取，然后服务器告诉我，其实你的文件还尚未过期，让你回自己本地取资源；</li></ul><h4 id="状态码200（from-cache）是怎么产生的？"><a href="#状态码200（from-cache）是怎么产生的？" class="headerlink" title="状态码200（from cache）是怎么产生的？"></a>状态码200（from cache）是怎么产生的？</h4><ul><li>一定是通过了请求并且成功然后返回的状态码，方式<code>get</code>或者<code>post</code>。</li></ul><blockquote><p>以上的问题只是有所了解了，但是关于浏览器的缓存机制还没有系统的了解，自己在看官方文档的时候，感觉有点困惑，所以先在这里埋个种子。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是第二次整理讨论的内容，本次内容有点深奥，值得细嚼慢咽。&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yangkunyi.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="问题" scheme="http://yangkunyi.com/tags/%E9%97%AE%E9%A2%98/"/>
    
      <category term="讨论" scheme="http://yangkunyi.com/tags/%E8%AE%A8%E8%AE%BA/"/>
    
      <category term="浏览器缓存" scheme="http://yangkunyi.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    
      <category term="状态码" scheme="http://yangkunyi.com/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>WeeklyMind-2</title>
    <link href="http://yangkunyi.com/2017/12/02/WeeklyMind-2/"/>
    <id>http://yangkunyi.com/2017/12/02/WeeklyMind-2/</id>
    <published>2017-12-02T04:29:09.000Z</published>
    <updated>2017-12-02T06:43:47.499Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>忙碌的一周，这都是浪三天的后遗症。上周的周记都在浪中忘记了，但是心情还是很开心的。</p></blockquote><a id="more"></a><h3 id="总结上两周"><a href="#总结上两周" class="headerlink" title="总结上两周"></a>总结上两周</h3><h5 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h5><blockquote><p>期中考试和报告全部完成，成绩一般，接下来又要开始准备期末考试了，来台湾三个月了，自己也在想这一趟来的值不值。</p></blockquote><ul><li><p>课程：</p><ul><li>突然对不动产的作业很是上心，希望在同学和老师们面前不丢咱大陆学生的脸</li><li>为了行销管理的期中报告，自己也算是呕心沥血了，希望不要太差</li><li>西方哲学到康德部分，开始有点抽象到不懂了，还是知识面太狭窄了</li><li>财务管理课程让自己彻底对经融课程失望了，自己是真的不适合学习，修这门课都当作了解吧</li><li>突然觉得人际交往是一门很重要的课程，既认识了自己，也认识了别人</li><li>这两个周因为中间的各种考试和报告，时间有点混乱，所以接下来应该好好计划</li></ul></li><li><p>其它</p><ul><li>http缓存机制的了解，周末希望能理解完</li><li>继续学习了php</li><li>了解php架构包中如何建wordpress以及评论板块（但是发现自己对数据库的认识还不够，导致在尝试过程中老是出现问题）</li></ul></li></ul><h5 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h5><blockquote><p>上个周末算是很精彩了，一趟三天两夜的旅行回来，也导致了博客的的各种托更。</p></blockquote><ul><li><p>台南：</p><ul><li>赤崁楼</li><li>安平古堡</li><li>安平树屋</li><li>安平老街</li></ul></li><li><p>高雄</p><ul><li>夜市</li><li>爱河</li><li>真爱码头</li><li>西子湾</li><li>中山大学</li></ul></li></ul><p>也算是见过真正的浪了！</p><h5 id="待更进事项"><a href="#待更进事项" class="headerlink" title="待更进事项"></a>待更进事项</h5><ul><li>12月计划</li><li>微信订阅号</li><li>各种作业</li><li>前端书籍（每天给点时间来做，积累最重要）</li></ul><blockquote><p>今年的最后一个月，完成你年初的计划可好，少年！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;忙碌的一周，这都是浪三天的后遗症。上周的周记都在浪中忘记了，但是心情还是很开心的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="周记" scheme="http://yangkunyi.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>WeeklyMind-1</title>
    <link href="http://yangkunyi.com/2017/11/19/WeeklyMind-1/"/>
    <id>http://yangkunyi.com/2017/11/19/WeeklyMind-1/</id>
    <published>2017-11-19T06:11:30.000Z</published>
    <updated>2017-12-02T06:43:35.669Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>寻常的一周，不过做了许多的决定，之后每一周也希望自己能坚持做一下简单的总结。</p></blockquote><a id="more"></a><h3 id="总结上周"><a href="#总结上周" class="headerlink" title="总结上周"></a>总结上周</h3><h4 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h4><ul><li>新买的T恤很喜欢</li><li>吃得很随便，但不失营养，老年人一样的生活，哈哈哈</li><li>住的寝室，还是比较宅，之后希望有时间，还是多出去走走看看</li><li>这周没怎么出门，最近在准备各种考试和期中报告</li></ul><h4 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h4><ul><li><p>课程：</p><ul><li>人际考试</li><li>周三运动会放假</li><li>复习财管</li><li>其它课程一切照常进行</li><li>完成日常作业</li></ul></li><li><p>其它</p><ul><li>申请和绑定了域名</li><li>博客主题修改</li><li>了解nodeppt</li><li>简单的看了一下网易云api（有准备做一个音乐播放器）</li></ul></li></ul><h2 id="待更进事项"><a href="#待更进事项" class="headerlink" title="待更进事项"></a>待更进事项</h2><ul><li>复习财管（周三考试）</li><li>电商案例分析</li><li>人际期中报告</li><li>不动产课堂报告</li><li>课程小节论文</li><li>通信英语ppt</li><li>继续学习php</li><li>更新博客</li><li>日常作业</li></ul><blockquote><p>最后还有锻炼，这个事情还是比较重要的。按照自己的计划腾出锻炼的时间，保持健康，毕竟在这个遥远的地方没有买保险。。。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;寻常的一周，不过做了许多的决定，之后每一周也希望自己能坚持做一下简单的总结。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="周记" scheme="http://yangkunyi.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>PHP学习笔记</title>
    <link href="http://yangkunyi.com/2017/11/17/PHP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yangkunyi.com/2017/11/17/PHP学习笔记/</id>
    <published>2017-11-17T09:55:52.000Z</published>
    <updated>2017-12-02T06:42:30.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是一些PHP的基础知识，自己看书的时候做的一些笔记。</p></blockquote><a id="more"></a><h2 id="PHP变量"><a href="#PHP变量" class="headerlink" title="PHP变量"></a>PHP变量</h2><ul><li>PHP 语句和 PHP 变量都是区分大小写的。</li><li>PHP 没有声明变量的命令。</li></ul><h3 id="PHP-是一门弱类型语言"><a href="#PHP-是一门弱类型语言" class="headerlink" title="PHP 是一门弱类型语言"></a>PHP 是一门弱类型语言</h3><ul><li>不必向 PHP 声明该变量的数据类型。</li><li>PHP会根据变量的值，自动把变量转换为正确的数据类型。</li><li>在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称。</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h4><ul><li><code>global</code>可以将局部变量提升为全局变量。</li><li>PHP将所有全局变量存储在一个名为<code>$GLOBALS[index]</code>的数组中。index保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。</li><li><code>Static</code>作用域<ul><li>当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除。要做到这一点，请在您第一次声明变量时使用 static 关键字。</li></ul></li><li>参数作用域：属于函数的局部变量。</li></ul><h2 id="php中常见的输出语句"><a href="#php中常见的输出语句" class="headerlink" title="php中常见的输出语句"></a>php中常见的输出语句</h2><ul><li><code>echo()</code>: 可以一次输出多个值，多个值之间用逗号分隔。<code>echo</code>是语言结构(language construct)，而并不是真正的函数，因此不能作为表达式的一部分使用。</li><li><code>print()</code>: 函数<code>print()</code>打印一个值（它的参数），如果字符串成功显示则返回<code>true</code>，否则返回<code>false</code>。</li><li><code>print_r()</code>: 可以把字符串和数字简单地打印出来，而数组则以括起来的键和值得列表形式显示，并以<code>Array</code>开头。但<code>print_r()</code>输出布尔值和NULL的结果没有意义，因为都是打印”\n”。因此用<code>var_dump()</code>函数更适合调试。</li><li><code>var_dump()</code>: 判断一个变量的类型与长度,并输出变量的数值,如果变量有值输的是变量的值并回返数据类型。此函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h3><ul><li>双引号串中的内容可以被解释而且替换，而单引号串中的内容总被认为是普通字符。 在单引号串中甚至反斜杠也失去了他的扩展含义（除了插入反斜杠\和插入单引号\’）。 所以，当你想在字串中进行变量代换和包含\n（换行符）等转义序列时，你应该使用双引号。单引号串可以用在其他任何地方，脚本中使用单引号串处理速度会更快些。</li></ul><h3 id="整型（Integer）"><a href="#整型（Integer）" class="headerlink" title="整型（Integer）"></a>整型（Integer）</h3><ul><li>整数是一个没有小数的数字。</li></ul><h3 id="浮点型（Float）"><a href="#浮点型（Float）" class="headerlink" title="浮点型（Float）"></a>浮点型（Float）</h3><p>-浮点数是带小数部分的数字，或是指数形式。</p><h3 id="布尔型（Boolean）"><a href="#布尔型（Boolean）" class="headerlink" title="布尔型（Boolean）"></a>布尔型（Boolean）</h3><h3 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h3><h3 id="对象（Object）"><a href="#对象（Object）" class="headerlink" title="对象（Object）"></a>对象（Object）</h3><ul><li>类似于java的类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    class Car</div><div class="line">    &#123;</div><div class="line">        var $color;</div><div class="line">        function Car($color=&quot;green&quot;) &#123;</div><div class="line">            $this-&gt;color = $color;</div><div class="line">        &#125;</div><div class="line">        function what_color() &#123;</div><div class="line">            return $this-&gt;color;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure><h3 id="NULL值"><a href="#NULL值" class="headerlink" title="NULL值"></a>NULL值</h3><ul><li>NULL值表示变量没有值。NULL是数据类型为NULL的值。</li><li>NULL值指明一个变量是否为空值。同样可用于数据空值和NULL值的区别。</li><li><p>可以通过设置变量值为 NULL 来清空变量数据</p><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><ul><li><code>strlen(string)</code>函数：返回字符串长度</li><li><code>strpos(seacher,char)</code>函数：查找一个字符串在另一个字符串中第一次出现的位置</li></ul></li></ul><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><ul><li><code>sort()</code> - 对数组进行升序排列</li><li><code>rsort()</code> - 对数组进行降序排列</li><li><code>asort()</code> - 根据关联数组的值，对数组进行升序排列</li><li><code>ksort()</code> - 根据关联数组的键，对数组进行升序排列</li><li><code>arsort()</code> - 根据关联数组的值，对数组进行降序排列</li><li><code>krsort()</code> - 根据关联数组的键，对数组进行降序排列</li></ul><h2 id="PHP-超级全局变量"><a href="#PHP-超级全局变量" class="headerlink" title="PHP 超级全局变量"></a>PHP 超级全局变量</h2><ul><li><code>$GLOBALS</code>：是一个包含了全部变量的全局组合数组。变量的名字就是数组的键。</li><li><code>$_SERVER</code>：是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。</li><li><code>$_REQUEST</code>：用于收集HTML表单提交的数据。</li><li><code>$_POST</code>：被广泛应用于收集表单数据，在HTMLform标签的指定该属性：<code>&quot;method=&quot;post&quot;</code>。<ul><li>从带有 POST 方法的表单发送的信息，对任何人都是不可见的（不会显示在浏览器的地址栏）</li><li>并且对发送信息的量也没有限制。</li></ul></li><li><code>$_GET</code>：同样被广泛应用于收集表单数据，在HTMLform标签的指定该属性：<code>&quot;method=&quot;get&quot;</code>。<code>$_GET</code>也可以收集URL中发送的数据。<ul><li>从带有 GET 方法的表单发送的信息，对任何人都是可见的（会显示在浏览器的地址栏）</li><li>并且对发送信息的量也有限制。</li></ul></li><li><code>$_FILES</code></li><li><code>$_ENV</code></li><li><code>$_COOKIE</code></li><li><code>$_SESSION</code></li></ul><h2 id="PHP魔术变量"><a href="#PHP魔术变量" class="headerlink" title="PHP魔术变量"></a>PHP魔术变量</h2><ul><li><code>__LINE__</code>：文件中的当前行号。</li><li><code>__FILE__</code>：文件的完整路径和文件名。</li><li><code>__DIR__</code>：文件所在的目录。</li><li><code>__FUNCTION__</code>：函数名称。</li><li><code>__CLASS__</code>：类的名称。</li><li><code>__TRAIT__</code>：trait的名称。</li><li><code>__METHOD__</code>：类方法的名称。</li><li><code>__NAMESPACE__</code>：命名空间的名称。</li></ul><h2 id="XSS又叫-CSS-Cross-Site-Script"><a href="#XSS又叫-CSS-Cross-Site-Script" class="headerlink" title="XSS又叫 CSS (Cross-Site Script)"></a>XSS又叫 CSS (Cross-Site Script)</h2><blockquote><p>跨站脚本攻击。恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。</p></blockquote><h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><ul><li>邮箱：<code>/([\w\-]+\@[\w\-]+\.[\w\-]+)/</code></li><li>URL：<code>/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&amp;@#\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\/%=~_|]/i</code></li><li>只有字母和空格：<code>/^[a-zA-Z ]*$/</code></li></ul><h2 id="Get-与-Post"><a href="#Get-与-Post" class="headerlink" title="Get 与 Post"></a>Get 与 Post</h2><h3 id="何时用method-”get”？"><a href="#何时用method-”get”？" class="headerlink" title="何时用method=”get”？"></a>何时用method=”get”？</h3><ul><li>在 HTML 表单中使用 method=”get” 时，所有的变量名和值都会显示在 URL 中。<ul><li>注释：所以在发送密码或其他敏感信息时，不应该使用这个方法！</li></ul></li><li>然而，正因为变量显示在URL中，因此可以在收藏夹中收藏该页面。在某些情况下，这是很有用的。<ul><li>注释：HTTP GET 方法不适合大型的变量值。它的值是不能超过 2000 个字符的。</li></ul></li></ul><h3 id="何时用method-”post”？"><a href="#何时用method-”post”？" class="headerlink" title="何时用method=”post”？"></a>何时用method=”post”？</h3><ul><li>从带有 POST 方法的表单发送的信息，对任何人都是不可见的，并且对发送信息的量也没有限制。</li><li>然而，由于变量不显示在 URL 中，所以无法把页面加入书签。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是一些PHP的基础知识，自己看书的时候做的一些笔记。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yangkunyi.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="PHP" scheme="http://yangkunyi.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript调试</title>
    <link href="http://yangkunyi.com/2017/11/16/JavaScript%E8%B0%83%E8%AF%95/"/>
    <id>http://yangkunyi.com/2017/11/16/JavaScript调试/</id>
    <published>2017-11-16T10:38:42.000Z</published>
    <updated>2017-12-02T06:42:03.794Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文就想总结一些调试的方法，其实调试是提高效率的重要方法之一，会用正确高效的调试方法，可以事半功倍。</p></blockquote><a id="more"></a><h3 id="1、最常用console-log（简单数据输出）"><a href="#1、最常用console-log（简单数据输出）" class="headerlink" title="1、最常用console.log（简单数据输出）"></a>1、最常用<code>console.log</code>（简单数据输出）</h3><ul><li>这就没有什么好解释的，不过输出也是有技巧的，那就是要格式化，简单说就是要有标志性，只有数据或许会让人不理解，最好是加上前缀</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// example</div><div class="line">console.log(&quot;fun&apos;s result---&quot; + fun(2));</div><div class="line">console.log(&quot;value of a---&quot; + a);</div></pre></td></tr></table></figure><ul><li>当然可以改变颜色和字体等</li></ul><h3 id="2、debugger：断点"><a href="#2、debugger：断点" class="headerlink" title="2、debugger：断点"></a>2、debugger：断点</h3><ul><li>与<code>console.log</code>相比，debugger会在执行的过程中停在你想的地方，能够更加直接的看到执行过程。</li></ul><h3 id="3、将对象以表格的形式展示console-table"><a href="#3、将对象以表格的形式展示console-table" class="headerlink" title="3、将对象以表格的形式展示console.table()"></a>3、将对象以表格的形式展示<code>console.table()</code></h3><ul><li>将对象强制用表格打出来，这样展开的对象键值对应更加清晰</li><li>注意firefox有限制，最多显示1000行</li></ul><h3 id="4、尝试适配各种机型屏幕大小"><a href="#4、尝试适配各种机型屏幕大小" class="headerlink" title="4、尝试适配各种机型屏幕大小"></a>4、尝试适配各种机型屏幕大小</h3><ul><li>这个对开发手机页面很有帮助</li><li>其次是可以检查布局问题</li></ul><h3 id="5、如何快速找到对应的DOM元素"><a href="#5、如何快速找到对应的DOM元素" class="headerlink" title="5、如何快速找到对应的DOM元素"></a>5、如何快速找到对应的DOM元素</h3><ul><li>方法1浏览器的快速选择工具</li><li>方法2是通过参数访问，浏览器有将DOM元素进行编号，可以通过$x的方式去访问。（具体后续补充）</li></ul><h3 id="6、使用console-time-和console-timeEnd-来记录时间"><a href="#6、使用console-time-和console-timeEnd-来记录时间" class="headerlink" title="6、使用console.time()和console.timeEnd()来记录时间"></a>6、使用<code>console.time()</code>和<code>console.timeEnd()</code>来记录时间</h3><ul><li>关注函数运行的时间是提高效率的方法之一</li></ul><h3 id="获取某个函数的Stacktrace"><a href="#获取某个函数的Stacktrace" class="headerlink" title="获取某个函数的Stacktrace"></a>获取某个函数的Stacktrace</h3><ul><li>console.trace()</li><li>向Web控制台输出一个堆栈跟踪</li></ul><h3 id="将minify的代码还原"><a href="#将minify的代码还原" class="headerlink" title="将minify的代码还原"></a>将minify的代码还原</h3><ul><li>{}</li></ul><h3 id="快速定位需要debug的函数"><a href="#快速定位需要debug的函数" class="headerlink" title="快速定位需要debug的函数"></a>快速定位需要debug的函数</h3><ul><li>debug(funName)</li><li>会在执行函数的地方停下来</li></ul><h3 id="屏蔽不相关的脚本"><a href="#屏蔽不相关的脚本" class="headerlink" title="屏蔽不相关的脚本"></a>屏蔽不相关的脚本</h3><ul><li>注释掉</li></ul><h3 id="查看某个函数调用和其参数"><a href="#查看某个函数调用和其参数" class="headerlink" title="查看某个函数调用和其参数"></a>查看某个函数调用和其参数</h3><ul><li>monitor(funName)</li></ul><h3 id="Postman很好用，不过传说Firefox更快"><a href="#Postman很好用，不过传说Firefox更快" class="headerlink" title="Postman很好用，不过传说Firefox更快"></a>Postman很好用，不过传说Firefox更快</h3><ul><li>但由于本人喜欢用chrome，所以没有用尝试firefox</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文就想总结一些调试的方法，其实调试是提高效率的重要方法之一，会用正确高效的调试方法，可以事半功倍。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yangkunyi.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>域名的购买和绑定</title>
    <link href="http://yangkunyi.com/2017/11/15/%E5%9F%9F%E5%90%8D%E7%9A%84%E8%B4%AD%E4%B9%B0%E5%92%8C%E7%BB%91%E5%AE%9A/"/>
    <id>http://yangkunyi.com/2017/11/15/域名的购买和绑定/</id>
    <published>2017-11-15T09:42:30.000Z</published>
    <updated>2017-12-02T06:46:26.217Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>终于下定决心，自己在阿里云上购买了域名，开始将自己的博客放到一个更大的“池塘”里面了，之后的学习，希望自己能继续坚持。</p></blockquote><a id="more"></a><h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><ul><li><p>前期翻看了很多关于在哪里购买域名的博文，最后还是决定就在阿里云买了，原因如下：（其实很早就想买了，但是之前还是觉得自己技术不成熟吧，买了也是浪费，不过现在觉得，买了就有更大的动力学习了）</p><ul><li><strong>为了让自己的博客更有识别度</strong></li><li>作为一个新手，阿里云的性能已经很够用了</li><li>价格一般，作为大学生，还是能负担</li><li>阿里云在国内也算有名了吧</li></ul></li><li><p>购买方法很简单啊，只要去官网就好了<strong><a href="https://cn.aliyun.com/" target="_blank" rel="external">阿里云</a></strong></p></li></ul><h3 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h3><blockquote><p>之前自己的博客是挂在github上面直接用的免费的github pages，为了更有识别度，便买了域名，因为还没有购买服务器，（准备在接下来一年内完成这任务）所以之后项目还是会放在github上。</p></blockquote><p>因此这样的话，绑定域名就很简单了。</p><ul><li>域名的解析，在阿里云的后台管理进行如下设置</li></ul><p><img src="http://otn4ut2th.bkt.clouddn.com/blogdns.PNG" alt="dnsSetting"></p><ul><li>然后是github项目的重定向<ul><li>用过github pages的都知道，github赠送的域名是<code>yourgithubname.github.io</code>，而我们现在要做的就是将这个页面重定向到我们申请的域名上去</li></ul></li></ul><h4 id="方法如下："><a href="#方法如下：" class="headerlink" title="方法如下："></a>方法如下：</h4><ul><li>方法1. 直接更改项目设置中的pages设置，如图：</li></ul><p><img src="http://otn4ut2th.bkt.clouddn.com/bloggithubpage.PNG" alt="githubpages"></p><ul><li>方法2.在项目的根目录中新建一个<code>CNAME</code>文件，文件的内容就是我们申请的域名：</li></ul><p><img src="http://otn4ut2th.bkt.clouddn.com/blogcname.PNG" alt="cname"></p><p>最后就是等待了（时间长短不定，本人感觉并没有等很久），就可以通过我们自己申请的域名访问项目页面了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;终于下定决心，自己在阿里云上购买了域名，开始将自己的博客放到一个更大的“池塘”里面了，之后的学习，希望自己能继续坚持。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="域名" scheme="http://yangkunyi.com/tags/%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>学习PHP之环境搭建</title>
    <link href="http://yangkunyi.com/2017/09/30/%E5%AD%A6%E4%B9%A0PHP%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yangkunyi.com/2017/09/30/学习PHP之环境搭建/</id>
    <published>2017-09-30T04:02:08.000Z</published>
    <updated>2017-12-02T06:46:21.999Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：因为搭建的是本地的服务器，所以只有自己的电脑开着的时候，才能访问到。</p></blockquote><a id="more"></a><h3 id="一、注册域名"><a href="#一、注册域名" class="headerlink" title="一、注册域名"></a>一、注册域名</h3><ol><li>这是一个免费域名的注册地址<a href="https://www.noip.com/" target="_blank" rel="external">www.noip.com</a>，这种网站有很多，只是本人用的这一个，可自由选择。<br><img src="http://otn4ut2th.bkt.clouddn.com/blogwebsite.PNG" alt="此处输入图片的描述"></li><li>注册登录即可。（一个简单的域名注册申请，就不再赘述了）</li><li>根据自己的ip注册后的结果是这样（要特别注意的是ip地址的填写，不知道自己此刻的ip地址可以用命令行查询；<strong><em>此处的ip地址会根据你使用的网络而改变</em></strong>）：<br><img src="http://otn4ut2th.bkt.clouddn.com/blogresult.PNG" alt="此处输入图片的描述"></li></ol><h3 id="二、架构包的安装"><a href="#二、架构包的安装" class="headerlink" title="二、架构包的安装"></a>二、架构包的安装</h3><ol><li>下载架构包（架构包当然也有很多种，本人使用的是链接中的这个）<a href="https://www.appservnetwork.com/en/" target="_blank" rel="external">AppSever8.6.0</a></li><li>安装架构包（跟着流程走就好了，规则就是两个键按左边，三个键按中间，一个键就只能按它咯~）<strong><em>注意安装目录的选择！</em></strong>安装完之后，会有一个这样的目录：<br><img src="http://otn4ut2th.bkt.clouddn.com/blogfile.PNG" alt="此处输入图片的描述"></li><li>测试：在浏览器地址栏中输入你之前申请的并且与ip地址对应的域名，当看到以下结果，说明你ok了，否则请从头开始=_=（嘿嘿，有问题肯定是某个步骤出了问题，仔细检查）：<br><img src="http://otn4ut2th.bkt.clouddn.com/blogifo.png" alt="此处输入图片的描述"></li><li>此处显示的是，文件夹<code>www</code>中的index.php文件<blockquote><p>当然我们希望这些关于服务器的各种信息只有我们自己能看到，而别人看不到，很简单，将文档的名字改成只有你自己知道就好了:<br><img src="http://otn4ut2th.bkt.clouddn.com/blogfilename.png" alt="此处输入图片的描述"></p></blockquote></li><li>既然index文件已经被我们改掉了，因此可以开始写第一个index文件了，此刻网页会自动显示该文件（之后就可以开始写自己的网页了）：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// index.html</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">&lt;title&gt;index&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;p style=&quot;font-size: 50px;color: #66ccff;&quot;&gt;啦啦啦&lt;/p&gt;</div><div class="line">&lt;p style=&quot;font-size: 40px;color: red&quot;&gt;完了&lt;/p&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p><img src="http://otn4ut2th.bkt.clouddn.com/blogover.png" alt="此处输入图片的描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：因为搭建的是本地的服务器，所以只有自己的电脑开着的时候，才能访问到。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://yangkunyi.com/tags/PHP/"/>
    
      <category term="学习" scheme="http://yangkunyi.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>画地为牢</title>
    <link href="http://yangkunyi.com/2017/08/04/%E7%94%BB%E5%9C%B0%E4%B8%BA%E7%89%A2/"/>
    <id>http://yangkunyi.com/2017/08/04/画地为牢/</id>
    <published>2017-08-04T01:16:39.000Z</published>
    <updated>2017-12-02T06:45:38.969Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>它是一套规则，这套规则用来管理引擎如何在当前作用域及嵌套的子作用域中根据标识符名称进行变量的查找。</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if(true) &#123;</div><div class="line">    var num = 10;</div><div class="line">&#125;</div><div class="line">console.log(num);</div></pre></td></tr></table></figure><blockquote><p>思考：JavaScirpt怎样才会形成作用域？</p></blockquote><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><blockquote><p>就是说，在JavaScript中，在函数里面定义的变量，可以在函数里面被访问，但是在函数外无法访问。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var func = function() &#123;</div><div class="line">    var num = 10;</div><div class="line">&#125;;</div><div class="line">console.log(num);</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var func = function() &#123;</div><div class="line">    var num = 10;</div><div class="line">    console.log(num);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><blockquote><p>前面说了，函数可以限定变量的作用域，那么在函数中的函数就成为该作用域的子域。在子域中的代码可以访问到父域中的变量。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var func = function() &#123;</div><div class="line">    var num = 10;</div><div class="line">    var sub_func = function() &#123;</div><div class="line">        console.log(num);</div><div class="line">    &#125;;</div><div class="line">    sub_func();</div><div class="line">&#125;;</div><div class="line">func();</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var func = function() &#123;</div><div class="line">    var num = 10;</div><div class="line">    var sub_func = function() &#123;</div><div class="line">        var num = 20;</div><div class="line">        console.log(num);</div><div class="line">    &#125;;</div><div class="line">    sub_func();</div><div class="line">&#125;;</div><div class="line">func();</div></pre></td></tr></table></figure><blockquote><p>由此可见访问有一定规则可言。在JavaScript中使用变量，JavaScript解释器首先在当前作用域中搜索是否有该变量的定义，如果有，就是用这个变量；如果没有就到父域中寻找该变量。以此类推，直到最顶级作用域，仍然没有找到就抛出异常”变量未定义”。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">    var num = 10;</div><div class="line">    (function() &#123;</div><div class="line">        var num = 20;</div><div class="line">        (function()&#123;</div><div class="line">            console.log(num);</div><div class="line">        &#125;)()</div><div class="line">    &#125;)();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><blockquote><p>思考：什么叫块级作用域？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function outputNumbers(count)&#123;</div><div class="line">    for (var i=0;i&lt;count;i++)&#123;</div><div class="line">        console.log(i);</div><div class="line">    &#125;</div><div class="line">    console.log(i)</div><div class="line">    var i;</div><div class="line">    console.log(i);</div><div class="line">&#125;</div><div class="line">outputNumbers(3);</div></pre></td></tr></table></figure><blockquote><p>很遗憾，在es6之前，javascript是没有块级作用域的。所以也会因此造成对一些变量值的忽视，从而引起程序运行结果不对。那前辈们遇到这个问题是怎么做的呢？让我们来考考古。</p></blockquote><h4 id="利用函数来实现块级作用域"><a href="#利用函数来实现块级作用域" class="headerlink" title="利用函数来实现块级作用域"></a>利用函数来实现块级作用域</h4><ul><li>因为函数是js里唯一具有块级作用域特点的。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function outputNumbers(count)&#123;</div><div class="line">    (function()&#123;</div><div class="line">        for (var i=0;i&lt;count;i++)&#123;</div><div class="line">            console.log(i);</div><div class="line">        &#125;</div><div class="line">    &#125;)();</div><div class="line">    console.log(i);</div><div class="line">&#125;</div><div class="line">outputNumbers(3);</div></pre></td></tr></table></figure><blockquote><p>思考：这是不是一个闭包？</p></blockquote><h4 id="方法类（不建议使用）"><a href="#方法类（不建议使用）" class="headerlink" title="方法类（不建议使用）"></a>方法类（不建议使用）</h4><h5 id="with"><a href="#with" class="headerlink" title="with"></a>with</h5><ul><li>用with从对象创建出的作用域仅在with声明中而非外部作用域中有效。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function foo(obj) &#123;</div><div class="line">    with (obj) &#123;</div><div class="line">        var a = 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var o1 = &#123;</div><div class="line">    a: 3</div><div class="line">&#125;;</div><div class="line">var o2 = &#123;</div><div class="line">    b: 3</div><div class="line">&#125;;</div><div class="line">foo( o1 );</div><div class="line">console.log( o1.a );</div><div class="line"></div><div class="line">foo( o2 );</div><div class="line">console.log( o2.a );</div><div class="line">console.log( a );</div></pre></td></tr></table></figure></li></ul><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a>try/catch</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line">undefined();//执行一个非法操作来强制制造一个异常</div><div class="line">&#125;</div><div class="line">catch(err)&#123;</div><div class="line">console.log(err)//能够正常执行</div><div class="line">&#125;</div><div class="line">console.log(err);</div></pre></td></tr></table></figure><h4 id="ES6中的块级作用域"><a href="#ES6中的块级作用域" class="headerlink" title="ES6中的块级作用域"></a>ES6中的块级作用域</h4><blockquote><p>将代码在函数中隐藏的信息扩展为在块中隐藏起来。</p></blockquote><h5 id="let-不能重复声明"><a href="#let-不能重复声明" class="headerlink" title="let(不能重复声明)"></a>let(不能重复声明)</h5><blockquote><p>let关键字可以将变量绑定到所在的任意作用域中。</p></blockquote><ul><li><p>垃圾回收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function process(data)&#123;</div><div class="line">  //在这里做点有趣的事情</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;//在这个块中定义的内容完事可以销毁</div><div class="line">  let someReallyBigData=&#123;...&#125;;</div><div class="line">  process(someReallyBigData);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>let循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(let i=0;i&lt;10;i++)&#123;</div><div class="line">   console.log(i);</div><div class="line">&#125;</div><div class="line">console.log(i);</div></pre></td></tr></table></figure></li></ul><h5 id="const（不能重复声明）"><a href="#const（不能重复声明）" class="headerlink" title="const（不能重复声明）"></a>const（不能重复声明）</h5><ul><li>定义一个该块的常量，不能修改值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var foo = true;</div><div class="line"></div><div class="line">if (foo) &#123;</div><div class="line">    var a = 2;</div><div class="line">    const b = 3;</div><div class="line">    a = 3;</div><div class="line">    b = 4;</div><div class="line">&#125;</div><div class="line">console.log(a);</div><div class="line">console.log(b);</div></pre></td></tr></table></figure><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><blockquote><p>因为作用域是一套用于确定在何处以及如何查找变量的规则，我对作用域链的理解就是查找变量所走的路。</p></blockquote><h3 id="建筑"><a href="#建筑" class="headerlink" title="建筑"></a>建筑</h3><p><img src="http://i1.piimg.com/567571/5d27ab14bdca83a3.png" alt="作用域链建筑型"></p><blockquote><p>根据这个图来理解，就是查找变量所爬的楼。</p></blockquote><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><blockquote><p>爬楼太累了，我们再看看用画树的方法再来看看。</p></blockquote><ul><li>绘制规则<ul><li>作用域链就是对象的数组</li><li>全局作用域是0级链，每个对象占一个位置</li><li>凡是看到函数延伸一个链出来，一级级展开</li><li>访问首先看当前函数，如果没有定义往上一级链检查</li><li>如此往复，直到0级链</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">var func1 = function() &#123;</div><div class="line">    var num = 20;</div><div class="line">    var func2 = function() &#123;</div><div class="line">        var num = 30;</div><div class="line">        console.log(num);</div><div class="line">    &#125;;</div><div class="line">    func2();</div><div class="line">&#125;;</div><div class="line">var func2 = function() &#123;</div><div class="line">    var num = 20;</div><div class="line">    var func3 = function() &#123;</div><div class="line">        console.log(num);</div><div class="line">    &#125;;</div><div class="line">    func3();</div><div class="line">&#125;;</div><div class="line">func1();</div><div class="line">func2();</div></pre></td></tr></table></figure><blockquote><p>现场绘制一波</p></blockquote><h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><blockquote><p>形成变量提升现象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">var func = function() &#123;</div><div class="line">    console.log(num);</div><div class="line">    var num = 20;</div><div class="line">    console.log(num);</div><div class="line">&#125;;</div><div class="line">func();</div></pre></td></tr></table></figure></p><p>函数提升<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var func = function() &#123;</div><div class="line"> console.log(&quot;调用外面的函数&quot;);</div><div class="line">&#125;;</div><div class="line">var foo = function() &#123;</div><div class="line">    func();</div><div class="line">    var func = function() &#123;</div><div class="line">        console.log(&quot;调用内部的函数&quot;);</div><div class="line">    &#125;;</div><div class="line">    func();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>预解析：在当前作用域下,js运行之前，会把带有var和function关键字的事先声明，并在内存中安排好，然后再从上到下执行js语句。预解析只会发生在通过var定义的变量和function上。</p></blockquote><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><ul><li>只要是通过var定义的，不管是变量，还是函数，都是先赋值undefined，如果是变量，也不管变量有没有赋值，在预解析阶段，都是会被赋值为undefined。</li></ul><h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><ul><li>function进行预解析的时候，不仅是声明而且还定义了，但是它存储的数据的那个空间里面存储的是代码是字符串，没有任何意义。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function fun() &#123;</div><div class="line">    //代码区</div><div class="line">&#125;();</div></pre></td></tr></table></figure><ul><li><p>定义一个函数想要立即执行，写成上面的形式是不可行的，在预解释的时候，它把它分解成两部分来对待，第一部分是fun函数，而第二部分是(),一个匿名函数，执行时会报错。如果小括号带参数，如(2)，虽然不会报错，会打印出来2，但并不能把fn执行，也不能当成参数传递给fn函数。</p></li><li><p>如果你想实现立即执行的函数，可以把要执行的函数放到一对括号里面，对于JavaScript 来说，括弧()里面不能包含语句，所以在这一点上，解析器在解析function关键字的时候，会将相应的代码解析成function表达式，而不是function声明所以，只要将大括号将代码(包括函数部分和在后面加上一对大括号)全部括起来就可以了。 如下：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function fun() &#123;</div><div class="line">    //代码区</div><div class="line">&#125;());</div></pre></td></tr></table></figure><ul><li>预解析是发生在当前作用域下的，刚开始的时候，我们预解析的是全局作用域，在js中我们的global就是我们的window。</li><li>我们运行函数的时候会生成一个新的私有作用域（每次执行都是新的，执行完成就销毁）这个作用域下我们可以理解为开辟了一个新的内存空间。在这个内存中我们也要执行预解析。当我们的函数执行完成后，这个内存或者作用域就会销毁。</li><li>如果在当前作用域下的一个变量没有预解析，就会向它的上一级去找，直到找到window，如果window下也没有定义，就会报错。所以，在函数内通过var定义的变量是局部变量，没有通过var定义的变量是全局变量。</li><li>预解析不会在同一个变量上重复的发生，也就是一个变量如果已经在当前作用域下预解析了，不会再重复解析。</li><li>等号右边的function不会进行预解析。</li><li>预解释是不受其它if或者其它判断条件影响的，也就是说，即使条件不成立，我们里面只要有var或者function也会被预解释。</li><li>后面定义的会覆盖前面定义的。</li></ul><h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">// 例子一</div><div class="line">if(!(&quot;a&quot; in window))&#123;</div><div class="line">    var a = &quot;李玉华&quot;；</div><div class="line">&#125;</div><div class="line">console.log(a);</div><div class="line"></div><div class="line">// 例子二</div><div class="line">function fn()&#123;</div><div class="line">    console.log(&quot;我们是全局的fn&quot;);</div><div class="line">&#125;</div><div class="line">function fn2()&#123;</div><div class="line">    console.log(fn);</div><div class="line">    fn = 3;</div><div class="line">    return ;</div><div class="line">    function fn()&#123;</div><div class="line">    console.log(&quot;我是fn2里面的&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">fn2();</div><div class="line"></div><div class="line">// 例子三</div><div class="line">var n = 0;</div><div class="line">function a()&#123;</div><div class="line">    var n = 10;</div><div class="line">    function b()&#123;</div><div class="line">        n++;</div><div class="line">        console.log(n);</div><div class="line">    &#125;</div><div class="line">    b();</div><div class="line">    return b;</div><div class="line">&#125;</div><div class="line">var c = a(); </div><div class="line">c(); </div><div class="line">console.log(n); </div><div class="line"></div><div class="line">// 例子四</div><div class="line">var n = 99;</div><div class="line">function outer()&#123;</div><div class="line">    var n = 0;</div><div class="line">    return function inner()&#123;</div><div class="line">    return n++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var c = outer(); </div><div class="line">var num1 = c();</div><div class="line">var num2 = c();</div><div class="line">var d = outer();</div><div class="line">var num3 = d();</div><div class="line">console.log(c);</div><div class="line">console.log(num1);</div><div class="line">console.log(num2);</div><div class="line">console.log(d);</div><div class="line">console.log(num3);</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>作用域就是根据标识符查找变量的一套规则。（路标）</strong></li><li><strong>作用域链就是找变量所走的路径。</strong></li><li><strong>预解析就是万恶的“VIP”。</strong></li></ul><h2 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h2><ul><li>ReferenceError作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。</li><li>参考链接<ul><li><a href="http://www.jb51.net/article/55435.htm" target="_blank" rel="external">作用域和作用域链</a></li><li><a href="http://www.jianshu.com/p/2d548a45685c" target="_blank" rel="external">块级作用域</a></li><li><a href="https://frannieyi.github.io/2017/08/02/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8E%9F%E5%9E%8B/" target="_blank" rel="external">作用域和原型</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;它是一套规则，这套规则用来管理引擎如何在当前作用域及嵌套的子作用域中根据标识符名称进行变量的查找。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="分享" scheme="http://yangkunyi.com/tags/%E5%88%86%E4%BA%AB/"/>
    
      <category term="作用域" scheme="http://yangkunyi.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="作用域链" scheme="http://yangkunyi.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    
      <category term="预解析" scheme="http://yangkunyi.com/tags/%E9%A2%84%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>作用域和原型</title>
    <link href="http://yangkunyi.com/2017/08/02/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8E%9F%E5%9E%8B/"/>
    <id>http://yangkunyi.com/2017/08/02/作用域和原型/</id>
    <published>2017-08-02T11:29:16.000Z</published>
    <updated>2017-12-02T06:47:04.776Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是作用域？"><a href="#什么是作用域？" class="headerlink" title="什么是作用域？"></a>什么是作用域？</h3><a id="more"></a><blockquote><p>它是一套规则，这套规则用来管理引擎如何在当前作用域及嵌套的子作用域中根据标识符名称进行变量的查找。</p></blockquote><h4 id="先介绍一下RHS和LHS"><a href="#先介绍一下RHS和LHS" class="headerlink" title="先介绍一下RHS和LHS"></a>先介绍一下RHS和LHS</h4><ul><li>这是引擎的两种查找类型</li><li>“R”和“L”分别代表赋值操作的右侧和左侧</li><li><strong>案例</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo(a)&#123;//对a进行LHS引用2</div><div class="line">    console.log(a);</div><div class="line">    //对console进行RHS引用3</div><div class="line">    //对a进行RHS引用4</div><div class="line">&#125;</div><div class="line">foo(2);//对foo进行RHS引用1</div></pre></td></tr></table></figure><ul><li>当变量还没有声明的时候（在任何作用域都找不到该变量），这两种查询的行为是不一样的：LHS查询会在全局作用域中自己创建一个变量。RHS查询会抛出一个ReferenceError错误。</li></ul><h4 id="作用域的嵌套"><a href="#作用域的嵌套" class="headerlink" title="作用域的嵌套"></a>作用域的嵌套</h4><blockquote><p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。这一就形成了一条作用域链。</p></blockquote><ul><li><p><strong>案例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo(a)&#123;</div><div class="line">    console.log(a+b);</div><div class="line">&#125;</div><div class="line">var b=2;</div><div class="line">foo(2);//4</div></pre></td></tr></table></figure></li><li><p><strong>将作用域链比喻成一个建筑</strong></p></li></ul><p><img src="http://i1.piimg.com/567571/5d27ab14bdca83a3.png" alt="作用域链"></p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><ul><li>词法作用域是由你写代码时将变量和块作用域写在哪里来决定的。</li><li><strong>案例</strong><br><img src="http://i1.piimg.com/567571/abb987dd184464f7.jpg" alt="三级逐步嵌套的作用域"></li></ul><h4 id="JavaScript中有两个机制可以“欺骗”词法作用域"><a href="#JavaScript中有两个机制可以“欺骗”词法作用域" class="headerlink" title="JavaScript中有两个机制可以“欺骗”词法作用域"></a>JavaScript中有两个机制可以“欺骗”词法作用域</h4><ul><li><p>eval() 例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function foo(str, a) &#123;</div><div class="line">    eval( str ); // 欺骗！</div><div class="line">    console.log( a, b );</div><div class="line">&#125;</div><div class="line">var b = 2;</div><div class="line">foo( &quot;var b = 3;&quot;, 1 );</div><div class="line"></div><div class="line">//严格模式</div><div class="line">// function foo(str) &#123;</div><div class="line">//    &quot;use strict&quot;;</div><div class="line">//    eval( str );</div><div class="line">//    console.log( a ); // ReferenceError: a is not defined</div><div class="line">// &#125;</div><div class="line"></div><div class="line">foo( &quot;var a = 2&quot;);</div></pre></td></tr></table></figure></li><li><p>with() 例子：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function foo(obj) &#123;</div><div class="line">    with (obj) &#123;</div><div class="line">        var a = 2;</div><div class="line">    &#125;</div><div class="line">    // a = 2;</div><div class="line">&#125;</div><div class="line">var o1 = &#123;</div><div class="line">    a: 3</div><div class="line">&#125;;</div><div class="line">var o2 = &#123;</div><div class="line">    b: 3</div><div class="line">&#125;;</div><div class="line">foo( o1 );</div><div class="line">console.log( o1.a );</div><div class="line"></div><div class="line">foo( o2 );</div><div class="line">console.log( o2.a );</div><div class="line">console.log( a );</div></pre></td></tr></table></figure><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><ul><li>在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。</li><li><strong>案例</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a=2;</div><div class="line">function foo()&#123;</div><div class="line">    var a=3;</div><div class="line">    console.log(a);//3</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line">console.log(a);//2</div></pre></td></tr></table></figure><ul><li>不足之处：<ul><li>必须声明一个foo函数，这个foo“污染”了所在作用域。</li><li>必须显示调用才能运行其中的代码</li></ul></li><li><strong>改进</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a=2;</div><div class="line">(function foo()&#123;</div><div class="line">    var a=3;</div><div class="line">    console.log(a);//3</div><div class="line">&#125;)();</div><div class="line">console.log(a);//2</div><div class="line">//函数会被当作函数表达式而不是一个标准的函数声明来处理。</div></pre></td></tr></table></figure><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><ul><li>优点：<ul><li>书写起来简单快捷</li></ul></li><li>缺点：<ul><li>匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。</li><li>如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用。（callee是arguments对象的一个属性。它可以用于引用该函数的函数体内当前正在执行的函数。）</li><li>匿名函数省略了对于代码可读性/可理解性很重要的函数名。</li></ul></li></ul><h4 id="立即执行函数表达式"><a href="#立即执行函数表达式" class="headerlink" title="立即执行函数表达式"></a>立即执行函数表达式</h4><ul><li>IIFE(Immediately Invoked Function Expression)：<code>(function foo(){...})()</code></li><li>函数名对IIFE来说不是必须的：<code>(function(){...}())</code></li><li>进阶用法：当作函数调用并传参数进去。</li><li>例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></li></ul><h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><blockquote><p>块作用域将代码在函数中隐藏的信息扩展为在块中隐藏起来。</p></blockquote><ul><li><strong>思考</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for(var i=0;i&lt;10;i++)&#123;</div><div class="line">    console.log(i);</div><div class="line">&#125;</div><div class="line">console.log(i);</div><div class="line">//为什么要把一个只在for循环内部使用（至少是应该只在内部使用）的变量i“污染”到整个作用域（不管是函数还是全局）中？</div></pre></td></tr></table></figure><ul><li>with：用with从对象创建出的作用域仅在with声明中而非外部作用域中有效。</li><li>try/catch：例子：try.html</li><li>let：let关键字可以将变量绑定到所在的任意作用域中。<ul><li>垃圾回收</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function process(data)&#123;</div><div class="line">  //在这里做点有趣的事情</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;//在这个块中定义的内容完事可以销毁</div><div class="line">  let someReallyBigData=&#123;...&#125;;</div><div class="line">  process(someReallyBigData);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>let循环</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(let i=0;i&lt;10;i++)&#123;</div><div class="line">   console.log(i);</div><div class="line">&#125;</div><div class="line">console.log(i);ReferenceError</div></pre></td></tr></table></figure><ul><li>const：定义一个该块的常量，不能修改值。例子：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var person = function(name)&#123;</div><div class="line">    this.name = name</div><div class="line">&#125;;</div><div class="line">person.prototype.getName = function()&#123;</div><div class="line">    console.log(this.name);</div><div class="line">&#125;</div><div class="line">var zjh = new person(&apos;zhangjiahao&apos;);</div><div class="line">zjh.getName(); //zhangjiahao</div></pre></td></tr></table></figure><h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型[prototype]"></a>原型[prototype]</h2><h3 id="普通对象和函数对象"><a href="#普通对象和函数对象" class="headerlink" title="普通对象和函数对象"></a>普通对象和函数对象</h3><ul><li>JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var o1 = &#123;&#125;; </div><div class="line">var o2 =new Object();</div><div class="line">var o3 = new f1();</div><div class="line"></div><div class="line">function f1()&#123;&#125;; </div><div class="line">var f2 = function()&#123;&#125;;</div><div class="line">var f3 = new Function(&apos;str&apos;,&apos;console.log(str)&apos;);</div><div class="line"></div><div class="line">console.log(typeof Object); //function </div><div class="line">console.log(typeof Function); //function  </div><div class="line"></div><div class="line">console.log(typeof f1); //function </div><div class="line">console.log(typeof f2); //function </div><div class="line">console.log(typeof f3); //function   </div><div class="line"></div><div class="line">console.log(typeof o1); //object </div><div class="line">console.log(typeof o2); //object </div><div class="line">console.log(typeof o3); //object</div></pre></td></tr></table></figure><ul><li>怎么区分，其实很简单，<strong>凡是通过new&nbsp;Function()创建的对象都是函数对象，其他的都是普通对象。f1,f2,归根结底都是通过new&nbsp;Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的。</strong></li></ul><h3 id="什么是prototype？"><a href="#什么是prototype？" class="headerlink" title="什么是prototype？"></a>什么是<code>prototype</code>？</h3><blockquote><p>在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个<code>prototype</code>属性，这个属性指向函数的原型对象。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;</div><div class="line">    Person.prototype.name = &apos;Zaxlct&apos;;</div><div class="line">    Person.prototype.age  = 28;</div><div class="line">    Person.protetype.job  = &apos;Software Engineer&apos;;</div><div class="line">    Person.prototype.sayName = function() &#123;</div><div class="line">      alert(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">person1.sayName(); // &apos;Zaxlct&apos;</div><div class="line"></div><div class="line">var person2 = new Person();</div><div class="line">person2.sayName(); // &apos;Zaxlct&apos;</div><div class="line"></div><div class="line">console.log(person1.sayname == person2.sayname); //true</div></pre></td></tr></table></figure><ul><li>只有函数对象才有 <code>prototype</code> 属性</li></ul><h3 id="什么是原型对象？"><a href="#什么是原型对象？" class="headerlink" title="什么是原型对象？"></a>什么是原型对象？</h3><blockquote><p>原型对象，顾名思义，它就是一个普通对象。从现在开始你要牢牢记住原型对象就是 <code>Person.prototype</code>，如果你还是记不住，那就把它想想成一个字母 A： <code>var A = Person.prototype;</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Person.prototype = &#123;</div><div class="line">   name:  &apos;Zaxlct&apos;,</div><div class="line">   age: 28,</div><div class="line">   job: &apos;Software Engineer&apos;,</div><div class="line">   sayName: function() &#123;</div><div class="line">     alert(this.name);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>在默认情况下，所有的原型对象都会自动获得一个<code>constructor</code>（构造函数）属性，这个属性（是一个指针）指向 <code>prototype</code> 属性所在的函数（Person）</p></blockquote><ul><li><p><strong>原型对象（Person.prototype）是 构造函数（Person）的一个实例。</strong></p></li><li><p>那原型对象是用来做什么的呢？举个例子：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var person = function(name)&#123;</div><div class="line">    this.name = name</div><div class="line">&#125;;</div><div class="line">person.prototype.getName = function()&#123;</div><div class="line">    return this.name;</div><div class="line">&#125;</div><div class="line">var zjh = new person(‘zhangjiahao’);</div><div class="line">zjh.getName(); //zhangjiahao</div></pre></td></tr></table></figure><ul><li>从这个例子可以看出，通过给<code>person.prototype</code>设置了一个函数对象的属性，那由<code>person</code>实例（例中：zjh）出来的普通对象就继承了这个属性。<strong>所以原型对象的主要作用就是用于继承。</strong></li><li>具体是怎么实现的继承，就要讲到下面的原型链了。</li></ul><h3 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h3><ul><li>JS在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做__proto__的内置属性，用于指向创建它的函数对象的原型对象prototype。例如：<ul><li><code>console.log(zjh.__proto__ === person.prototype) //true</code></li></ul></li><li>同样，person.prototype对象也有__proto__属性，它指向创建它的函数对象（Object）的prototype<ul><li><code>console.log(person.prototype.__proto__ === Object.prototype) //true</code></li></ul></li><li>继续，Object.prototype对象也有__proto__属性，但它比较特殊，为null<ul><li><code>console.log(Object.prototype.__proto__) //null</code> </li></ul></li><li><strong>我们把这个有<strong>proto</strong>串起来的直到Object.prototype.<strong>proto</strong>为null的链叫做原型链。</strong><br><img src="http://i2.muimg.com/567571/055ff751adbbf734.jpg" alt="原型链"></li></ul><h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><ul><li>ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。</li><li>区分函数声明和表达式最简单的方法是看function关键字出现在声明这哦那个的位置（不仅仅是一行代码，而是整个声明中的位置）。如果function是在声明的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</li><li>作用域理解基于《你不知道的Javascript 上卷》</li><li>原型理解基于文章<a href="http://www.jianshu.com/p/dee9f8b14771" target="_blank" rel="external">原型与原型链</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是作用域？&quot;&gt;&lt;a href=&quot;#什么是作用域？&quot; class=&quot;headerlink&quot; title=&quot;什么是作用域？&quot;&gt;&lt;/a&gt;什么是作用域？&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yangkunyi.com/tags/Javascript/"/>
    
      <category term="分享" scheme="http://yangkunyi.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>JavaSccript语言精粹</title>
    <link href="http://yangkunyi.com/2017/07/20/JavaSccript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9/"/>
    <id>http://yangkunyi.com/2017/07/20/JavaSccript语言精粹/</id>
    <published>2017-07-20T07:01:07.000Z</published>
    <updated>2017-12-02T06:41:53.610Z</updated>
    
    <content type="html"><![CDATA[<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><a id="more"></a><ul><li>字符串是不可变的。一旦被创建就永远无法改变。</li><li>typeof运算符产生的值有‘number’ ‘string’ ‘boolean’ ‘undefined’ ‘function’ ‘object’。</li><li>一个属性存取表达式用于指定一个对象或数值的属性或元素。</li><li>原型连接只有在检索值的时候才被用到。如果我们尝试弃获取对象的某个属性值，但该对象没有此属性名，那么JavaScript会试着从原型对象中获取属性值。如果那个原型对象也没有该属性，那么再从它的原型中寻找，依次类推，只到该过程最后到达终点Object.prototype。如果想要的属性完全不存在于原型练中，那么结果就是undefined值。这个过程为<strong>委托</strong>。</li><li>用for in的方法来遍历一个对象中的所有属性名，属性名出现的顺序是不确定的，因此要对任何可能出现的顺序有所准备。若想自定义顺序最好的方式是避免使用for in，而是通过建立数组的形式将属性存入，然后用for循环从数组中依次获取属性。这样也不用担心可能发掘出原型链中的属性，并且我们按正常的顺序取得了它的值。</li><li>最小化使用全局变量的方法之一是为你的应用只创建一个唯一的全局变量。资源都纳入一个名称空间之下，你的程序与其他应用程序、组件或类库之间发生冲突的可能性就会显著降低。</li><li>函数对参数值不会进行类型检查：任何类型的值都可以被传递给任何参数。</li><li>apply方法让我们构建一个参数数组传递给调用函数。</li><li>因为语言的一个设计错误，arguments并不是一个真正的数组。它只是一个“类似数组（array-like）”的对象。arguments拥有一个length属性，但它没有任何数组的方法。</li><li><strong>尾递归</strong>是一种在函数的最后执行递归调用语句的特殊形式的递归。</li><li>作用域的好处是内部函数可以访问定义它们外部函数的参数和变量（除了this和arguments）。</li><li><strong>继承</strong>的两种服务：<ul><li>是代码重用的一种形式。（如果一个新的类与一个已经存在的类大部分相似，那么你只需要具体说明其不同点即可。代码重用的模式极为重要，因为它们可以显著的减少软件开发的成本。）</li><li>另一个好处是引入了一套类型系统的规范。（由于程序员无需编写显式类型转换的代码，他们的工作量将大大减轻，这是一件很好的事情，因为类型转换会丧失类型系统在安全上的优势。）</li></ul></li><li>构造一个生成对象的函数：<ul><li>1.创建一个新的对象。</li><li>2.有选择地定义私有的实例变量和放方法。</li><li>3.给这个新对象扩充方法。</li><li>4.返回那个新对象。</li></ul></li><li>数组的length属性的值是这个数组的最大整数属性名加上1，它不一定等于数组里属性的个数。</li><li>for in 用来遍历数组的所有属性，但遗憾的是，for in 无法保证属性的顺序。</li><li>数组和对象的使用区别：当属性名是小而连续的整数时，你应该使用数组；否则，使用数组。</li><li>排序的稳定性是指排序后的数组中相等值的相对位置没有发生改变，而不稳定性排序则会改变相等值的相对位置。</li></ul><h3 id="方法篇"><a href="#方法篇" class="headerlink" title="方法篇"></a>方法篇</h3><h5 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h5><ul><li>array.concat(item…):产生新的数组，和它类似功能的array.push(item)。</li><li>array.join(separator):把一个array构造成一个字符串。</li><li>array.pop():移除数组的最后一个元素，并返回这个元素。</li><li>array.push(item…):把一个或多个参数item附加到一个数组的尾部。</li><li>array.reverse():反转array里的元素的顺序，并返回array本身。</li><li>array.shift():移除数组array中的第一个元素，并返回该元素。</li><li>array.slice(start,end):对array中的一段做浅复制。</li><li>array.sort(comparefn):对array中的内容进行排序。</li><li>array.splice(start,deleteCount,item…):从array中移除一个或多个元素，并用新的item替换它们。</li><li>array.unshift(item…):像push方法一样，用于把元素添加到数组中，但它是把item插入到array的开始部分，不是尾部。返回array的新的length。</li></ul><h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><ul><li>function.apply(thisArg,argArray):调用function，传递一个会被绑定到this上的对象和一个可选的数组作为参数。</li></ul><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><ul><li>number.toExponential(fractionDigits):把这个number转换成一个指数形式的字符串。</li><li>number.toFixed(fractionDigits):把这个number转换成为一个十进制数形式的字符串。可选择参数控制其小数点后的数字位数。</li><li>number.toPrecision(precision):把这个number转换成一个十进制数形式的字符串。可选择参数控制数字的精度（0~21）。</li><li>number.toString(radix):把这个number转换成字符串。可选择参数控制基数（2~36，默认是10）。</li></ul><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><ul><li>object.hasOwnProperty(name):判断属性是否存在，不会检查原型链中的同名属性。</li></ul><h4 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h4><ul><li>regexp.exec(string):最强大（和最慢），看书理解。</li><li>regexp.test(string):最简单（和最快），匹配就返回true，否则返回false，不要对这个方法使用g标识。</li></ul><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul><li>string.charAt(pos):返回在string中pos位置处的字符。</li><li>string。charCodeAt(pos):返回在string中pos位置的字符的字符码位（以整数形式表示）。</li><li>string.conecat(string…):把其他的字符串连接在一起来构造一个新的字符串。</li><li>string.indexOf(searchString,postion):在string中查找另一个字符串searchString。找到就返回第一个匹配字符的位置，否则返回-1。可选参数position从字符串的哪个位置开始查找。</li><li>string.lastIndexOf(searchString,position):从字符串的末尾开始查找。</li><li>string.lacaleCompare(that):比较两个字符串。</li><li>string.match(regexp):让字符串和一个正则表达式进行匹配。</li><li>string.replace(searchValue,replaceValue):对string进行查找和替换操作，并返回一个新的字符串（如果searchValue不是一个带有g标识的正则表达式那就只会替换第一个）。</li><li>string.search(regexp):接收一个正则表达式作为对象参数返回匹配的首字符位置。</li><li>string.slice(start,end):复制string的一部分来构造一个新的字符串。</li><li>string.split(separator,limit):把这个string分割成片段来创建一个字符串数组。</li><li>string.substring(start,end):和slice方法一样，只是他不能处理负数参数。</li><li>string.toLocaleLowerCase():返回一个新字符串，使用本地化的规则将这个string中所有字母转换成小写格式。</li><li>string.toLacaleUpperCase():返回一个新字符串，使用本地化的规则将这个string中所有字母转换成大写格式。</li><li>string.toLowerCase():返回一个新的字符串，这个string中所有字母都被转换为小写格式。</li><li>string.toUpperCase():返回一个新的字符串，这个strnig中所有字母都被转换为大写格式。</li><li>string.fromCharCode(char…):函数根据一串数字编码返回一个字符串。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h3&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yangkunyi.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>vue2.0生命周期</title>
    <link href="http://yangkunyi.com/2017/06/02/vue2-0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yangkunyi.com/2017/06/02/vue2-0生命周期/</id>
    <published>2017-06-02T02:03:58.000Z</published>
    <updated>2017-12-02T06:47:13.236Z</updated>
    
    <content type="html"><![CDATA[<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><a id="more"></a><p><img src="http://i4.buimg.com/519918/2060f4c49f431cd5.png" alt="lifecycle"></p><h3 id="函数解释"><a href="#函数解释" class="headerlink" title="函数解释"></a>函数解释</h3><ul><li><p><code>beforeCreate</code><br>在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。</p></li><li><p><code>created</code><br>实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</p></li><li><p><code>beforeMount</code><br>在挂载开始之前被调用：相关的 render 函数首次被调用。</p></li><li><p><code>mounted</code><br>el 被新创建的vm.\$el替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</p></li><li><p><code>beforeUpdate</code><br>数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</p></li><li><p><code>updated</code><br>由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。</p></li><li><p><code>beforeDestroy</code><br>实例销毁之前调用。在这一步，实例仍然完全可用。</p></li><li><p><code>destroyed</code><br>Vue 实例销毁后调用。调用后，Vue实例指示的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p></li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;&lt;/title&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/vue/2.1.3/vue.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line"></div><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">     &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line"></div><div class="line">  var app = new Vue(&#123;</div><div class="line">      el: &apos;#app&apos;,</div><div class="line">      data: &#123;</div><div class="line">          message : &quot;Hello!&quot;</div><div class="line">      &#125;,</div><div class="line">       beforeCreate: function () &#123;</div><div class="line">                console.group(&apos;beforeCreate 创建前状态===============》&apos;);</div><div class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot; , &quot;el     : &quot; + this.$el); //undefined</div><div class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //undefined</div><div class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message)</div><div class="line">        &#125;,</div><div class="line">        created: function () &#123;</div><div class="line">            console.group(&apos;created 创建完毕状态===============》&apos;);</div><div class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el); //undefined</div><div class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //已被初始化</div><div class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化</div><div class="line">        &#125;,</div><div class="line">        beforeMount: function () &#123;</div><div class="line">            console.group(&apos;beforeMount 挂载前状态===============》&apos;);</div><div class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + (this.$el)); //已被初始化</div><div class="line">            console.log(this.$el);</div><div class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //已被初始化</div><div class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化</div><div class="line">        &#125;,</div><div class="line">        mounted: function () &#123;</div><div class="line">            console.group(&apos;mounted 挂载结束状态===============》&apos;);</div><div class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el); //已被初始化</div><div class="line">            console.log(this.$el);</div><div class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //已被初始化</div><div class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化</div><div class="line">        &#125;,</div><div class="line">        beforeUpdate: function () &#123;</div><div class="line">            console.group(&apos;beforeUpdate 更新前状态===============》&apos;);</div><div class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);</div><div class="line">            console.log(this.$el);</div><div class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data);</div><div class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message);</div><div class="line">        &#125;,</div><div class="line">        updated: function () &#123;</div><div class="line">            console.group(&apos;updated 更新完成状态===============》&apos;);</div><div class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);</div><div class="line">            console.log(this.$el);</div><div class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data);</div><div class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message);</div><div class="line">        &#125;,</div><div class="line">        beforeDestroy: function () &#123;</div><div class="line">            console.group(&apos;beforeDestroy 销毁前状态===============》&apos;);</div><div class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);</div><div class="line">            console.log(this.$el);</div><div class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data);</div><div class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message);</div><div class="line">        &#125;,</div><div class="line">        destroyed: function () &#123;</div><div class="line">            console.group(&apos;destroyed 销毁完成状态===============》&apos;);</div><div class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);</div><div class="line">            console.log(this.$el);</div><div class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data);</div><div class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message)</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><ul><li>用浏览器打开</li></ul><blockquote><p>beforecreated：el 和 data 并未初始化<br>created:完成了 data 数据的初始化，el没有<br>beforeMount：完成了 el 和 data 初始化<br>mounted ：完成渲染</p></blockquote><ul><li><p>关于更新<code>app.message= &#39;vue&#39;;</code></p></li><li><p>关于销毁<code>app.$destroy();</code></p></li></ul><blockquote><p>销毁完成后，我们再重新改变message的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在。可以这么理解，执行了destroy操作，后续就不再受vue控制了。</p></blockquote><ul><li>生命周期函数的一些用法</li></ul><blockquote><p>beforecreate : 举个栗子：可以在这加个loading事件<br>created ：在这结束loading，还做一些初始化，实现函数自执行<br>mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情<br>beforeDestory： 你确认删除XX吗？<br>destoryed ：当前组件已被删除，清空相关内容</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;图解&quot;&gt;&lt;a href=&quot;#图解&quot; class=&quot;headerlink&quot; title=&quot;图解&quot;&gt;&lt;/a&gt;图解&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yangkunyi.com/tags/Javascript/"/>
    
      <category term="分享" scheme="http://yangkunyi.com/tags/%E5%88%86%E4%BA%AB/"/>
    
      <category term="vue" scheme="http://yangkunyi.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>坎帕斯学院日常讨论</title>
    <link href="http://yangkunyi.com/2017/04/16/%E5%9D%8E%E5%B8%95%E6%96%AF%E5%AD%A6%E9%99%A2%E6%97%A5%E5%B8%B8%E8%AE%A8%E8%AE%BA-1/"/>
    <id>http://yangkunyi.com/2017/04/16/坎帕斯学院日常讨论-1/</id>
    <published>2017-04-16T08:14:15.000Z</published>
    <updated>2017-12-02T06:46:40.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="话题：width：100-和width：auto的区别"><a href="#话题：width：100-和width：auto的区别" class="headerlink" title="话题：width：100%和width：auto的区别"></a>话题：width：100%和width：auto的区别</h2><a id="more"></a><h4 id="width：100"><a href="#width：100" class="headerlink" title="width：100%"></a>width：100%</h4><ul><li>元素宽度等于父级元素的宽度。</li></ul><h4 id="width：auto"><a href="#width：auto" class="headerlink" title="width：auto"></a>width：auto</h4><ul><li>元素的宽度等于父元素的宽度减去margin，padding，border这些。</li></ul><h4 id="高度知识点"><a href="#高度知识点" class="headerlink" title="高度知识点"></a>高度知识点</h4><ul><li>子元素的margin和padding百分比知识点根据父元素的width来算。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//test1</div><div class="line">&lt;style&gt;</div><div class="line">    body&#123;</div><div class="line">        margin:0;</div><div class="line">        padding:0;</div><div class="line">    &#125;</div><div class="line">    .main&#123;</div><div class="line">        width:500px;</div><div class="line">        background:red;</div><div class="line">    &#125;</div><div class="line">    .test&#123;</div><div class="line">        width:auto;</div><div class="line">        padding:20px;</div><div class="line">        margin:10px;</div><div class="line">        border:5px solid blue;</div><div class="line">        background:green;</div><div class="line">    &#125;</div><div class="line">&lt;/style&gt;</div><div class="line"></div><div class="line">&lt;div class=&quot;main&quot;&gt;</div><div class="line">    &lt;div class=&quot;wrap&quot;&gt;</div><div class="line">        &lt;div class=&quot;test&quot;&gt;123&lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></li></ul><p>test width=父元素width-margin-padding-border</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//test2</div><div class="line">&lt;style&gt;</div><div class="line">    body&#123;</div><div class="line">        margin:0;</div><div class="line">        padding:0;</div><div class="line">    &#125;</div><div class="line">    .main&#123;</div><div class="line">        display:inline-block;</div><div class="line">        background:red;</div><div class="line">    &#125;</div><div class="line">    .test&#123;</div><div class="line">        width:auto;</div><div class="line">        padding:20px;</div><div class="line">        margin:10px;</div><div class="line">        border:5px solid blue;</div><div class="line">        background:green;</div><div class="line">    &#125;</div><div class="line">&lt;/style&gt;</div><div class="line"></div><div class="line">&lt;div class=&quot;main&quot;&gt;</div><div class="line">    &lt;div class=&quot;wrap&quot;&gt;</div><div class="line">        &lt;div class=&quot;test&quot;&gt;123123123123123&lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p>test width=123123123123123+margin+padding+border</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//test3</div><div class="line">&lt;style&gt;</div><div class="line">    body&#123;</div><div class="line">        font-size:20px;</div><div class="line">        margin:0;</div><div class="line">        padding:0;</div><div class="line">    &#125;</div><div class="line">    .main&#123;</div><div class="line">        display:inline-block;</div><div class="line">        background:red;</div><div class="line">        width:500px;</div><div class="line">    &#125;</div><div class="line">    .test&#123;</div><div class="line">        width:auto;</div><div class="line">        padding:20px;</div><div class="line">        margin:10px;</div><div class="line">        border:5px solid blue;</div><div class="line">        background:green;</div><div class="line">    &#125;</div><div class="line">&lt;/style&gt;</div><div class="line"></div><div class="line">&lt;div class=&quot;main&quot;&gt;</div><div class="line">    &lt;div class=&quot;wrap&quot;&gt;</div><div class="line">        &lt;div class=&quot;test&quot;&gt;123123123123123&lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p>test width=500-padding-margin-border<br>这里的500px并不是继承，而是因为div块级元素的影响而来的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//test4a</div><div class="line">&lt;style type=&quot;text/css&quot;&gt;</div><div class="line">body&#123;</div><div class="line">font-size: 20px;</div><div class="line">padding: 0;</div><div class="line">margin: 0;</div><div class="line">&#125;</div><div class="line">.first1&#123;</div><div class="line">background: red;</div><div class="line">width: 200px;</div><div class="line">height: 400px;</div><div class="line">overflow: hidden;</div><div class="line">&#125;</div><div class="line">.second1&#123;</div><div class="line">height: 25%;width: 25%;</div><div class="line">margin-top: 10%;</div><div class="line">background-color: green;</div><div class="line">padding-left: 10%;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;div class=&quot;first1&quot;&gt;</div><div class="line">&lt;div class=&quot;second1&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure><p>test width=50,height=100,margin-top=20</p><h5 id="2017-4-19-21-00"><a href="#2017-4-19-21-00" class="headerlink" title="2017.4.19 21:00"></a>2017.4.19 21:00</h5><h2 id="话题：document-getElementByClassName-返回的是什么？"><a href="#话题：document-getElementByClassName-返回的是什么？" class="headerlink" title="话题：document.getElementByClassName()返回的是什么？"></a>话题：document.getElementByClassName()返回的是什么？</h2><ul><li>是一个HTML集合。</li></ul><h4 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别"></a>集合和数组的区别</h4><ul><li>HTML集合：一直与文档保持着链接，每次你需要最新的信息时，都会重复执行查询的过程，哪怕只是获取集合里的元素个数，即集合的length属性也是这样。（简单的说就是这个集合会实时改变）</li><li>案例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var alldivs document.getElementsByTagName(&apos;div&apos;);</div><div class="line">for(var i=0;i&lt;alldivs.length;i++)&#123;</div><div class="line">    document.body.appendChild(document.createElement(&apos;div&apos;));</div><div class="line">&#125;</div><div class="line">//该循环会一直循环下去，因为每次添加一个div之后，alldicvs.length的值也会改变，导致循环条件一直为true，一直循环。</div></pre></td></tr></table></figure></li></ul><h4 id="关于闭包和词法作用域"><a href="#关于闭包和词法作用域" class="headerlink" title="关于闭包和词法作用域"></a>关于闭包和词法作用域</h4><ul><li>案例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">    concile.log(a);//2</div><div class="line">&#125;</div><div class="line">function bar()&#123;</div><div class="line">    var a=3;</div><div class="line">    foo();</div><div class="line">&#125;</div><div class="line">var a=2;</div><div class="line">bar();</div><div class="line">//原理：js的运行原理是词法作用域，而非动态作用域，因此当foo函数被调用的时候，对a进行查询的时候会直接在全局作用域中查询。</div></pre></td></tr></table></figure></li></ul><h2 id="话题：display：none和visibility：hidden区别？"><a href="#话题：display：none和visibility：hidden区别？" class="headerlink" title="话题：display：none和visibility：hidden区别？"></a>话题：display：none和visibility：hidden区别？</h2><ul><li>display：none；有dom树，没有渲染树，也就是说js可以找到display：none。</li><li>visibility：hidden；只是将内容隐藏起来了，还是要占位的。</li></ul><h2 id="话题：两个inline-block元素在同一行中间的那个间距是多少？"><a href="#话题：两个inline-block元素在同一行中间的那个间距是多少？" class="headerlink" title="话题：两个inline-block元素在同一行中间的那个间距是多少？"></a>话题：两个inline-block元素在同一行中间的那个间距是多少？</h2><ul><li>每个浏览器间距不同。</li><li>字体大小不同间距不同。</li></ul><h4 id="如何去掉这个空格？"><a href="#如何去掉这个空格？" class="headerlink" title="如何去掉这个空格？"></a>如何去掉这个空格？</h4><ul><li>去掉最底层html标签的空格。</li><li>margin为负值。（每个浏览器不同，值不同）</li><li>将父级元素的字体大小设置为0。（推荐方案）</li></ul><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul><li>这个间距不仅在水平方向有，在垂直方向也有！</li><li>距离大概是字体大小的1/8（可能会有叠加）。</li><li>inline-block元素之间，block和inline-block和inline的元素之间都有间距。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;话题：width：100-和width：auto的区别&quot;&gt;&lt;a href=&quot;#话题：width：100-和width：auto的区别&quot; class=&quot;headerlink&quot; title=&quot;话题：width：100%和width：auto的区别&quot;&gt;&lt;/a&gt;话题：width：100%和width：auto的区别&lt;/h2&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yangkunyi.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="记录" scheme="http://yangkunyi.com/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="问题" scheme="http://yangkunyi.com/tags/%E9%97%AE%E9%A2%98/"/>
    
      <category term="讨论" scheme="http://yangkunyi.com/tags/%E8%AE%A8%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://yangkunyi.com/2017/04/10/%E6%95%B0%E7%BB%84/"/>
    <id>http://yangkunyi.com/2017/04/10/数组/</id>
    <published>2017-04-10T11:13:22.000Z</published>
    <updated>2017-12-02T06:45:58.287Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Array创建实例</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//用构造函数的方法</div><div class="line">var colors=new Array();</div><div class="line">var colors=new Array(20);</div><div class="line">var colors=new Array(&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;);</div><div class="line">var colors=Array();//可以省略new</div><div class="line"></div><div class="line">//用数组字面量表示法</div><div class="line">var colors=[&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;];</div><div class="line">var names=[];</div><div class="line">var values=[1,2,];//不要这样，这样会创建一个包含2或3项的数组</div><div class="line">var options=[,,,,,]//不要这样，这样会创建一个包含2或6项的数组</div></pre></td></tr></table></figure><h4 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h4><ul><li><code>Array.isArray()</code>确定一个值到底是不是数组<h4 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h4></li><li>toString()：返回有由数组中每个值得字符串形式拼接而成的一个以逗号分隔的字符串。</li><li>valueOf()：直接返回数组</li><li><p>toLocaleString()：创建一个数组值的以逗号分隔的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var colors=[&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;];</div><div class="line">alert(colors.toString());  //gray,green,red</div><div class="line">alert(colors.valueOf());   //gray,green,red</div><div class="line">alert(colors);             //gray,green,red</div><div class="line">//最后一行将数组传给alert，alert要求接受字符串，所以后台自动调用头String（）</div><div class="line"></div><div class="line">var person1=&#123;</div><div class="line">    toLocaleString:function()&#123;</div><div class="line">        return &quot;Nikolaos&quot;;</div><div class="line">    &#125;,</div><div class="line">    toString:function()&#123;</div><div class="line">        return &quot;Nicholas&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">var person2=&#123;</div><div class="line">    toLocaleString:function()&#123;</div><div class="line">        return &quot;Grigorios&quot;;</div><div class="line">    &#125;,</div><div class="line">    toString:function()&#123;</div><div class="line">        return &quot;Greg&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">var people=[person1,person2];</div><div class="line">alert(people);                       //Nicholas,Greg</div><div class="line">alert(people.toString());            //Nicholas,Greg</div><div class="line">alert(people.toLocaleString());      //Nicholas,Grigorios</div></pre></td></tr></table></figure></li><li><p>join()方法：可以用其他符号来分隔数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var colors=[&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;];</div><div class="line">alert(colors.join(&quot;,&quot;));     //gray,green,red</div><div class="line">alert(solors.join(&quot;||&quot;));    //gray||green||red</div></pre></td></tr></table></figure></li></ul><h4 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h4><ul><li>push()方法可以接受任意数量的参数，把他们逐个添加到数组末尾，并返回修改后的数组的长度。</li><li>pop()方法则是从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var colors=new Array();</div><div class="line">var count=colors.push(&quot;red&quot;,&quot;green&quot;);</div><div class="line">alert(count);            //2</div><div class="line">count=colors.push(&quot;black&quot;);</div><div class="line">alert(count);            //3</div><div class="line">var item=color.pop();</div><div class="line">alert(item);             //&quot;black&quot;;</div><div class="line">alert(colors.length);    //2</div><div class="line">//可以将栈方法和其它数组方法连用</div><div class="line">var colors=[&quot;red&quot;,&quot;blue&quot;];</div><div class="line">colors.push(&quot;brow&quot;);</div><div class="line">colors.[3]=&quot;black&quot;;</div><div class="line">alert(colors.length);    //4</div><div class="line">var item=colors.pop();</div><div class="line">alert(item);             //&quot;black&quot;</div></pre></td></tr></table></figure></li></ul><h4 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h4><ul><li>shift()方法能够移除数组中的第一项，并且返回该项，同时将数组长度减1。</li><li>unshift()方法能在数组前段端添加任意个项并返回数组长度。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var colors=new Array();</div><div class="line">var count=colors.push(&quot;red&quot;,&quot;green&quot;);</div><div class="line">alert(count);            //2</div><div class="line">var item=colors.shift();</div><div class="line">alert(item);             //&quot;red&quot;</div><div class="line">alert(colors.length);    //1</div><div class="line">count=colors.unshift(&quot;black&quot;);</div><div class="line">alert(count);            //2</div></pre></td></tr></table></figure></li></ul><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul><li>reverse()方法：反转数组项的顺序。返回值是数组。</li><li>sort()方法：按升序排列数字项。（比较的是字符串）返回值是数组。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var values=[1,2,3,4,5];</div><div class="line">values.reverse();</div><div class="line">alert(values);   //5,4,3,2,1</div><div class="line"></div><div class="line">var values=[0,1,5,10,15];</div><div class="line">values.sort();</div><div class="line">alert(values);   //0,1,10,15,5</div><div class="line">//在字符串进行比较的时候5是比10大的，这个时候我们经常让sort方法接受一个比较函数作为参考。</div><div class="line">//比较函数（升序，改变大于和小于就能变成降序）</div><div class="line">function campare(value1,value2)&#123;</div><div class="line">    if(value1&lt;value2)</div><div class="line">        return -1;</div><div class="line">    else if(value1&gt;value2)</div><div class="line">        return 1;</div><div class="line">    else</div><div class="line">        return 0;</div><div class="line">&#125;</div><div class="line">var values=[0,1,5,10,15];</div><div class="line">values.sort(campare);</div><div class="line">alert(values);   //0,1,5,10,15</div></pre></td></tr></table></figure></li></ul><h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><ul><li><p>concat()方法：创建一个新的数组。复制一遍数组并在末尾添上新的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var colors=[&quot;gray&quot;,&quot;green&quot;,&quot;red&quot;];</div><div class="line">var colors2=colors.contac(&quot;yellow&quot;,[&quot;black&quot;,&quot;brown&quot;]);</div><div class="line">alert(colors);             //gray,green,red</div><div class="line">alert(colors2);            //gray,green,red,yellow,black,brown</div></pre></td></tr></table></figure></li><li><p>slice()方法：能够基于当前数组中的一或多个项创建一个新数组。</p><ul><li>当有一个参数时：返回从该参数指定位置开始到当前数组末尾的所有项。</li><li>如果有两个参数时：返回起始和结束位置之间的项，但不包括结束为止的项。</li></ul></li><li>splice()方法：主要用途是项数组中部插入项。（最强大的数组方法）<ul><li>删除：需要两个参数，位置和删除项数。例：<code>splice(0,2);</code>删除数组中的前两项。</li><li>插入：需要三个参数，起始位置，0（删除的项数）和插入项。例：<code>splice(2,0,&quot;red,&quot;green&quot;)</code>从数组的位置2开始插入字符串”red”和”green”。</li><li>替换：需要三个参数，起始位置，要删除的的项数和要插入的任意数量的项。例：<code>splice(2，1，&quot;red&quot;,&quot;green&quot;)</code>删除当前数组位置2的项，然后再从位置2开始插入字符串。<h4 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h4></li></ul></li><li>indexOf()方法：从数组的开头开始向后查找。</li><li>lastIndexOf()方法：从数组的末尾开始向前查找。<br>两个方法都接收两个参数，要查找的项和开始查找的起始位置。没找到的情况返回-1，返回值是位置。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var numbers=[1,2,3,4,5,4,3,2,1];</div><div class="line">alert(numbers.indexOf(4));              //3</div><div class="line">alert(numbers.lastIndexOf(4));          //5</div><div class="line"></div><div class="line">alert(numbers.indexOf(4，4));           //5</div><div class="line">alert(numbers.lastIndexOf(4，4));       //3</div><div class="line"></div><div class="line">var person=&#123;name:&quot;Nicholas&quot;&#125;;</div><div class="line">var people=[&#123;name:&quot;Nicholas&quot;&#125;];</div><div class="line">var morePeople=[people];</div><div class="line">alert(people.indexOf(person));          //-1</div><div class="line">alert(morePeople.indexOf(peoson));      //0</div></pre></td></tr></table></figure></li></ul><h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><ul><li>every():对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true，否则返回false。</li><li>filter():对数组中的每一项运行给定函数，返回该函数会返回true的项组成数组。</li><li>forEach():对数组中的每一项运行给定函数，这个方法没有返回值。</li><li>map():对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li><li>some():对数组中的每一项运行给定函数，如果该函数对任意一项返回true，则返回true。<br>以上方法都不会修改数组中包含的值。都接收三个参数：数组项的值，该项在数组的位置，数组对象本身。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//every()</div><div class="line">var numbers=[1,2,3,4,5,4,3,2,1];</div><div class="line">var everyResult=numbers.every(function(item,index,array)&#123;</div><div class="line">    return (item&gt;2);</div><div class="line">&#125;);</div><div class="line">alert(everyResult);           //false</div><div class="line">//some()</div><div class="line">var numbers=[1,2,3,4,5,4,3,2,1];</div><div class="line">var someResult=numbers.every(function(item,index,array)&#123;</div><div class="line">    return (item&gt;2);</div><div class="line">&#125;);</div><div class="line">alert(someResult);           //true</div><div class="line">//filter()</div><div class="line">var numbers=[1,2,3,4,5,4,3,2,1];</div><div class="line">var filterResult=numbers.every(function(item,index,array)&#123;</div><div class="line">    return (item&gt;2);</div><div class="line">&#125;);</div><div class="line">alert(filterResult);           //[3,4,5,4,3]</div><div class="line">//map()</div><div class="line">var numbers=[1,2,3,4,5,4,3,2,1];</div><div class="line">var mapResult=numbers.every(function(item,index,array)&#123;</div><div class="line">    return item*2;</div><div class="line">&#125;);</div><div class="line">alert(mapResult);           //[2,4,6,8,10,8,6,4,2]</div><div class="line">//forEach()</div><div class="line">var numbers=[1,2,3,4,5,4,3,2,1];</div><div class="line">numbers.forEach(function(item,index,array)&#123;</div><div class="line">    //执行某些操作</div><div class="line">&#125;);</div></pre></td></tr></table></figure></li></ul><h4 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h4><ul><li>reduce():从数组的第一个开始，逐个遍历到最后。</li><li>reduceRight():从数组最后一个开始，逐个遍历到第一个。</li></ul><ol><li>这两个函数接收两个参数：一个在每一项上的调用的函数和（可选的）作为归并基础的初始值。</li><li>传给两个函数的函数接收四个参数：前一个值，当前值，项的索引，数组对象。</li><li>函数的返回值都会作为第一个参数自动传给下一项。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//reduce()正向</div><div class="line">var values=[1,2,3,4,5];</div><div class="line">var sum=values.reduce(function(prev,cur,index,array)&#123;</div><div class="line">    return prev+cur;</div><div class="line">&#125;);</div><div class="line">alert(sum);          //15</div><div class="line">//ruduceRight()反向</div><div class="line">var values=[1,2,3,4,5];</div><div class="line">var sum=values.reduceRight(function(prev,cur,index,array)&#123;</div><div class="line">    return prev+cur;</div><div class="line">&#125;);</div><div class="line">alert(sum);          //15</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Array创建实例&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yangkunyi.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://yangkunyi.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数组" scheme="http://yangkunyi.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>DOM知识点</title>
    <link href="http://yangkunyi.com/2017/04/10/DOM%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yangkunyi.com/2017/04/10/DOM知识点/</id>
    <published>2017-04-10T11:07:45.000Z</published>
    <updated>2017-12-02T06:41:06.604Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><a id="more"></a><p>D：document（文档）<br>O：object（对象）：用户定义对象，内建对象，宿主对象<br>M：model（模型）：“map”，树</p><h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><ul><li>元素节点（element node）：body，ul，li……<br>获取元素节点的方法：<ul><li>通过元素id（getElementById ）</li><li>通过标签名（getElementsByTagName）</li><li>通过类名（getElementsByClassName）</li></ul></li><li>属性节点（attribute node）<br><code>&lt;p title=&quot;yang&quot;&gt;hahahahahahha&lt;/p&gt;</code><br>title=”yang”是一个属性节点<br>属性节点总是包含在元素节点中</li><li>文本节点<h4 id="获取和设置属性"><a href="#获取和设置属性" class="headerlink" title="获取和设置属性"></a>获取和设置属性</h4></li><li><p>getAttribute（获取）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//例子</div><div class="line">var paras=document.getElementsByTagName(&quot;p&quot;);</div><div class="line">for(var i=0;i&lt;paras.lengeh;i++)&#123;</div><div class="line">    alert(paras[i].getAttribute(&quot;title&quot;));</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>setAttribute（设置）<br>若属性本不存在，实际就将完成两项操作：1.创建属性，2.设置值。<br>注：并不会改变源文件扽静态内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//例子</div><div class="line">var shopping=document.getElementById(&quot;purchases&quot;);</div><div class="line">shopping.setAttribute(&quot;title&quot;,&quot;a list of goods&quot;);</div></pre></td></tr></table></figure></li></ul><h3 id="实例：JavaScript图片库"><a href="#实例：JavaScript图片库" class="headerlink" title="实例：JavaScript图片库"></a>实例：JavaScript图片库</h3><ul><li><p>childNodes属性<br>用来获取任何一个元素的所有子元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//获取body所有子元素个数的函数例子</div><div class="line">function countBodyChildren()&#123;</div><div class="line">    var body_element=document.getElementsByTagName(&quot;body&quot;)[0];</div><div class="line">    alert(body_element.childNodes.length);</div><div class="line">&#125;</div><div class="line">window.onload=countBodyChildren;</div></pre></td></tr></table></figure></li><li><p>nodeType属性</p><ul><li>元素节点的nodeType属性值是1。</li><li>属性节点的nodeType属性值是2。</li><li>文本节点的nodeType属性值是3。<br><code>alert(body_element.nodeType);</code></li></ul></li><li>nodeValue属性<br>得到和设置一个节点的值。<br><code>alert(discription.nodeValue);</code></li><li>firstChild和lastChild属性<br>这两个属性都是为了个简便且直观的获取对应的元素。</li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>DOM是一套对文档内容进行抽象和概念化的方法。</li><li>变量名中不能包含空格和标点符号（美元$符号除外）。</li><li>变量名允许包含字母，数字，美元符号和下划线（但第一个字符不能是数字）。</li><li>变量申明实例：my_mood或者myMood（峰驼式camel case：首选）。</li><li>Javascript是弱类型语言，不需要对变量进行类型声明。</li><li>变量可以包含操作。</li><li>字符串可以做拼接操作。</li><li>innerHTML属性和documen.write方法都是HTML的专有属性。<br><code>var message=&quot;I am feeling&quot;+&quot;happy&quot;;</code></li><li>每个元素节点都是一个对象。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;DOM&quot;&gt;&lt;a href=&quot;#DOM&quot; class=&quot;headerlink&quot; title=&quot;DOM&quot;&gt;&lt;/a&gt;DOM&lt;/h3&gt;
    
    </summary>
    
    
      <category term="DOM" scheme="http://yangkunyi.com/tags/DOM/"/>
    
      <category term="JS" scheme="http://yangkunyi.com/tags/JS/"/>
    
      <category term="前端" scheme="http://yangkunyi.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>BOM知识点</title>
    <link href="http://yangkunyi.com/2017/04/06/BOM%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yangkunyi.com/2017/04/06/BOM知识点/</id>
    <published>2017-04-06T00:56:57.000Z</published>
    <updated>2017-12-02T06:40:28.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><a id="more"></a><h3 id="一、window对象"><a href="#一、window对象" class="headerlink" title="一、window对象"></a>一、window对象</h3><h4 id="1-全局作用域"><a href="#1-全局作用域" class="headerlink" title="1.全局作用域"></a>1.全局作用域</h4><ul><li>全局变量会变成window对象的属性。</li><li>全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性可以。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var age=29;</div><div class="line">window.color=&quot;red&quot;;</div><div class="line">//在IE&lt;9时抛出错误，在其他所有浏览器中都返回false</div><div class="line">delete window.age;</div><div class="line">//在IE&lt;9时抛出错误，在其他所有浏览器中都返回true</div><div class="line">delete window.color;//returns true</div><div class="line"></div><div class="line">alert(window.age);//29</div><div class="line">alert(window.color);//undefined</div></pre></td></tr></table></figure><ul><li>尝试访问未声明变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明变量是否存在。</li></ul><h4 id="窗口关系及框架"><a href="#窗口关系及框架" class="headerlink" title="窗口关系及框架"></a>窗口关系及框架</h4><ul><li>除非最高层窗口是通过window.open()打开的，否则其window对象的name属性不会包含任何值。</li><li>在使用框架的情况下，浏览器中会存在多个Global对象。</li><li>在每个框架中定义的全局变量会自动变成框架中window对象的属性。</li><li>由于每个window对象都包含原生类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应但并不相等。</li></ul><h4 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h4><ul><li>screenLeft/screenTop:分别用于表示相对于屏幕左边和上边的位置。</li><li>screenY/screenX:提供相同的窗口位置属性。``</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var leftPos=(typeof window.screenLeft==&quot;number&quot;)?window.screenLeft:window.screenX;</div><div class="line">var topPos=(typeof window.screenLeft==&quot;number&quot;)?window.screenTop:window.screenY;</div></pre></td></tr></table></figure><p>注意：最终无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值。</p><ul><li>moveTo()两个参数:移动到什么位置去。</li><li>moveBy()两个参数:向什么地方移动。<br>两个函数不适用与框架，只能对最外层的window对象使用。</li></ul><h4 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h4><ul><li>innerWidth/innnerHeight:返回浏览器本身的尺寸。</li><li>outerWidth/outerHeight:返回浏览器本身的尺寸。</li><li>document.documentElement.clientWidth/document.documentElement.clientHeight</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var pageWidth=window.innerWidth;</div><div class="line">    pageHeight=window.innerHeight;</div><div class="line">if(typeof pageWidth!=&quot;number&quot;)&#123;</div><div class="line">    if(document.compatMode==&quot;CSS1Compat&quot;)&#123;</div><div class="line">    //通过检查document.compatMode来确定页面是否处于标准模式</div><div class="line">        pageWidth=document.documentElement.clientWidth;</div><div class="line">        pageHeight=document.documentElement.clientHeight;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        pageWidth=document.body.clientWidth;</div><div class="line">        pageHeight=document.body.clientHeight;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>resizeTo()两个参数:调整到。</li><li>resizeBy()两个参数:接受新窗口与原窗口的宽度和高度之差。<br>两个函数不适用与框架，只能对最外层的window对象使用。</li></ul><h4 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h4><ul><li>window.open():既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。接收四个参数：1.要加载的URL 2.窗口目标 3.一个特定的字符串 4.一个表示新页面是否取代浏览器历史纪录中当前加载页面的布尔值<br>方法会返回一个指向新窗口的引用。<ul><li>1.打开窗口</li><li>2.安全限制</li><li>3.弹出窗口屏蔽程序</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var blocked=false;</div><div class="line"></div><div class="line">try&#123;</div><div class="line">    var wroxWin=window.open(&quot;http://www.wrox.com&quot;, &quot;_blank&quot;);</div><div class="line">    if(wroxWin==null)&#123;</div><div class="line">        blocked=true;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">catch(ex)&#123;</div><div class="line">    blocked=true;</div><div class="line">&#125;</div><div class="line">if(blocked)&#123;</div><div class="line">    alert(&quot;The popup was blocked!&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在任何情况下，以上代码都可以检测出调用window.open()打开的弹出窗口是不是被屏蔽来了。但要注意的是，检测窗口是否被屏蔽只是一方面，它并不会阻止浏览器显示与被屏蔽的弹出窗口有关的消息。</p><h4 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h4><ul><li>JavaScript是单线程语言，但它允许通过设置超时值和间歇值来调度代码在特定的时刻执行。</li><li>setTimeout():<br><ul><li>接受两个参数：1.要执行的代码（不建议传字符串，因为可能导致性能损失，建议用函数） 2.以毫秒表示的时间</li><li>该方法会返回一个数值ID，表示超时调用。这个超时调用ID是计划执行代码的唯一标识符，可以通过它来取消超时调用。</li></ul></li><li>setInterval():<ul><li>与超时调用类似，但是它会按照指定的时间间隔重复执行代码，直到间歇调用被取消或者页面被卸载。</li><li>也接受两个参数：1.要执行的代码 2.以毫秒表示的时间</li></ul></li><li>clearTimeout():取消超时调用或者间歇时间调用。</li><li>在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。所以，最好不要使用间歇调用。</li><li>一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var num=0;</div><div class="line">var max=10;</div><div class="line">function incremenetNumber()&#123;</div><div class="line">    num++;</div><div class="line">    //如果执行次数尚未达到max设定的值，则设置另一次超时调用</div><div class="line">    if(num&lt;max)&#123;</div><div class="line">        setTimeout(incrementNumber,500);</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        alert(&quot;Done!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">setTimeout(incrementNumber,500);</div></pre></td></tr></table></figure><h4 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h4><ul><li>alert():向用户显示一个系统对话框，其中包含一个制定的文本和一个OK（确定）按钮。</li><li>confirm():向用户显示“警告”对话框，返回true或者flase。</li><li>prompt():显示一个“提示”框，用于提示用户输入一些文本。接受两个参数：1.要显示给用户的文本提示 2.文本输入域的默认值。</li><li>window.find():显示“查询”对话框。</li><li>window.print():显示“打印”对话框。</li></ul><h3 id="二、location对象"><a href="#二、location对象" class="headerlink" title="二、location对象"></a>二、location对象</h3><h4 id="查询字符串参数"><a href="#查询字符串参数" class="headerlink" title="查询字符串参数"></a>查询字符串参数</h4><ul><li>解析查询字符串的函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">function getQueryStringArgs () &#123;</div><div class="line">// 解析查询字符串</div><div class="line"></div><div class="line">//取得查询字符串并去掉开头的问号</div><div class="line">var qs=(location.search.length&gt;0?location.search.substring(1):&quot;&quot;),</div><div class="line"></div><div class="line">//保存数据对象</div><div class="line">args=&#123;&#125;,</div><div class="line"></div><div class="line">//取得每一项</div><div class="line">items=qs.length?qs.sqlit(&quot;&amp;&quot;):[],</div><div class="line">item=null,</div><div class="line">name=null,</div><div class="line">value=null,</div><div class="line"></div><div class="line">//在for循环中使用</div><div class="line">i=0,</div><div class="line">len=items.length;</div><div class="line"></div><div class="line">//逐个将每一项添加到args对象中</div><div class="line">for (var i = 0; i &lt; len ; i++) &#123;</div><div class="line">item=items[i].sqlit(&quot;=&quot;);</div><div class="line">name=decodeURIComponent(item[0]);</div><div class="line">value=decodeURIComponent(item[1]);</div><div class="line"></div><div class="line">if (name.length) &#123;</div><div class="line">args[name]=value;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return args;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h4><p>改变浏览器的位置</p><ul><li>assigned()：<code>location.assign(&quot;http://www.wrox.com&quot;);</code></li><li>location.href</li><li>window.location</li><li>replace()：让用户无法回到前一个页面，历史记录中不会生成新的记录。</li><li>raload()：作用是重新加载当前显示的页面。最好将其放在代码的最后一行。</li></ul><h3 id="三、navigation对象"><a href="#三、navigation对象" class="headerlink" title="三、navigation对象"></a>三、navigation对象</h3><h4 id="检查插件"><a href="#检查插件" class="headerlink" title="检查插件"></a>检查插件</h4><ul><li>检查插件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">//检查插件（在IE中无效）</div><div class="line">function hasPlugin (name) &#123;</div><div class="line">name=name.toLowerCase();</div><div class="line">for (var i = 0; i &lt; navigator.plugins.length; i++) &#123;</div><div class="line">if (navigator.plugins[i].name.toLowerCase().indexOf(name)&gt;-1) &#123;</div><div class="line">return true;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//检测flash</div><div class="line">//alert(hasPlugin(&quot;Flash&quot;));</div><div class="line"></div><div class="line">//检测QuickTime</div><div class="line">//alert(hasPlugin(&quot;QuickTime&quot;));</div><div class="line"></div><div class="line">//检测IE中的插件</div><div class="line">function hasIEPlugin (name) &#123;</div><div class="line">try&#123;</div><div class="line">new ActiveXObject(name);</div><div class="line">return true;</div><div class="line">&#125;</div><div class="line">catch(ex)&#123;</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//检测flash</div><div class="line">//alert(hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;));</div><div class="line"></div><div class="line">//检测QuickTime</div><div class="line">//alert(hasPlugin(&quot;QuickTime.QuickTime&quot;));</div></pre></td></tr></table></figure><h4 id="注册处理程序"><a href="#注册处理程序" class="headerlink" title="注册处理程序"></a>注册处理程序</h4><ul><li>registerContentHandler()：接收三个参数：1.要处理的MIME类型。2.可以处理该MIME类型的页面的URL。3.应用程序的名称。</li><li>registerProtocolHandler()：接收三个参数：1.要处理的协议。2.处理该协议的页面的URL。3.应用程序的名字。</li></ul><h3 id="四、screen对象"><a href="#四、screen对象" class="headerlink" title="四、screen对象"></a>四、screen对象</h3><h3 id="五、history对象"><a href="#五、history对象" class="headerlink" title="五、history对象"></a>五、history对象</h3><ul><li>go()</li><li>back()</li><li>forward()</li><li>lengh属性</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;BOM&quot;&gt;&lt;a href=&quot;#BOM&quot; class=&quot;headerlink&quot; title=&quot;BOM&quot;&gt;&lt;/a&gt;BOM&lt;/h2&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yangkunyi.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="BOM" scheme="http://yangkunyi.com/tags/BOM/"/>
    
      <category term="笔记" scheme="http://yangkunyi.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>动画和HTML5</title>
    <link href="http://yangkunyi.com/2017/03/23/%E5%8A%A8%E7%94%BB%E5%92%8CHTML5/"/>
    <id>http://yangkunyi.com/2017/03/23/动画和HTML5/</id>
    <published>2017-03-23T06:33:24.000Z</published>
    <updated>2017-12-02T06:46:53.539Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用JavaScript实现动画效果"><a href="#用JavaScript实现动画效果" class="headerlink" title="用JavaScript实现动画效果"></a>用JavaScript实现动画效果</h3><a id="more"></a><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ul><li>position属性：<ul><li>static：默认值，意思是有关元素将按照它们在标记里出现的先后顺序出现在浏览器窗口里。</li><li>relative：与static相似，区别是relative的元素还可以（通过应用float属性）从文档的正常显示顺序里脱离出来。</li><li>absolute：我们就可以将它摆在“容器”的任何位置。这个容器要么是文档本身，要么是一个有着fixed或absolute属性的父元素。这个元素在原始标记里面出现的位置与它显示位置无关，因为它的显示位置由top，left，right和bottom等属性决定。你可以使用像素或百分比为单位设置这些属性。</li></ul></li><li>overflow属性：<ul><li>visible：不裁剪溢出内容。</li><li>hidden：隐藏溢出内容。</li><li>scroll：类似鱼hidden，浏览器将对溢出的内容进行隐藏，但显示一个滚动条以便让用户能够滚动看到内容的其他部分。</li><li>auto：类似于scroll，但浏览器只在确实发生溢出时才显示滚动条，如果没有溢出就不显示滚动条。<h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4></li></ul></li><li>setTimeout：能够让某个函数在经过一段预定的时间之后才开始执行。<ul><li>函数有两个参数：第一个是字符串，执行的函数名；第二个是数值，以毫秒为单位设定了需要经过多长时间才开始执行第一个参数所给出的函数。</li><li><code>setTimeout(&quot;function&quot;,interval)</code></li><li>在绝大多数情况下，将函数调用赋值给一个变量是一个好主意。</li><li><code>varible=setTimeout(&quot;function&quot;,interval)</code></li><li>取消某个正在排队等候执行的函数：</li><li><code>clearTimeout(variable)</code></li></ul></li></ul><h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><h4 id="video："><a href="#video：" class="headerlink" title="video："></a>video：</h4><ul><li>currentTime：返回当前播放的位置，以秒表示；</li><li>duration：返回媒体的总时长，以秒表示，对于流媒体返回无穷大； * paused：表示媒体是否处于暂停状态；</li><li>触发脚本的事件：</li><li>play：在媒体播放开始时发生；</li><li>pause：在媒体暂停是发生；</li><li>loadeddata：在媒体可以从当前播放位置开始播放时发生；</li><li>ended：在媒体已播放完成而停止时发生；</li><li>别忘了给<code>&lt;video&gt;</code>元素叫control属性：</li><li><code>&lt;video src=&quot;movie.ogv&quot; control&gt;</code></li></ul><h4 id="表单："><a href="#表单：" class="headerlink" title="表单："></a>表单：</h4><p>新的输入控件类型</p><ul><li>email，用于输入电子邮件地址；</li><li>url，用于输入URL；</li><li>date，用于输入日期和时间；</li><li>number，数值；</li><li>ranger，生成滑动条；</li><li>search，搜索框；</li><li>tel，电话号码；</li><li><p>color，选择颜色；<br>新的属性</p></li><li><p>autocomplete，用于为文本（text）输入框添加一组建议的输入项；</p></li><li>autofocus，让表单元素自动获得焦点；</li><li>form，对<form>标签外部的表单元素分组；</form></li><li>min，max和step，用在范围（range）和数值（number）输入框中；</li><li>pattern，定义一个正则表达式，以便验证输入的值；</li><li>placeholder，在文本输入临时性的提示信息；</li><li>required，表示必填；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;用JavaScript实现动画效果&quot;&gt;&lt;a href=&quot;#用JavaScript实现动画效果&quot; class=&quot;headerlink&quot; title=&quot;用JavaScript实现动画效果&quot;&gt;&lt;/a&gt;用JavaScript实现动画效果&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yangkunyi.com/tags/Javascript/"/>
    
      <category term="动画" scheme="http://yangkunyi.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="HTML5" scheme="http://yangkunyi.com/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>JSON相关内容</title>
    <link href="http://yangkunyi.com/2017/03/22/JSON%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"/>
    <id>http://yangkunyi.com/2017/03/22/JSON相关内容/</id>
    <published>2017-03-22T15:02:31.000Z</published>
    <updated>2017-12-02T06:42:18.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><a id="more"></a><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li>JSON是一种数据结构，不是一种编程语言。</li></ul><h3 id="语法（三种类型的值）"><a href="#语法（三种类型的值）" class="headerlink" title="语法（三种类型的值）"></a>语法（三种类型的值）</h3><ul><li>简单值：使用JavaScript语法，可以在JSON中表示字符串、数值、布尔值和null，但不支持undefined。<ul><li>字符串必须用双引号。</li><li>没有变量，没有分号。</li></ul></li><li>对象：表示一组无序的键值对儿，每个键值对儿的值可以是简单值，也可以是复杂数据类型。<ul><li><strong>对象的属性必须加双引号</strong>。</li><li>没有声明，没有末尾的分号。</li><li>一个对象绝不能出项两个同名的属性。</li></ul></li><li>数组：一组有序的值的列表，可以通过数值索引类访问其中的值，数组的值也可以是任意值。<ul><li>没有变量，没有分号。</li></ul></li></ul><h3 id="解析与序列化"><a href="#解析与序列化" class="headerlink" title="解析与序列化"></a>解析与序列化</h3><p>JSON可以将JSON数据结构解析为有用的JavaScript对象。</p><ul><li><p>JSON对象</p><ul><li>stringify()：将JavaScript对象序列化为JSON字符串。</li><li>parse()：将JSON字符串解析为原生的JavaScript值。</li></ul></li><li><p>序列化选项</p><ul><li>stringify()除了要序列化的JavaScript对象外，还可以接收两个参数，用于指定以不同的方式序列化JavaScript对象。一个是参数过滤器（可以是数组，可以是函数），第二个参数是选项，表示是否在JSON字符串中保存缩进。</li><li>如果是数组，就返回对象相应的属性。</li><li>如果是函数，返回值是undefined将会被忽略。</li><li>字符串缩进：第三个参数用于控制结果中的缩进和空白字符串。如果是数字就表示的是每个级别缩进的空格数。</li><li>toJSON()方法：（没看懂）。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JSON&quot;&gt;&lt;a href=&quot;#JSON&quot; class=&quot;headerlink&quot; title=&quot;JSON&quot;&gt;&lt;/a&gt;JSON&lt;/h2&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yangkunyi.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JSON" scheme="http://yangkunyi.com/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>css选择器、权重及优先级</title>
    <link href="http://yangkunyi.com/2017/03/21/css%E9%80%89%E6%8B%A9%E5%99%A8%E3%80%81%E6%9D%83%E9%87%8D%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>http://yangkunyi.com/2017/03/21/css选择器、权重及优先级/</id>
    <published>2017-03-21T07:11:22.000Z</published>
    <updated>2017-12-02T06:40:52.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><a id="more"></a><ol><li>子元素使用padding会影响父元素。（解决方法是给父元素用padding）</li><li>背景图片的设置。（已解决）</li></ol><hr><h2 id="分享会（胡小青）"><a href="#分享会（胡小青）" class="headerlink" title="分享会（胡小青）"></a>分享会（胡小青）</h2><h1 id="CSS选择器、权重及优先级"><a href="#CSS选择器、权重及优先级" class="headerlink" title="CSS选择器、权重及优先级"></a>CSS选择器、权重及优先级</h1><h3 id="选择器的种类"><a href="#选择器的种类" class="headerlink" title="选择器的种类"></a>选择器的种类</h3><ul><li>通配符选择器（＊）</li><li>id选择器（#ID）</li><li>类选择器（.className）</li><li>标签选择器(E)</li><li>后代选择器（Ｅ Ｆ）</li><li>子元素选择器(E&gt;F)</li><li>相邻兄弟元素选择器(E + F)</li><li>群组选择器（selector1,selector2,…,selectorN）</li><li>交集选择器（E.className)</li><li>属性选择器</li><li>伪类选择器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">//html</div><div class="line">&lt;div id=&quot;share&quot;&gt;id选择器&lt;/div&gt;</div><div class="line">&lt;div class=&quot;share&quot;&gt;类选择器&lt;/div&gt;</div><div class="line">&lt;div&gt;</div><div class="line">&lt;em&gt;标签选择器&lt;/em&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;div&gt;</div><div class="line">&lt;p&gt;后代选择器&lt;/p&gt;</div><div class="line">&lt;p&gt;&lt;span&gt;非直系后代&lt;/span&gt;&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;div&gt;</div><div class="line">&lt;p&gt;子元素选择器&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;div&gt;</div><div class="line">&lt;p&gt;相邻兄弟1&lt;/p&gt;</div><div class="line">&lt;span&gt;相邻兄弟2&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;div&gt;</div><div class="line">&lt;h1&gt;群组选择器&lt;/h1&gt;</div><div class="line">&lt;h2&gt;群组选择器&lt;/h2&gt;</div><div class="line">&lt;h3&gt;群组选择器&lt;/h3&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">//css</div><div class="line">*&#123;</div><div class="line">margin: 0;</div><div class="line">padding: 0;</div><div class="line">&#125;</div><div class="line">#share&#123;</div><div class="line">width: 200px;</div><div class="line">background: #cfd2d1;</div><div class="line">&#125;</div><div class="line">.share&#123;</div><div class="line">width: 200px;</div><div class="line">background: #e9eeec;</div><div class="line">margin-bottom: 10px;</div><div class="line">&#125;</div><div class="line">div.share &#123;</div><div class="line">border: 2px solid #000;</div><div class="line">&#125;</div><div class="line">em&#123;</div><div class="line">background: #f5f6f6;</div><div class="line"></div><div class="line">&#125;</div><div class="line">div p &#123;</div><div class="line">background: #e9eeec;</div><div class="line">&#125;</div><div class="line">div p span&#123;</div><div class="line">width: 200px;</div><div class="line">background: #acb1af;</div><div class="line">&#125;</div><div class="line"></div><div class="line">div &gt; p &#123;</div><div class="line">width: 200px;</div><div class="line">background: #adcec0;</div><div class="line">&#125;</div><div class="line">p + span &#123;</div><div class="line">width: 200px;</div><div class="line">background: #9d9e9e;</div><div class="line">&#125;</div><div class="line">h1,h2,h3 &#123;</div><div class="line">width: 200px;</div><div class="line">background: #afead2;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><table><thead><tr><th style="text-align:center">属性选择器</th><th style="text-align:center">功能</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">E[att]</td><td style="text-align:center">匹配所有具有att属性的E元素，不考虑它的值。</td><td style="text-align:center">css2</td></tr><tr><td style="text-align:center">E[att=val]</td><td style="text-align:center">匹配所有att属性等于”val”的E元素</td><td style="text-align:center">css2</td></tr><tr><td style="text-align:center">E[att~=val]</td><td style="text-align:center">匹配属性包含val的元素，并设置其样式：注意是val，所以val-ab这样不算</td><td style="text-align:center">css2</td></tr><tr><td style="text-align:center">E[att\</td><td style="text-align:center">=val]</td><td style="text-align:center">匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以”val”开头的E元素，主要用于lang属性</td><td>css2</td></tr><tr><td style="text-align:center">E[att^=val]</td><td style="text-align:center">选择匹配的元素E，E定义了属性att,属性值以val开头的字符串</td><td style="text-align:center">css3</td></tr><tr><td style="text-align:center">E[arr$=val]</td><td style="text-align:center">选择匹配的元素E，E定义了属性att,属性值以val结尾的字符串</td><td style="text-align:center">css3</td></tr><tr><td style="text-align:center">E[att*=val]</td><td style="text-align:center">选择匹配的元素E，E定义了属性att,属性值包含val的字符串，也就是val可以在任意位置</td><td style="text-align:center">css3</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">//html</div><div class="line">&lt;a href=&quot;xxx.pdf&quot;&gt;我链接的是PDF文件&lt;/a&gt;</div><div class="line">&lt;a href=&quot;#&quot; class=&quot;icon&quot;&gt;我类名是icon&lt;/a&gt;</div><div class="line">&lt;a href=&quot;#&quot; title=&quot;我的title是more&quot;&gt;我的title是more&lt;/a&gt;</div><div class="line">&lt;a href=&quot;#&quot; name=&quot;about&quot; lang=&quot;en-zhN&quot;&gt;选择含有about的元素&lt;/a&gt;</div><div class="line">&lt;a href=&quot;#&quot; name=&quot;about-ab&quot; lang=&quot;en&quot;&gt;选择含有about的元素&lt;/a&gt;</div><div class="line">&lt;a href=&quot;#&quot; name=&quot;about ab&quot;&gt;选择含有about的元素&lt;/a&gt;</div><div class="line"></div><div class="line">//css</div><div class="line">a[href=&quot;xxx.pdf&quot;] &#123;</div><div class="line">border: 1px solid #000;</div><div class="line">&#125;</div><div class="line">a[href$=pdf]&#123;</div><div class="line">  background: orange;</div><div class="line">  color: #fff;</div><div class="line">&#125;</div><div class="line">a[class^=icon] &#123;</div><div class="line">  background: #55e2a8;</div><div class="line">  color:#fff;</div><div class="line">&#125;</div><div class="line">a[title*=more] &#123;</div><div class="line">  background: #7a92e9;</div><div class="line">  color: #fff;</div><div class="line">&#125;</div><div class="line">a[name~=about] &#123;</div><div class="line">background: #55e2a8;</div><div class="line">&#125;</div><div class="line">a[lang|=en] &#123;</div><div class="line">border: 1px solid #000;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器 *"></a>伪类选择器 <em>*</em></h3><h4 id="动态伪类"><a href="#动态伪类" class="headerlink" title="动态伪类"></a>动态伪类</h4><ul><li><p>锚点伪类</p><ul><li><code>:link</code>  链接访问前状态</li><li><code>:visited</code>  链接访问后状态</li><li><code>:hover</code>  鼠标悬浮链接的状态</li><li><code>:active</code>  激活链接时的状态<blockquote><p>伪类的顺序：link - visited -&gt; hover -&gt; active</p></blockquote></li></ul></li><li><p>用户行为伪类</p><ul><li><code>:hover</code> 用于当用户把鼠标移动到元素上面时的效果</li><li><code>:active</code> 用于用户点击元素那一下的效果</li><li><code>:focus</code>用于元素成为焦点，这个经常用在表单元素上<blockquote><p>顺序： focus - &gt; hover -&gt; active<br>IE6下只有<code>&lt;a&gt;</code>支持<code>:hover</code>，IE6,7都不支持<code>:focus</code>、<code>:active</code></p></blockquote></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//html</div><div class="line">&lt;a href=&quot;#&quot; class=&quot;link&quot;&gt;link效果&lt;/a&gt;</div><div class="line">&lt;a href=&quot;#&quot; class=&quot;visited&quot;&gt;visited效果&lt;/a&gt;</div><div class="line">&lt;a href=&quot;#&quot; class=&quot;hover&quot;&gt;hover效果&lt;/a&gt;</div><div class="line">&lt;a href=&quot;#&quot; class=&quot;active&quot;&gt;active效果&lt;/a&gt;</div><div class="line">&lt;input type=&quot;text&quot; name=&quot;&quot;&gt;</div><div class="line"></div><div class="line">//css</div><div class="line">.link:link &#123;</div><div class="line">background: pink;</div><div class="line">&#125;</div><div class="line">.visited:visited&#123;</div><div class="line">background: #cca;</div><div class="line">&#125;</div><div class="line">.hover:hover &#123;</div><div class="line">background: lightblue;</div><div class="line">&#125;</div><div class="line">.active:active &#123;</div><div class="line">background: lightgreen;</div><div class="line">&#125;</div><div class="line">input:focus &#123;</div><div class="line">outline: 2px solid red;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="UI元素状态伪类"><a href="#UI元素状态伪类" class="headerlink" title="UI元素状态伪类"></a>UI元素状态伪类</h4><p>这类伪类主要针对form元素</p><table><thead><tr><th style="text-align:center">伪类</th><th style="text-align:center">功能</th><th>适用元素</th></tr></thead><tbody><tr><td style="text-align:center"><code>:enabled</code></td><td style="text-align:center">匹配表单中激活的元素</td><td>type=”text”</td></tr><tr><td style="text-align:center"><code>:disabled</code></td><td style="text-align:center">匹配表单中禁用的元素</td><td>type=”text”</td></tr><tr><td style="text-align:center"><code>:checked</code></td><td style="text-align:center">匹配表单中被选中的radio（单选框）或checkbox（复选框）元素</td><td>type=”radio”</td></tr><tr><td style="text-align:center"><code>::selection</code></td><td style="text-align:center">匹配用户当前选中的元素</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">input[type=&quot;radio&quot;]:disabled &#123;</div><div class="line">background-color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="结构伪类"><a href="#结构伪类" class="headerlink" title="结构伪类"></a>结构伪类</h4><ul><li><code>:first-child</code>*  选择某个元素的第一个子元素,IE6不支持；</li><li><code>:last-child</code>* 选择某个元素的最后一个子元素；</li><li><code>:nth-child()</code>* 选择某个元素的一个或多个特定的子元素，IE6-8，Firefox3.0不兼容；<blockquote><p>:nth-child(length)&ensp;&ensp;参数是具体数字<br> :nth-child(n)&ensp;&ensp;参数是n,n从0开始计算<br> :nth-child(n<em>length)&ensp;&ensp;n的倍数选择，n从0开始算<br> :nth-child(n+length)&ensp;&ensp;选择大于length后面的元素<br>  :nth-child(-n+length)&ensp;&ensp;选择小于length前面的元素<br>  :nth-child(n</em>length+1)&ensp;&ensp;表示隔几选一</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">li:last-child &#123;</div><div class="line">background: #f9f57a;</div><div class="line">&#125;</div><div class="line">li:nth-child(2) &#123;</div><div class="line">background: #c8cac9;</div><div class="line">&#125;</div><div class="line">li:nth-child(2n) &#123;</div><div class="line">border: 3px solid red;</div><div class="line">&#125;</div><div class="line">li:nth-child(n+3) &#123;</div><div class="line">border: 3px solid yellow;</div><div class="line">&#125;</div><div class="line">li:nth-child(-n+3) &#123;</div><div class="line">border: 3px solid yellow;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>:nth-last-child()</code>选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算，IE6-8，Firefox3.0不兼容；</li><li><code>:nth-of-type()</code>选择指定的元素,与nth-child类似也可以使用表达式，IE6-8，Firefox3.0不兼容；</li><li><code>:nth-last-of-type()</code>选择指定的元素，从元素的最后一个开始计算；</li><li><code>:first-of-type</code>选择一个上级元素下的第一个同类子元素，与first-child类似，不过是指定了元素类型；</li><li><code>:last-of-type</code>选择一个上级元素的最后一个同类子元素；</li><li><code>:only-child</code>选择的元素是它的父元素的唯一一个子元素，兼容到IE9；</li><li><code>:only-of-type</code>选择一个元素是它的上级元素的唯一一个相同类型的子元素，IE6-8，Firefox3.0不兼容；</li><li><code>:empty</code>选择的元素里面没有任何内容，兼容到IE9；</li><li><code>:not()</code>选择不匹配的元素，兼容到IE9；</li><li><code>target</code> 匹配文档中特定”id”点击后的效果，兼容到IE9。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//html</div><div class="line">&lt;a href=&quot;#test&quot;&gt;test&lt;/a&gt;</div><div class="line">&lt;div&gt;第一个div&lt;/div&gt;</div><div class="line">&lt;p&gt;第一个p&lt;/p&gt;</div><div class="line">&lt;div id=&quot;test&quot;&gt;第二个div&lt;/div&gt;</div><div class="line">&lt;p&gt;第二个p&lt;/p&gt;</div><div class="line">&lt;p&gt;&lt;/p&gt;</div><div class="line"></div><div class="line">//css</div><div class="line">div:not&#123;</div><div class="line">background-color: lightgrey;</div><div class="line">&#125;</div><div class="line">p:empty&#123;</div><div class="line">height:30px;</div><div class="line">width:30px;</div><div class="line">background:pink;</div><div class="line">&#125;</div><div class="line">div:target&#123;</div><div class="line">color:blue;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h4><table><thead><tr><th style="text-align:center">伪元素</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>:first-line</code></td><td style="text-align:center">匹配元素的第一行</td></tr><tr><td style="text-align:center"><code>:first-letter</code></td><td style="text-align:center">匹配元素的第一个字母</td></tr><tr><td style="text-align:center"><code>:before</code></td><td style="text-align:center">元素之前插入生成的内容</td></tr><tr><td style="text-align:center"><code>:after</code></td><td style="text-align:center">元素之后插入生成的内容</td></tr><tr><td style="text-align:center"><code>:selecton</code></td><td style="text-align:center">改变浏览网页选中文的默认效果</td></tr></tbody></table><p>伪元素可以用<code>::</code>也可以用<code>:</code><br>关于first-letter使用条件比较苛刻，一般只有<br>有兴趣可以参考<a href="http://www.zhangxinxu.com/wordpress/2016/09/css-first-letter-pseudo-element/" target="_blank" rel="external">深入CSS ::first-letter伪元素及其实例</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">li::first-letter &#123;</div><div class="line">font-size: 56px;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别"></a>伪类和伪元素的区别</h3><p>&gt;</p><ul><li>CSS 伪类用于向某些选择器添加特殊的效果。</li><li>CSS 伪元素用于将特殊的效果添加到某些选择器。<br>两者都与选择器相关，可以添加一些“特殊”的效果。</li></ul><blockquote><p>区别：<br>&ensp;&ensp;&ensp;&ensp;伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到</p></blockquote><p><strong>伪类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//html</div><div class="line">&lt;p&gt;</div><div class="line">    &lt;i&gt;first&lt;/i&gt;</div><div class="line">    &lt;i&gt;second&lt;/i&gt;+</div><div class="line">&lt;/p&gt;</div><div class="line"></div><div class="line">//css</div><div class="line">p&gt;i:first-child &#123;</div><div class="line">    color: red</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://sfault-image.b0.upaiyun.com/28/5a/285a5d7bc8c979311d637f576914ccea_articlex" alt="伪类"></p><p><strong>伪类</strong> <code>:first-child</code> 添加样式到第一个子元素<br>如果我们不使用伪类，而希望达到上述效果，可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//html</div><div class="line">&lt;p&gt;</div><div class="line">    &lt;i class=&quot;first-child&quot;&gt;first&lt;/i&gt;</div><div class="line">    &lt;i&gt;second&lt;/i&gt;</div><div class="line">&lt;/p&gt;</div><div class="line"></div><div class="line">//css</div><div class="line">.first-child &#123;</div><div class="line">    color: red</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>我们给第一个子元素添加一个类，然后定义这个类的样式。</p></blockquote><p><strong>伪元素：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//html</div><div class="line">&lt;p&gt;I am stephen lee.&lt;/p&gt;</div><div class="line"></div><div class="line">//css</div><div class="line">p:first-letter &#123;</div><div class="line">    color: red</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://sfault-image.b0.upaiyun.com/47/d5/47d55dc18a1c34ba5ca9dc53faccb623_articlex" alt="伪元素"></p><p>伪元素 <code>:first-letter</code> 添加样式到第一个字母<br>那么如果我们不使用伪元素，要达到上述效果，我们可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//html</div><div class="line">&lt;p&gt;</div><div class="line">    &lt;span&gt;I&lt;/span&gt; am stephen lee.</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;遇到的问题&quot;&gt;&lt;a href=&quot;#遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;遇到的问题&quot;&gt;&lt;/a&gt;遇到的问题&lt;/h2&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yangkunyi.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://yangkunyi.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="分享" scheme="http://yangkunyi.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
</feed>
