<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨坤怡</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yangkunyi.com/"/>
  <updated>2018-08-23T02:23:55.565Z</updated>
  <id>http://yangkunyi.com/</id>
  
  <author>
    <name>杨坤怡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序（数据结构）</title>
    <link href="http://yangkunyi.com/2018/08/23/%E6%8E%92%E5%BA%8F%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/"/>
    <id>http://yangkunyi.com/2018/08/23/排序（数据结构）/</id>
    <published>2018-08-23T02:22:23.000Z</published>
    <updated>2018-08-23T02:23:55.565Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>同样是复习总结。</p></blockquote><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>概念：就是重新排列列表中的元素，使表中的元素满足按关键字递增或递减的过程。</li><li><p>算法的稳定性：简单来说就是原本列表中的两个相同元素经过排序算法后，如果没有发生位置变化，则称该算法是<strong>稳定</strong>的；反之则<strong>不稳定</strong>。</p><ul><li>注：</li><li>1.算法是否具有稳定性并不能衡量一个算法的优劣，它主要是对算法的性质进行描述。</li><li>2.对于不稳定的排序算法，只需举出一组关键字的实例，说明它的不稳定性即可。</li></ul></li><li><p>排序根据数据元素是否完全在内存中，可分为<strong>内部排序</strong>和<strong>外部排序</strong>。</p><ul><li>内部排序：在排序期间元素全部存放在内存中的排序。</li><li>外部排序：在排序期间元素无法全部同时存放在内存中，必须在排序过程中根据要求不断地在内、外存之间移动的排序。</li></ul></li></ul><blockquote><p>在今天只是对内部排序进行复习。</p></blockquote><ul><li>内部排序的操作：比较和移动。（并不是所有的内部排序算法都要基于比较，例如：基数排序）</li><li>内部排序算法的性能却决于算法的<strong>时间复杂度</strong>和<strong>空间复杂度</strong>，而时间复杂度一般是由移动的次数来决定的。</li></ul><h2 id="直接插入排序（插入排序）"><a href="#直接插入排序（插入排序）" class="headerlink" title="直接插入排序（插入排序）"></a>直接插入排序（插入排序）</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//直接插入排序</div><div class="line">void InsertSort(ElemType A[],int n)&#123;</div><div class="line">    int i,j;</div><div class="line">    for(i=2;i&lt;=n;i++)&#123;                           //依次将A[2]~A[n]插入到前面已排序序列</div><div class="line">        if(A[i].key&lt;A[i-1].key)&#123;                 //若A[i]的关键码小于其前驱，需将A[i]插入有序表</div><div class="line">            A[0]=A[i];                           //复制为哨兵，A[0]不存放元素</div><div class="line">            for(j=i-1;A[0].key&lt;A[j].key;--j)&#123;    //从后往前查找待插入位置</div><div class="line">                A[j+1]=A[j];                     //向后挪位</div><div class="line">            &#125;</div><div class="line">            A[j+1]=A[0];                         //复制到插入位置</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ul><li>空间效率：<code>O(1)</code></li><li>时间效率：<code>O(n²)</code></li><li>稳定性：<strong>稳定</strong></li><li>适用性：<strong>顺序储存和链式储存</strong></li></ul><h2 id="折半插入排序（插入排序）"><a href="#折半插入排序（插入排序）" class="headerlink" title="折半插入排序（插入排序）"></a>折半插入排序（插入排序）</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//折半插入排序</div><div class="line">void InsertSort(ElemType A[],int n)&#123;</div><div class="line">    int i,j,low,high,mid;</div><div class="line">    for(i=2;i&lt;=n;i++)&#123;                          //依次将A[2]~A[n]插入到前面已排序序列</div><div class="line">        A[0] = A[i];                            //将A[i]暂存到A[0]</div><div class="line">        low = 1;</div><div class="line">        high = i - 1;                           //设置折半查找的范围</div><div class="line">        while(low&lt;=high)&#123;                       //折半查找（默认递增序列）</div><div class="line">            mid = (low + high) / 2;             //取中间点</div><div class="line">            if(A[mid].key&gt;A[0].key)&#123;            //查找左半子表         </div><div class="line">                high = mid - 1;</div><div class="line">            &#125;</div><div class="line">            else low = mid + 1;                 //查找右半子表</div><div class="line">        &#125;</div><div class="line">        for(j=i-1;j&gt;=high+1;--i)&#123;</div><div class="line">            A[j+1]=A[j];                        //统一后移元素，空出插入位置</div><div class="line">        &#125;</div><div class="line">        A[high+1] = A[0];                       //插入操作</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><ul><li>空间效率：<code>O(1)</code></li><li>时间效率：<code>O(n²)</code></li><li>稳定性：<strong>稳定</strong></li><li>适用性：<strong>顺序储存</strong></li></ul><h2 id="希尔排序（插入排序）"><a href="#希尔排序（插入排序）" class="headerlink" title="希尔排序（插入排序）"></a>希尔排序（插入排序）</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//希尔排序</div><div class="line">void ShellSort(ElemType A[],int n)&#123;</div><div class="line">    //对顺序表作写入插入排序，本算法和直接插入排序相比，做了以下修改：</div><div class="line">    //1.券后记录位置的增量是dk，不是1</div><div class="line">    //2.r[0]只是暂存单元，不是哨兵，当j&lt;=0时，插入位置已到</div><div class="line">    for(dk=n/2;dk&gt;=1;dk=dk/2)&#123;                  //步长变化</div><div class="line">        for(i=dk+1;i&lt;=n;kd=dk/2)&#123;</div><div class="line">            if(A[i].key&lt;A[i-dk].key)&#123;           //需将A[i]插入有序增量子表</div><div class="line">                A[0] = A[i];                    //暂存在A[0]</div><div class="line">                for(j=i-dk;j&gt;0&amp;&amp;A[0].key&lt;A[j].key;j-=dk)&#123;</div><div class="line">                    A[j+dk] = A[j];</div><div class="line">                &#125;</div><div class="line">                A[j+dk] = A[j];</div><div class="line">            &#125;//if</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h3><ul><li>空间效率：<code>O(1)</code></li><li>时间效率：<code>O(n²)</code></li><li>稳定性：<strong>不稳定</strong></li><li>适用性：<strong>顺序储存</strong></li></ul><h2 id="冒泡排序（交换排序）"><a href="#冒泡排序（交换排序）" class="headerlink" title="冒泡排序（交换排序）"></a>冒泡排序（交换排序）</h2><h3 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//冒泡排序</div><div class="line">void BubbleSort(ElemType A[],int n)&#123;</div><div class="line">    for(i=0;i&lt;n-1;i++)&#123;</div><div class="line">        flag = false;</div><div class="line">        for(j=n-1;j&gt;i;j--)&#123;</div><div class="line">            if(A[j-1].key&gt;A[j].key)&#123;</div><div class="line">                swap(A[j-1],A[j]);</div><div class="line">                flag = true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if(flag==false)&#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="性能分析-3"><a href="#性能分析-3" class="headerlink" title="性能分析"></a>性能分析</h3><ul><li>空间效率：<code>O(1)</code></li><li>时间效率：<code>O(n²)</code></li><li>稳定性：<strong>稳定</strong></li><li>适用性：<strong>顺序储存</strong></li><li>特点：每一趟排序都会将一个元素放置到其最终的位置上。</li></ul><h2 id="快速排序（交换排序）"><a href="#快速排序（交换排序）" class="headerlink" title="快速排序（交换排序）"></a>快速排序（交换排序）</h2><h3 id="算法-4"><a href="#算法-4" class="headerlink" title="算法"></a>算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//快速排序</div><div class="line">void QuickSort(Element A[],int low;int high)&#123;</div><div class="line">    if(low&lt;high)&#123;</div><div class="line">        int pivotpos = Partition(A,low,high);    //划分</div><div class="line">        QuickSort(A,low,pivotpos-1);             //依次对两个子表进行递归排序</div><div class="line">        QuickSort(A,pivotpos-1,high);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//快速排序中的一分二为操作</div><div class="line">int Partition(ElemType A[],int low,int high)&#123;</div><div class="line">    //一趟排序过程</div><div class="line">    ElemType  pivot = A[low];                    //将当前表中第一个元素设为枢轴值，对表进行划分</div><div class="line">    while(low&lt;high)&#123;                             //跳出循环</div><div class="line">        while(low&lt;high&amp;&amp;A[high]&gt;=pivot)&#123;</div><div class="line">            --high;</div><div class="line">        &#125;</div><div class="line">        A[low] = A[high];                        //将比枢轴值小的元素移动到左边</div><div class="line">        while(low&lt;high&amp;&amp;A[low]&lt;=pivot)&#123;</div><div class="line">            ++low;</div><div class="line">        &#125;</div><div class="line">        A[high] = A[low];                        //将比枢轴值大的元素移动到右边</div><div class="line">    &#125;</div><div class="line">    A[low] = pivot;                              //枢轴值元素存放到最终位置</div><div class="line">    return low;                                  //返回存放数轴的最终位置</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="性能分析-4"><a href="#性能分析-4" class="headerlink" title="性能分析"></a>性能分析</h3><ul><li>空间效率：最坏情况<code>O(n)</code>；平均情况<code>O(log2n)</code></li><li>时间效率：<code>O(n²)</code></li><li>稳定性：<strong>不稳定</strong></li><li>适用性：<strong>顺序储存</strong></li><li>特点：每一趟排序都会将一个元素放置到其最终的位置上。</li></ul><h2 id="简单选择排序（选择排序）"><a href="#简单选择排序（选择排序）" class="headerlink" title="简单选择排序（选择排序）"></a>简单选择排序（选择排序）</h2><h3 id="算法-5"><a href="#算法-5" class="headerlink" title="算法"></a>算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//简单选择排序</div><div class="line">void SelectSort(ElemType A[],int n)&#123;</div><div class="line">    //对表A作简单选择排序，A[]从0开始存放元素</div><div class="line">    For(i=0,i&lt;n-1;i++)&#123;                         //一共进行n-1趟</div><div class="line">        min = i;                                //记录最小元素位置</div><div class="line">        for(j=i+1;j&lt;n;j++)                      //在A[1···n-1]中选择最小的元素</div><div class="line">            if(A[j]&lt;A[min])</div><div class="line">                min = j;</div><div class="line">        if(min!=i)</div><div class="line">            swap(A[i],A[min]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="性能分析-5"><a href="#性能分析-5" class="headerlink" title="性能分析"></a>性能分析</h3><ul><li>空间效率：<code>O(1)</code></li><li>时间效率：<code>O(n²)</code></li><li>稳定性：<strong>不稳定</strong></li><li>适用性：<strong>顺序储存</strong></li></ul><h2 id="堆排序（选择排序）"><a href="#堆排序（选择排序）" class="headerlink" title="堆排序（选择排序）"></a>堆排序（选择排序）</h2><ul><li>这是一种树形选择排序方法，特点：子啊排序过程中，将L[1…n]看成是一棵完全二叉树的顺序储存结构，利用完全二叉树中双亲结点和孩子节点之间的内在关系，在当前无序区中选择关键字最大（或最小）的元素。</li><li>小根堆（小定堆）</li><li>大根堆（大定堆）</li></ul><h3 id="建立大根堆的算法"><a href="#建立大根堆的算法" class="headerlink" title="建立大根堆的算法"></a>建立大根堆的算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//建立大根堆</div><div class="line">void BuildMaxHeap(ElemType A[],int len)&#123;</div><div class="line">    for(int i=len/2;i&gt;0;i--)&#123;                     //从i=[n/2]~1,反复调整堆</div><div class="line">        AdjustDown(A,i,len);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="向下调整算法"><a href="#向下调整算法" class="headerlink" title="向下调整算法"></a>向下调整算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//向下调整算法</div><div class="line">void AdjustDown(ElemType A[],int k,int len)&#123;</div><div class="line">    A[0] = A[k];                                  //A[0]暂存</div><div class="line">    for(i=2*k;i&lt;=len;i*=2)&#123;                       //沿key较大的子结点向下筛选</div><div class="line">        if(i&lt;len&amp;&amp;A[i]&lt;A[i+1])</div><div class="line">            i++;                                  //取key值较大的子结点的下标</div><div class="line">        if(A[0]&gt;=A[i])</div><div class="line">            break;                                //筛选结束</div><div class="line">        else&#123;</div><div class="line">            A[k] = A[i];                          //将A[i]调整到双亲结点上</div><div class="line">            k = i;                                //修改k值，以便继续向下筛选</div><div class="line">        &#125;</div><div class="line">    &#125;//for</div><div class="line">    A[k] = A[0];                                  //被筛选结点的值放入最终位置</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="向上调整算法"><a href="#向上调整算法" class="headerlink" title="向上调整算法"></a>向上调整算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//向上调整算法</div><div class="line">void AdjustUp(ElemType A[],int k)&#123;</div><div class="line">    A[0] = A[k];</div><div class="line">    int i = k/2;                                  //若结点值大于双亲结点，则将双亲结点向下调，并继续向上比较</div><div class="line">    while(i&gt;0&amp;&amp;A[i]&lt;A[0])&#123;                        //循环跳出条件</div><div class="line">        A[k] = A[i];                              //双亲结点下调</div><div class="line">        k = i;</div><div class="line">        i = k/2;                                  //继续向上比较</div><div class="line">    &#125;//while</div><div class="line">    A[k] = A[0];                                  //复制到最终位置</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="堆排序的算法"><a href="#堆排序的算法" class="headerlink" title="堆排序的算法"></a>堆排序的算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 堆排序算法</div><div class="line">void HeapSort(ElemType A[],int len)&#123;</div><div class="line">    BuildMaxHeap(A,len);                          //初始创建</div><div class="line">    for(i=len;i&gt;1;i--)&#123;                           //n-1趟的交换和建堆过程</div><div class="line">        swap(A[i],A[1]);                          //输出堆顶元素（和堆低元素交换）</div><div class="line">        AdjustDown(A,1,i-1);                      //整理，把剩余的i-1个元素整理成堆</div><div class="line">    &#125;//for</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="性能分析-6"><a href="#性能分析-6" class="headerlink" title="性能分析"></a>性能分析</h3><ul><li>空间效率：<code>O(1)</code></li><li>时间效率：<code>O(nlog2n)</code></li><li>稳定性：<strong>不稳定</strong></li><li>适用性：<strong>顺序储存</strong></li></ul><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="Merge算法"><a href="#Merge算法" class="headerlink" title="Merge算法"></a>Merge算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//Merge函数</div><div class="line">ElemType *B = (ElemType *)malloc((n + 1) * sizeof(ElemType));      //辅助数组B</div><div class="line">void Merge(ElemType A[],int low,int mid,int high)&#123;</div><div class="line">    //表A的两段各自有序，将它们合成一个有序表</div><div class="line">    for(int k=low;k&lt;=high;k++)&#123;</div><div class="line">        B[k] = A[k];                              //将A中所有元素复制到B中</div><div class="line">    &#125;</div><div class="line">    for(i=low,j=mid+1,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)&#123;</div><div class="line">        if(B[i]&lt;=b[j])                            //比较B的左右两段中的元素</div><div class="line">            A[k] = B[i++];                        //将较小值复制到A中</div><div class="line">        else</div><div class="line">            A[k] = B[j++];</div><div class="line">    &#125;//for</div><div class="line">    while(j&lt;=mid)</div><div class="line">        A[k++] = B[i++];                          //若第一个表未检测完，复制</div><div class="line">    while(j&lt;=high)</div><div class="line">        A[k++] = B[j++];                          //若第二个表未检测完，复制</div><div class="line">&#125;//注：这里最后的两个while循环只有一个会执行</div></pre></td></tr></table></figure><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//排序算法（2路）</div><div class="line">void MergeSort(ElemType A[],int low,int high)&#123;</div><div class="line">    if(low&lt;high)&#123;</div><div class="line">        int mid = (low + high)/2;                 //从中间划分两个子序列 </div><div class="line">        MergeSort(A,low,high);                    //对左侧子序列进行递归排序</div><div class="line">        MergeSort(A,mid+1,high);                  //对右侧子序列进行递归排序</div><div class="line">        Merge(A,low,mig,high);                    //归并</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="性能分析-7"><a href="#性能分析-7" class="headerlink" title="性能分析"></a>性能分析</h3><ul><li>空间效率：<code>O(n)</code></li><li>时间效率：<code>O(nlog2n)</code></li><li>稳定性：<strong>稳定</strong></li><li>适用性：<strong>顺序储存</strong></li></ul><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="性能分析-8"><a href="#性能分析-8" class="headerlink" title="性能分析"></a>性能分析</h3><ul><li>空间效率：<code>O(r)</code>（r是队列的个数）</li><li>时间效率：<code>O(d(n+r))</code>（特点：跟序列的初始状态无关）</li><li>稳定性：<strong>稳定</strong></li><li>适用性：<strong>顺序储存</strong></li></ul><h2 id="各种排序的比较及应用"><a href="#各种排序的比较及应用" class="headerlink" title="各种排序的比较及应用"></a>各种排序的比较及应用</h2><h3 id="各种排序算法的性质"><a href="#各种排序算法的性质" class="headerlink" title="各种排序算法的性质"></a>各种排序算法的性质</h3><table><br>        <tr><br>            <td rowspan="2">算法种类</td><br>            <td colspan="3">时间复杂度</td><br>            <td rowspan="2">空间复杂度</td><br>            <td rowspan="2">是否稳定</td><br>        </tr><br>        <tr><br>            <td>最好情况</td><br>            <td>平均情况</td><br>            <td>最坏情况</td><br>        </tr><br>        <tr><br>            <td>直接插入排序</td><br>            <td>O(n)</td><br>            <td>O(n²)</td><br>            <td>O(n²)</td><br>            <td>O(1)</td><br>            <td>是</td><br>        </tr><br>        <tr><br>            <td>冒泡排序</td><br>            <td>O(n)</td><br>            <td>O(n²)</td><br>            <td>O(n²)</td><br>            <td>O(1)</td><br>            <td>是</td><br>        </tr><br>        <tr><br>            <td>简单选择排序</td><br>            <td>O(n²)</td><br>            <td>O(n²)</td><br>            <td>O(n²)</td><br>            <td>O(1)</td><br>            <td>否</td><br>        </tr><br>        <tr><br>            <td>希尔排序</td><br>            <td>O(n²)</td><br>            <td>O(n²)</td><br>            <td>O(n²)</td><br>            <td>O(1)</td><br>            <td>否</td><br>        </tr><br>        <tr><br>            <td>快速排序</td><br>            <td>O(nlog2n)</td><br>            <td>O(nlog2n)</td><br>            <td>O(n²)</td><br>            <td>O(log2n)</td><br>            <td>否</td><br>        </tr><br>        <tr><br>            <td>堆排序</td><br>            <td>O(nlog2n)</td><br>            <td>O(nlog2n)</td><br>            <td>O(nlog2n)</td><br>            <td>O(1)</td><br>            <td>否</td><br>        </tr><br>        <tr><br>            <td>2-路归并排序</td><br>            <td>O(nlog2n)</td><br>            <td>O(nlog2n)</td><br>            <td>O(nlog2n)</td><br>            <td>O(n)</td><br>            <td>是</td><br>        </tr><br>        <tr><br>            <td>基数排序</td><br>            <td>O(d(n+r))</td><br>            <td>O(d(n+r))</td><br>            <td>O(d(n+r))</td><br>            <td>O(r)</td><br>            <td>是</td><br>        </tr><br>    </table><h3 id="排序算法的应用"><a href="#排序算法的应用" class="headerlink" title="排序算法的应用"></a>排序算法的应用</h3><h4 id="（1）选取排序方法需要考虑的因素："><a href="#（1）选取排序方法需要考虑的因素：" class="headerlink" title="（1）选取排序方法需要考虑的因素："></a>（1）选取排序方法需要考虑的因素：</h4><ul><li>待排序的元素数目n</li><li>元素本身信息量的大小</li><li>关键自结构及其分布情况</li><li>稳定性的要求</li><li>语言工具的条件，存储结构及辅助空间的大小</li></ul><h4 id="（2）排序算法小结："><a href="#（2）排序算法小结：" class="headerlink" title="（2）排序算法小结："></a>（2）排序算法小结：</h4><ul><li>若n（n&lt;=50）较小，则可以采用<strong>直接插入排序</strong>和<strong>简单选择排序</strong>。当记录本身信息量较大的时候，用<strong>简单选择排序较好</strong>。</li><li>若文件的初始状态已关键字基本有序，则选用<strong>直接插入</strong>或<strong>冒泡排序</strong>为宜。</li><li><p>若n较大，则采用时间复杂度为<code>O(nlog2n)</code>的排序方法：<strong>快速排序、堆排序、归并排序</strong>。</p><ul><li>快速排序被认为是目前基于比骄傲的每部排序法中最好的方法。（不稳定）</li><li>堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。（稳定）</li><li>当追求稳定时，可以采用归并排序。但通常不提倡2-路归并，而是将它和直接插入排序结合在一起使用。直接插入排序是稳定的，因此改进后的归并排序仍是稳定的。</li></ul></li><li><p>当文件的n个关键字随机分布时，任何借助“比较”的排序算法，至少需要<code>O(nlog2n)</code>的时间。</p></li><li>当n很大，记录的关键字位数较少且可以分解时，采用基数排序较好。</li><li>当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结构。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;同样是复习总结。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="复习" scheme="http://yangkunyi.com/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="博客" scheme="http://yangkunyi.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="数据结构" scheme="http://yangkunyi.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>查找（数据结构）</title>
    <link href="http://yangkunyi.com/2018/08/21/%E6%9F%A5%E6%89%BE%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/"/>
    <id>http://yangkunyi.com/2018/08/21/查找（数据结构）/</id>
    <published>2018-08-21T08:27:36.000Z</published>
    <updated>2018-08-21T08:30:27.070Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天数据结构复习到查找部分，正好将这一部分初步整理出来，以便之后学习的时候参考复习。</p></blockquote><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>查找：在数据集合中寻找满足某种条件的数据元素的过程。</li><li><p>查找结果：</p><ul><li>查找成功</li><li>查找失败</li></ul></li><li><p><strong>查找表：用于查找数据集合。</strong><br>查找表的操作：</p><ul><li>1.查找是否存在某个特定元素（静态）</li><li>2.检索满足条件的某个特定元素的属性（静态）</li><li>3.在查找表中删除一个数据元素（动态）</li><li>4.在查找表中插入一个数据元素（动态）</li></ul></li><li>动态：二叉排序树的查找；散列查找；</li><li><p>静态：顺序查找；折半查找；散列查找；</p></li><li><p>关键字：数据元素中唯一标识该元素的某个数据项的值。</p></li><li>平均查找长度：是衡量查找算法效率的最主要指标。</li></ul><h2 id="1-顺序查找（线性查找）"><a href="#1-顺序查找（线性查找）" class="headerlink" title="1.顺序查找（线性查找）"></a>1.顺序查找（线性查找）</h2><h3 id="1）一般线性表的顺序查找（无序）"><a href="#1）一般线性表的顺序查找（无序）" class="headerlink" title="1）一般线性表的顺序查找（无序）"></a>1）一般线性表的顺序查找（无序）</h3><ul><li>算法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 顺序查找</div><div class="line">typedef struct&#123;                      //查找表的顺序结构</div><div class="line">    ElemType *elem;                  //元素储存空间地址，建表时按实际长度分配，0号单元留空（哨兵）</div><div class="line">    int TableLen;                    //表的长度</div><div class="line">&#125;SSTable;</div><div class="line">int Search_seq(SSTable ST,ElemType key)&#123;</div><div class="line">    //在顺序表ST中顺序查找关键字为key的元素，若找到则返回元素在表中的位置</div><div class="line">    ST.elem[0] = key;                //&quot;哨兵&quot;</div><div class="line">    for(i=ST.TableLen;ST.elem[i]!=key;i--)  ;   //从后往前找</div><div class="line">    return i;                        //若表中不存在关键字为key的元素，将查找到i为0时退出for循环</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>缺点：当n较大的时，平均查找长度较大，效率低；</li><li>优点：对数据元素的存储没有要求，顺序存储或链式存储皆可；对表中记录的有序性也没有要求，无论记录是否按照关键码有序均可应用。</li><li><strong>平均查找长度：(n+1)/2</strong></li></ul><p><strong><em>注意：对线性的链表只能进行顺序查找。</em></strong></p><h3 id="2）有序表的顺序查找"><a href="#2）有序表的顺序查找" class="headerlink" title="2）有序表的顺序查找"></a>2）有序表的顺序查找</h3><ul><li>查找失败可以不再找到表的另一端，能降低顺序查找失败的平均查找长度。</li><li>查找平均长度：<ul><li>成功：(n+1)/2</li><li>失败：n/2+n/(n+1)</li></ul></li></ul><h2 id="2-折半查找（二分查找）"><a href="#2-折半查找（二分查找）" class="headerlink" title="2.折半查找（二分查找）"></a>2.折半查找（二分查找）</h2><ul><li>算法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//二分查找</div><div class="line">int Binary_Search(SeqList L,ElemType key)&#123;</div><div class="line">    //在有序表L中查找关键字为key的元素，若存在则返回其位置，不存在则返回-1</div><div class="line">    int low = 0,hight = L.TableLen-1,mid;</div><div class="line">    while(low&lt;=high)&#123;</div><div class="line">        mid = (low + high)/2;        //取中间位置</div><div class="line">        if(L.elem[mid] == key)</div><div class="line">            return mid;              //查找成功则返回所在位置</div><div class="line">        else if(L.elem[mid]&gt;key)</div><div class="line">            high = mid - 1;          //从前半部分继续查找</div><div class="line">        else</div><div class="line">            low = mid + 1;           //从后半部分继续查找</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>判定树（计算成功和不成功的平查找长度）</strong></li></ul><h2 id="3-分块查找（索引顺序查找）"><a href="#3-分块查找（索引顺序查找）" class="headerlink" title="3.分块查找（索引顺序查找）"></a>3.分块查找（索引顺序查找）</h2><ul><li>块内的元素可以无序，但块之间是有序的。</li><li>步骤：<ul><li>1.在索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表</li><li>2.在块内顺序查找</li></ul></li></ul><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><ul><li>散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为<code>Hash(key)=Addr</code>。（的地址可以是数组下标、索引、或内存地址等）</li><li>冲突：散列函数可能会把两个以上的不同关键字映射到同一地址</li><li>同义词：发生冲突的不同关键字</li><li>散列表：是根据关键字而直接进行访问的数据结构</li><li>对散列表进行查找的时间复杂度为O(1)</li></ul><h3 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h3><ul><li>注意:<ul><li>1.散列函数的定义域必须包含全部需要储存的关键字，而值域的范围则依赖于散列函数表的大小或地址范围</li><li>2.散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间，从而减少冲突的发生</li><li>3.散列函数应尽量简单，能够在较短的时间内就计算出任一关键字对应的散列地址</li><li>4.实际的选择中，采用何种构造散列函数的方法取决于关键字集合的情况，但是目标是为了使产生的冲突的可能性尽量的降低</li></ul></li></ul><h4 id="（1）直接定址法"><a href="#（1）直接定址法" class="headerlink" title="（1）直接定址法"></a>（1）直接定址法</h4><ul><li>直接取关键字的某个函数值为散列地址，散列函数为：<code>H(key)=a×key+b</code>。这种方法计算简单，并且不会产生冲突。</li><li>它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，将造成储存空间的浪费。</li></ul><h4 id="（2）除留余数法"><a href="#（2）除留余数法" class="headerlink" title="（2）除留余数法"></a>（2）除留余数法</h4><ul><li>这是一种最简单、最常用的方法，假定散列表表长为m，出下一个不大于m但最接近或等于m的质数p，利用<code>H(key)=key%p</code>的公式把关键字转换成散列地址。</li><li>该方法关键的是选好p，使得每一个关键字通过函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性。</li></ul><h4 id="（3）数字分析法"><a href="#（3）数字分析法" class="headerlink" title="（3）数字分析法"></a>（3）数字分析法</h4><ul><li>设关键字是r进制数（如十进制），而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几处数码经常出现，则应选数码分布较为均匀的若干位作为散列地址。</li><li>这种方法适合于已知的关键字集合，如果更换了关键字，就需要重新构造新的散列函数。</li></ul><h4 id="（4）平方取中法"><a href="#（4）平方取中法" class="headerlink" title="（4）平方取中法"></a>（4）平方取中法</h4><ul><li>顾名思义，取关键字的平方值的中间几位作为散列地址。具体多少位要看实际情况而定。这种方法取到的散列地址和关键字的每一位都有关系，使得散列地址分布布较均匀。</li><li>适用于关键字的每一位取值都不够均匀或均小于散列地址所需的函数。</li></ul><p>####（5）折叠法</p><ul><li>将关键字分割成位数相同的及部分（最后一部分的位数可以短一些），然后取这几部分的折叠和作为散列地址。</li><li>关键字位数很多，而且关键字中每一位上数字分布大致均匀时，可以采用折叠法得到散列地址。</li></ul><p>####（6）随机数法</p><ul><li>选择一随机函数，取关键字的随机值作为散列地址。</li><li>通常用于关键字长度不同的场合。</li></ul><h3 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h3><blockquote><p>任何设计出来的散列函数都不可能绝对地避免冲突，为此，必须考虑在发生冲突时应该如何进行处理，即为产生冲突的关键字寻找下一个“空”的Hash地址。</p></blockquote><h4 id="（1）开放定址法"><a href="#（1）开放定址法" class="headerlink" title="（1）开放定址法"></a>（1）开放定址法</h4><ul><li>可存放新表项的空闲地址既向它的同义词表现开放，又向它的非同义词表项开放。</li></ul><h5 id="A-线性探测法"><a href="#A-线性探测法" class="headerlink" title="A.线性探测法"></a>A.线性探测法</h5><ul><li>冲突发生时，顺序表查看表中下一个单元（当探测到表尾m-1时，下一个探测地址是表首地址0），直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。</li><li>缺点：可能时第i个散列地址的同义词存入第i+1个散列地址，这样本应存入第i+1个散列地址的元素就争夺第i+2个散列地址的元素的地址……，从而在成大量元素的响铃的散列地址上“聚集”（或堆积）起来，大大降低了查找效率。</li></ul><h5 id="B-平方探测法（二次探测法）"><a href="#B-平方探测法（二次探测法）" class="headerlink" title="B.平方探测法（二次探测法）"></a>B.平方探测法（二次探测法）</h5><ul><li>这是一种较好的处理冲突的方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少探测到一半的单元。</li></ul><h5 id="C-再散列法（双散列法）"><a href="#C-再散列法（双散列法）" class="headerlink" title="C.再散列法（双散列法）"></a>C.再散列法（双散列法）</h5><ul><li>需要两个散列函数，当通过第一个散列函数H(key)得到的地址发生冲突时，则利用第二个散列函数<code>Hash2(key)=&gt;[H=(H(key)+i*Hash2(key))%m]</code>计算该关键字的地址增量。</li></ul><h5 id="D-伪随机序列法"><a href="#D-伪随机序列法" class="headerlink" title="D.伪随机序列法"></a>D.伪随机序列法</h5><ul><li>利用伪随机数序列</li></ul><h4 id="（2）拉链法"><a href="#（2）拉链法" class="headerlink" title="（2）拉链法"></a>（2）拉链法</h4><ul><li>为了避免非同义词发生冲突，可以把所有的同义词储存在一个线性链表中，这个线性链表由其散列地址唯一标识。</li><li>适用于经常进行插入和删除的情况。</li></ul><h3 id="散列的查找和性能分析"><a href="#散列的查找和性能分析" class="headerlink" title="散列的查找和性能分析"></a>散列的查找和性能分析</h3><ul><li>查找与构造方式基本一致。</li><li>散列表的查找效率取决于三个因素：散列函数、处理冲突的方式和填装因子。</li><li><strong>填装因子：</strong><code>α=表中记录数n/散列表长度m</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天数据结构复习到查找部分，正好将这一部分初步整理出来，以便之后学习的时候参考复习。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="复习" scheme="http://yangkunyi.com/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="博客" scheme="http://yangkunyi.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="数据结构" scheme="http://yangkunyi.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数列学习</title>
    <link href="http://yangkunyi.com/2018/07/25/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yangkunyi.com/2018/07/25/斐波那契数列学习/</id>
    <published>2018-07-25T13:50:38.000Z</published>
    <updated>2018-07-25T13:52:05.222Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>复习过程中涉及到计算算法的时间复杂度，课后例题中的“计算斐波那契数列时间复杂度”引起了自己的思考，通过学习，总结出好集中不同的方式。</p></blockquote><a id="more"></a><h2 id="斐波那契数列简介"><a href="#斐波那契数列简介" class="headerlink" title="斐波那契数列简介"></a>斐波那契数列简介</h2><blockquote><p>斐波那契数列（意大利语：Successione di Fibonacci），又译为菲波拿契数列、菲波那西数列、斐波那契数列、黄金分割数列。<br>在数学上，费波那契数列是以递归的方法来定义：</p></blockquote><ul><li>F[0] = 0</li><li>F[1] = 0</li><li>F[n] = F[n-1] + F<a href="n&gt;=2">n-2</a></li></ul><blockquote><p>用文字来说，就是费波那契数列由0和1开始，之后的费波那契系数就是由之前的两数相加而得出。首几个费波那契系数是：</p></blockquote><ul><li>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233……</li></ul><blockquote><p>特别指出：0不是第一项，而是第零项。</p></blockquote><h2 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h2><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><p>递归计算斐波那契数列的JavaScript如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Fibonacci1(n)&#123;</div><div class="line">    if(n==0)</div><div class="line">        return 0;</div><div class="line">    if(n==1)</div><div class="line">        return 1;</div><div class="line">    return Fibonacci1(n-1) + Fibonacci1(n-2);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>递归的方法很简单，但是显然十分显然存在大量的重复运算，效率低下很低，还会占用大量的内存。</p><ul><li>时间复杂度：T(n) = O(2^n)</li></ul><h4 id="递推法"><a href="#递推法" class="headerlink" title="递推法"></a>递推法</h4><p>为了避免递归的低效率，我们可以采取累加的方式，一项一项的计算，JavaScript代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Fibonacci2(n)&#123;</div><div class="line">    a = 0;</div><div class="line">    b = 1;</div><div class="line">    if(n==0)</div><div class="line">        return a;</div><div class="line">    for(i = 1;i &lt;= n;i++)&#123;</div><div class="line">        c = a + b;</div><div class="line">        a = b;</div><div class="line">        b = c;</div><div class="line">    &#125;</div><div class="line">    return c;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>时间复杂度：T(n) = O(n)</li><li>空间复杂度：O(n)</li></ul><h4 id="公式法"><a href="#公式法" class="headerlink" title="公式法"></a>公式法</h4><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><p>以下是斐波那契数列的常见递推公式：</p><p>$$ F_{n}=\dfrac {1}{\sqrt {5}}\times \left[ \left( \dfrac {1+\sqrt {5}}{2}\right) ^{n}-\left( \dfrac {1-\sqrt {5}}{2}\right) ^{n}\right] $$</p><p>公式法的JavaScript代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Fibonacci3(n)&#123;</div><div class="line">    root_five = sqrt(5);</div><div class="line">    f1=f2=1;</div><div class="line">    for(i=1;i&lt;=n;i++)&#123;</div><div class="line">        f1 *= (1+root_five)/2;</div><div class="line">        f2 *= (1-root_five)/2;</div><div class="line">    &#125;</div><div class="line">    result = (f1 - f2)/root_five;</div><div class="line">    return int(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>虽然公式看起来不是很复杂，但是当中有很多的浮点运算，返回的结果也会因为n越来越大而不断产生更大的误差，因此并不可靠。</p><h4 id="矩阵法"><a href="#矩阵法" class="headerlink" title="矩阵法"></a>矩阵法</h4><p>$$ \begin{bmatrix} F<em>{n} \ F</em>{n-1} \end{bmatrix}=\begin{bmatrix} F<em>{n-1}+F</em>{n-2} \ F<em>{n-1} \end{bmatrix}=\begin{bmatrix} 1\times f</em>{n-1}+1\times F<em>{n}-2 \ 1\times f</em>{n-1}+0\times F_{n-2} \end{bmatrix}=\begin{bmatrix}<br>1 &amp; 1 \<br>1 &amp; 0<br>\end{bmatrix} $$</p><p>由此可推得：</p><p>$$ \begin{bmatrix} F<em>{n} \ F</em>{n-1} \end{bmatrix}=\begin{bmatrix} 1 &amp; 1 \ 1 &amp; 0 \end{bmatrix}^{n-1}\times \begin{bmatrix} F<em>{1} \ F</em>{0} \end{bmatrix}=\begin{bmatrix} 1 &amp; 1 \ 1 &amp; 0 \end{bmatrix}^{n-1}\times \begin{bmatrix} 1 \ 0 \end{bmatrix} $$</p><p>那这里就把问题转换为了求矩阵的n-1次幂，利用快速幂的方式来计算：</p><p>$$ a_{n}=\begin{cases}a^{\dfrac {n}{2}}a^{\dfrac {n}{2}},ifniseven\ a^{\dfrac {n-1}{2}}a^{\dfrac {n-1}{2}}a,ifnisodd\end{cases} $$</p><p>以上方法的JavaScript代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// 矩阵乘法</div><div class="line">function multiMatrix(int[][] m1,int[][] m2) &#123;</div><div class="line">//参数判断什么的就不给了，如果矩阵是n*m和m*p,那结果是n*p</div><div class="line">    int[][] res = new int[m1.length][m2[0].length];</div><div class="line">    for (int i = 0; i &lt; m1.length; i++) &#123;</div><div class="line">        for (int j = 0; j &lt; m2[0].length; j++) &#123;</div><div class="line">            for (int k = 0; k &lt; m2.length; k++) &#123;</div><div class="line">                res[i][j] += m1[i][k] * m2[k][j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return res;</div><div class="line">&#125;</div><div class="line">// 矩阵快速幂</div><div class="line">function Fibonacci4(int n) &#123;</div><div class="line">    if (n &lt; 1) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    if (n == 1 || n == 2) &#123; </div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    //底</div><div class="line">    int[][] base = &#123;&#123;1,1&#125;,</div><div class="line">                    &#123;1,0&#125;&#125;;</div><div class="line">    //求底为base矩阵的n-2次幂</div><div class="line">    int[][] res = matrixPower(base, n - 2);</div><div class="line">    //根据[f(n),f(n-1)] = [1,1] * &#123;[1,1],[1,0]&#125;^(n-2)，f(n)就是</div><div class="line">    //1*res[0][0] + 1*res[1][0]</div><div class="line">    return res[0][0] + res[1][0];</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>时间复杂度：T(n) = O(log(n)) </li></ul><blockquote><p>今天的学习过程中并不是全部都理解透彻了，关于时间复杂度也还有更长的路去学习，本文仅关于一道课后题延伸出这些内容。<br>未完待续~~~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;复习过程中涉及到计算算法的时间复杂度，课后例题中的“计算斐波那契数列时间复杂度”引起了自己的思考，通过学习，总结出好集中不同的方式。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="学习" scheme="http://yangkunyi.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据结构" scheme="http://yangkunyi.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>NodePPT</title>
    <link href="http://yangkunyi.com/2018/04/11/NodePPT/"/>
    <id>http://yangkunyi.com/2018/04/11/NodePPT/</id>
    <published>2018-04-11T06:38:20.000Z</published>
    <updated>2018-04-11T06:40:45.520Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>用了好几次这个ppt，自己确实觉得这是用过的ppt中最简洁，B格最高的ppt，但是每次做都要去看原文档，十分的不方便，因此自己写一篇文章，将经常使用的一些命令和参数记录下来。<br>例子：<a href="https://yangkunyi.com/Share/ppt.html">https://yangkunyi.com/Share/ppt.html</a><br>原文：<a href="https://github.com/ksky521/nodeppt" target="_blank" rel="external">https://github.com/ksky521/nodeppt</a></p></blockquote><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>这是一款网页ppt库，只需要编辑相应的md文档就可以做出演示ppt，支持markdown,html,css,js等不同的语言，十分的方便。</p></blockquote><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="本地跑md文档"><a href="#本地跑md文档" class="headerlink" title="本地跑md文档"></a>本地跑md文档</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// port是端口号</div><div class="line">nodeppt start -p &lt;port&gt;</div></pre></td></tr></table></figure><h4 id="生成html文档"><a href="#生成html文档" class="headerlink" title="生成html文档"></a>生成html文档</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 默认生成publish文件夹</div><div class="line">nodeppt generate filename -a</div></pre></td></tr></table></figure><h3 id="常用主题和动画"><a href="#常用主题和动画" class="headerlink" title="常用主题和动画"></a>常用主题和动画</h3><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p><code>colors</code>-<code>moon</code>-<code>blue</code>-<code>dark</code>-<code>green</code>-<code>light</code></p><h4 id="翻页动画"><a href="#翻页动画" class="headerlink" title="翻页动画"></a>翻页动画</h4><ul><li>kontext</li><li>vkontext</li><li>circle</li><li>earthquake</li><li>cards</li><li>glue</li><li>stick</li><li>move</li><li>newspaper</li><li>slide</li><li>slide2</li><li>slide3</li><li>horizontal3d</li><li>horizontal</li><li>vertical3d</li><li>zoomin</li><li>zoomout</li><li>pulse</li></ul><h4 id="单页动画语法"><a href="#单页动画语法" class="headerlink" title="单页动画语法"></a>单页动画语法</h4><blockquote><p><code>{:&amp;.动画}</code></p></blockquote><hr><blockquote><p>因为自己又经常将ppt放到GitHub上去，所以也顺便记一下git的常用指令</p></blockquote><h2 id="git常用指令"><a href="#git常用指令" class="headerlink" title="git常用指令"></a>git常用指令</h2><h4 id="从本地上传到仓库的步骤"><a href="#从本地上传到仓库的步骤" class="headerlink" title="从本地上传到仓库的步骤"></a>从本地上传到仓库的步骤</h4><ol><li><code>git init</code></li><li><code>git add .</code></li><li><code>git commit -m &#39;备注&#39;</code></li><li><code>git remote origin add 仓库地址</code></li><li><code>git pull</code> //当仓库不为空的时候需要做的工作</li><li><code>git push</code></li><li><code>git status</code> //查询状态</li></ol><p><img src="http://otn4ut2th.bkt.clouddn.com/bloggithub.png" alt="git指令"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;用了好几次这个ppt，自己确实觉得这是用过的ppt中最简洁，B格最高的ppt，但是每次做都要去看原文档，十分的不方便，因此自己写一篇文章，将经常使用的一些命令和参数记录下来。&lt;br&gt;例子：&lt;a href=&quot;https://yangkunyi.com/Share/ppt.html&quot;&gt;https://yangkunyi.com/Share/ppt.html&lt;/a&gt;&lt;br&gt;原文：&lt;a href=&quot;https://github.com/ksky521/nodeppt&quot;&gt;https://github.com/ksky521/nodeppt&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="nodeppt" scheme="http://yangkunyi.com/tags/nodeppt/"/>
    
      <category term="学习" scheme="http://yangkunyi.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Day-1</title>
    <link href="http://yangkunyi.com/2018/03/12/Day-1/"/>
    <id>http://yangkunyi.com/2018/03/12/Day-1/</id>
    <published>2018-03-12T15:37:15.000Z</published>
    <updated>2018-03-12T16:17:40.878Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是自己游戏开始的第一天。</p></blockquote><a id="more"></a><h2 id="今日游戏进度"><a href="#今日游戏进度" class="headerlink" title="今日游戏进度"></a>今日游戏进度</h2><ul><li>完成英语的记忆</li></ul><blockquote><p>今天因为课程和学分的事情，未完成数学的学习，明天除了代课以外，应该能够完成自己定的计划。</p></blockquote><h2 id="今日完成事项"><a href="#今日完成事项" class="headerlink" title="今日完成事项"></a>今日完成事项</h2><ul><li>通信课程学分认定</li><li>课表课程</li><li>再次思考学校（电子科技大学 VS 四川大学）</li></ul><h2 id="明日安排"><a href="#明日安排" class="headerlink" title="明日安排"></a>明日安排</h2><ul><li>代课</li></ul><h2 id="待更进事项"><a href="#待更进事项" class="headerlink" title="待更进事项"></a>待更进事项</h2><ul><li>思想报告（2016年11月-2018年3月）</li><li>微信订阅号</li><li>博客更新</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是自己游戏开始的第一天。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="游戏攻略" scheme="http://yangkunyi.com/tags/%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5/"/>
    
      <category term="日记" scheme="http://yangkunyi.com/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>WeeklyMind-8</title>
    <link href="http://yangkunyi.com/2018/03/11/WeeklyMind-8/"/>
    <id>http://yangkunyi.com/2018/03/11/WeeklyMind-8/</id>
    <published>2018-03-11T15:36:44.000Z</published>
    <updated>2018-03-12T16:17:51.436Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是开学第一周，经过一个寒假的思考，自己选择了和之前不同的决定，那就是考研。</p></blockquote><a id="more"></a><h2 id="寒假小结"><a href="#寒假小结" class="headerlink" title="寒假小结"></a>寒假小结</h2><h4 id="“锦城之行”"><a href="#“锦城之行”" class="headerlink" title="“锦城之行”"></a>“锦城之行”</h4><blockquote><p>过程中虽然我和室长都没有提起这项人生大事，但从室长的言语中，我感受到了她心中的那份宁静，也不愿再去打破，如果这是她愿意的，也接受的，并且感受到了快乐，那接受又有什么不好呢。而自己可能还是有点不甘心吧，不想就这样过了，大学的生活过了一大半，找个工作，然后挣钱，生活，大半辈子就这样过去了，我怕到时候自己会后悔，我还想学习，其中也有一点点小小的逃避，我也不否认，所以我想再为自己努力一下吧，反正就一年，拿来学习，我相信自己还是可以的，毕竟也是经历过这样子考试的了，为了自己想要过的生活，自己也需要在上一层楼。<br>这些都是自己想的，也不知道你怎么想的。<br>两天的行程很短，但很精彩，真的很放松，在那边和室友一起出去玩的时候就经常想着有机会一定要和你出门玩一次，我们一起看逛了想逛的地方，吃了想吃的东西，这次经历我会一直记得。不过还是要说室长真的缺乏锻炼啊，我是一个喜欢散步得人，而你好像并不是很喜欢走路啊，老是走走就累了。</p></blockquote><h4 id="三三（家兔，已亡）和十七（安哥拉兔）"><a href="#三三（家兔，已亡）和十七（安哥拉兔）" class="headerlink" title="三三（家兔，已亡）和十七（安哥拉兔）"></a>三三（家兔，已亡）和十七（安哥拉兔）</h4><blockquote><p>说起来可能不信，现在十七就在我脚下，还在闹腾呢，突然有一点理解室长有了它们之后为什么得忧虑症，突然除了自己的命以外，身上又背上了一条命，然后我也快忧虑了。</p></blockquote><h4 id="过年"><a href="#过年" class="headerlink" title="过年"></a>过年</h4><blockquote><p>过年最不一样的可能就是除夕了吧，因为今年的除夕没有在家里过，而是和朋友在外面看烟花过的，总的来说感觉还是不错的。<br>然后就是每家的过年饭啊，只是人慢慢长大了，大家都开始有自己的圈子了，可能是观点上的偏差吧，开始有点疏远了。<br>今年过年是真的累，没有一天懒觉不说，自己还心系两门缓考，初六就来了学校。这些都是上学期的后遗症啊。</p></blockquote><h4 id="缓考"><a href="#缓考" class="headerlink" title="缓考"></a>缓考</h4><blockquote><p>一节课没上，用一个周时间复习两门课，然后考试，能及格都是奇迹啦！</p></blockquote><h2 id="考研准备"><a href="#考研准备" class="headerlink" title="考研准备"></a>考研准备</h2><blockquote><p>既然选择了，就要好好的开始准备，自己小金库都拿去报了班，然后还买了ipad，希望更方便看复习资料和视频等，不负青春不负自己。</p></blockquote><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><ul><li>专业：计算机科学与技术</li><li>类型：工学</li><li>学校：四川大学 VS 电子科技大学</li><li>所需分数：380分以上<ul><li>英语：70</li><li>数学：120</li><li>政治：70</li><li>专业：120</li></ul></li></ul><h3 id="考试内容"><a href="#考试内容" class="headerlink" title="考试内容"></a>考试内容</h3><h3 id="101思想政治理论"><a href="#101思想政治理论" class="headerlink" title="101思想政治理论"></a>101思想政治理论</h3><blockquote><p>记忆内容放到后两个月再复习，做题。</p></blockquote><h3 id="201英语一（本学期重点学习）"><a href="#201英语一（本学期重点学习）" class="headerlink" title="201英语一（本学期重点学习）"></a>201英语一（<strong>本学期重点学习</strong>）</h3><ul><li>词汇量</li><li>阅读能力</li><li>写作能力</li></ul><h3 id="301数学一（本学期重点学习）"><a href="#301数学一（本学期重点学习）" class="headerlink" title="301数学一（本学期重点学习）"></a>301数学一（<strong>本学期重点学习</strong>）</h3><ul><li>高等数学　56%</li><li>线性代数　22%</li><li>概率论与数理统计 22%</li></ul><h3 id="874-or-820计算机科学专业基础综合"><a href="#874-or-820计算机科学专业基础综合" class="headerlink" title="874 or 820计算机科学专业基础综合"></a>874 or 820计算机科学专业基础综合</h3><blockquote><p>这三本书都学过，这学期再过一遍，做做练习题。<br>PS：九月出考试大纲，根据大纲再复习。</p></blockquote><ul><li>数据结构（严蔚敏c语言版）</li><li>操作系统（汤子瀛）</li><li>计算机网络（谢希仁）</li></ul><h3 id="时间大纲"><a href="#时间大纲" class="headerlink" title="时间大纲"></a>时间大纲</h3><h4 id="8：00"><a href="#8：00" class="headerlink" title="8：00"></a>8：00</h4><ul><li>起床</li><li>洗漱</li><li>早饭</li></ul><h4 id="9：00之前"><a href="#9：00之前" class="headerlink" title="9：00之前"></a>9：00之前</h4><ul><li>到图书馆</li><li>每日英语</li><li>专业课复习</li></ul><h4 id="12：00-14：00"><a href="#12：00-14：00" class="headerlink" title="12：00 ~ 14：00"></a>12：00 ~ 14：00</h4><ul><li>午饭</li><li>午休</li></ul><h4 id="14：00之后"><a href="#14：00之后" class="headerlink" title="14：00之后"></a>14：00之后</h4><ul><li>每日数学</li><li>专业课复习</li></ul><h4 id="18：00-19：00"><a href="#18：00-19：00" class="headerlink" title="18：00 ~ 19：00"></a>18：00 ~ 19：00</h4><ul><li>晚饭</li><li>散步（回忆今天所复习的内容）</li></ul><h4 id="19：00-21：30"><a href="#19：00-21：30" class="headerlink" title="19：00 ~ 21：30"></a>19：00 ~ 21：30</h4><ul><li>自由学习时间</li><li>日记</li></ul><h4 id="21：40"><a href="#21：40" class="headerlink" title="21：40 ~"></a>21：40 ~</h4><ul><li>跑步</li><li>洗漱</li><li>睡觉</li></ul><h3 id="一天的学习量"><a href="#一天的学习量" class="headerlink" title="一天的学习量"></a>一天的学习量</h3><blockquote><p>这里的量会灵活机动一点，而不是所谓的一定，自己之所以做这个计划，是希望自己知道什么时候该做什么，而不是有时候无所事事。</p></blockquote><ul><li>英语：根据单词书，每天定量完成。</li><li>数学：一个月至少完成一本书！一天就大概是三节到四节的内容（可根据难易程度调整）。</li><li>专业：根绝英语和数学的量，适当看书做练习，做到对专业知识的敏感和熟悉，为后面的复习打下基础。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是开学第一周，经过一个寒假的思考，自己选择了和之前不同的决定，那就是考研。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="周记" scheme="http://yangkunyi.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深层理解GET与POST</title>
    <link href="http://yangkunyi.com/2018/01/09/%E6%B7%B1%E5%B1%82%E7%90%86%E8%A7%A3GET%E4%B8%8EPOST/"/>
    <id>http://yangkunyi.com/2018/01/09/深层理解GET与POST/</id>
    <published>2018-01-09T06:00:39.000Z</published>
    <updated>2018-01-09T06:02:33.948Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>推荐文章中，再次理解了GET与POST。</p></blockquote><a id="more"></a><p>GET与POST是HTTP请求的两种方式，每次谈到，不免都是想说这两者的区别嘛，之前自己也只是模糊的知道POST方法好一点，为什么，自己也只能回答一句，安全一点嘛，觉得说得太少了，于是去搜索了一下，以下是w3schools给出的答案：</p><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ul><p>说得真是有道理，没错啊，这就是区别啊，但是这样的答案大家背一背什么的就都会说了，但是这就完了吗？以上的自己都能理解，但是我觉得都只是现象，并不是原因啊！于是继续懵逼，直到看到下面的解释，自己好像慢慢开始理解了。</p><p>原文链接<a href="https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4" target="_blank" rel="external">99%的人都理解错了GET与POST</a></p><p>既然说GET与POST是HTTP请求的两种方式，那什么是HTTP？</p><p>学过一点计算机网络的我有点印象，但是也不记得官方咋说的了，于是借鉴一下别人的话：</p><blockquote><p>HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。</p></blockquote><p>那既然HTTP的底层是TCP/IP，GET与POST自然也是基于TCP/IP咯，那GET与POST就是TCP/IP的两种链接方式了，那它们的区别到底在哪里呢？</p><p>借助原文的比喻：</p><blockquote><p>在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。</p></blockquote><p>既然只是对传输数据的方式有要求，那关于参数的大小要求又从哪里来的？</p><p>这就是“运输公司”——浏览器和服务器不同导致的，业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到。</p><p>现在，我知道了，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。这个时候我觉得标准答案的现象我都可以解释了。</p><p>紧接着，我又看到了一个令我目瞪口呆的区别：</p><blockquote><p>简单的说：<br><strong>GET产生一个TCP数据包；POST产生两个TCP数据包。</strong></p></blockquote><p>这是什么情况，我难道睡觉的时候老师讲重点了！！！？？？反正就是现在才知道这么重要的知识点。</p><p>好吧，了解之后明白了，GET在请求的时候会一次性将header和data发出去，然后服务器响应200（返回数据）；而POST会先发header，等到服务器响应100（continue）的时候再发送data，然后服务器返回200（返回数据）。</p><p>POST两次发送骤导致时间上消耗要多一点，那GET看起来就更有效了，于是Yahoo团队推荐将所有的POST请求用GET请求替换，以此来优化网页性能，无可厚非这可以达到一定效果，但很明显也是一个坑啊！</p><p>为什么？</p><ul><li>存在即合理啊！（GET与POST都有自己的语义，不能随便混用。）</li><li>网速够快这点时间可以忽略（据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。），而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li><li>并不是所有“运输公司”（浏览器）都会在POST中发送两次包，Firefox就只发送一次。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;推荐文章中，再次理解了GET与POST。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="学习" scheme="http://yangkunyi.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="web" scheme="http://yangkunyi.com/tags/web/"/>
    
      <category term="GET" scheme="http://yangkunyi.com/tags/GET/"/>
    
      <category term="POST" scheme="http://yangkunyi.com/tags/POST/"/>
    
  </entry>
  
  <entry>
    <title>WeeklyMind-7</title>
    <link href="http://yangkunyi.com/2018/01/07/WeeklyMind-7/"/>
    <id>http://yangkunyi.com/2018/01/07/WeeklyMind-7/</id>
    <published>2018-01-07T15:39:16.000Z</published>
    <updated>2018-01-07T15:48:06.429Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>期末周真的很崩溃，赶各种报告，还要复习，命天要考不动产管理和西方哲学史，不动产管理自己都快要放弃了，今天下午又整理出二十页pdf的知识点，也是选择随缘了，反正这个周就是很忙碌就对了，为了复习自己周末都去图书馆了，真是不敢相信！！！</p></blockquote><a id="more"></a><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul><li>web网页程序设计已经结课了，这个对有基础的自己来说，不难，也没有担心什么，成绩也在自己的规划之中。</li><li>行销管理的报告初步形态也基本完成，明天早起去把名片打印出来就行了。</li><li>再来是明天要考试的两门，脑子已经不够用了！</li><li>周三的财务管理也算复习了三个单元了，但还是不算有底，主要是有一个数据不会算！！！这个问题要在明天和后天晚上的时间里面解决了。</li><li>最后周四还有一门课堂的期末报告，不过时间还够，所以不用太担心。</li><li>还有就是自己的博客有改一些个性化设置，更新了主题。</li></ul><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul><li>明明前两天都还是清空万里，到考试就大雨滂沱，自己不太喜欢雨天，所以有点点影响心情吧。</li><li>这个周都睡得比较晚，生物钟感觉都已经变了，不过自己也能接受。</li><li>其实就是很普通的一个周，所以自己也想不起太多想写的东西。</li></ul><h2 id="待更进事项"><a href="#待更进事项" class="headerlink" title="待更进事项"></a>待更进事项</h2><ul><li>走之前给自己写一封信</li><li>走之前给家里写一封信</li><li>思想报告</li><li>期末报告</li><li>联系老师商量考试安排</li></ul><blockquote><p>今天雨，可是我们在一起</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;期末周真的很崩溃，赶各种报告，还要复习，命天要考不动产管理和西方哲学史，不动产管理自己都快要放弃了，今天下午又整理出二十页pdf的知识点，也是选择随缘了，反正这个周就是很忙碌就对了，为了复习自己周末都去图书馆了，真是不敢相信！！！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="周记" scheme="http://yangkunyi.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>西方哲学史期末复习</title>
    <link href="http://yangkunyi.com/2018/01/07/%E8%A5%BF%E6%96%B9%E5%93%B2%E5%AD%A6%E5%8F%B2%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yangkunyi.com/2018/01/07/西方哲学史期末复习/</id>
    <published>2018-01-07T15:22:08.000Z</published>
    <updated>2018-01-07T15:26:13.213Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>明天期末考试，今天下午整理出来的复习资料，这还只是后半学期的，简直要疯了，最后还是佛系的选择随缘了！</p></blockquote><a id="more"></a><h2 id="柏克莱"><a href="#柏克莱" class="headerlink" title="柏克莱"></a>柏克莱</h2><h3 id="著作"><a href="#著作" class="headerlink" title="著作"></a>著作</h3><ul><li>《视觉新论》（Essay towards a New Theory of Vision,1709）</li><li>《人类知识原理》（A Treatise concerning the Princeples of Human Knowledge,1710）</li><li>《西利斯和斐罗诺斯得三篇对话》（Three Dialogues between Hylas and Phlionus,1713）</li></ul><h3 id="存在就是被感知（柏克莱）"><a href="#存在就是被感知（柏克莱）" class="headerlink" title="存在就是被感知（柏克莱）"></a>存在就是被感知（柏克莱）</h3><blockquote><p>一切物体的存在都离不开能感知它们的心灵或者说存在于心灵之中。</p></blockquote><ul><li>贝克莱的命题。他站在经验论的立场上，对外物的存在不做断定，认为存在就是观念的存在，而观念的存在，就是观念的感知和被感知，即使没有人感知事物的存在，上帝的心灵也会感知它。从而否认了物质概念的实在性，承认了上帝的存在。</li><li>贝克莱的这一命题是肯定外物客观实在性的基本观点。按照这个命题，根本不存在任何独立于感觉观念的事物，所谓事物无非是被“心灵”实体感知的一组观念，事物和观念是同一个东西，它们的存在只在于被心灵所感知，这夸大经验中的观念，从而陷入了主观唯心主义。</li><li>像洛克一样，贝克莱认为人类知识的对象就是“观念”，而无论哪一种观念都只存在于能感知的能动的实体即心灵之中。换言之，认识的对象是观念，观念只存在于心灵之中，它们不可能离开心灵而独立存在，因此观念的存在就在于被感知。</li><li>既然观念的存在就在于被感知，那就意味着感觉事物的存在就在于被感知，因而一切事物的存在就在于被感知。因为“具有一个观念与感知一个概念是一回事”，“事实上，对象和感觉是一种东西”。所以，事物的存在就是被感知。</li><li>存在就是被感知在贝克莱那里是逻辑地从“物是观念的集合”这一命题中推演出来的。</li></ul><h2 id="休谟（David-Hume）"><a href="#休谟（David-Hume）" class="headerlink" title="休谟（David Hume）"></a>休谟（David Hume）</h2><h3 id="经验主义认识论：观念与印象"><a href="#经验主义认识论：观念与印象" class="headerlink" title="经验主义认识论：观念与印象"></a>经验主义认识论：观念与印象</h3><h4 id="1-认识的起源：表象的分类"><a href="#1-认识的起源：表象的分类" class="headerlink" title="1. 认识的起源：表象的分类"></a>1. 认识的起源：表象的分类</h4><ul><li>印象：强烈而活跃的直觉<ul><li>对外：直接的感性直觉，如视觉、听觉</li><li>对内：直接的心里经验，如愤恨、喜悦</li></ul></li><li>观念：基于先有印象然后产生的心里图像，念的产生有可能经过我们的组合和排序</li></ul><h4 id="2-知识的边界在于观念能过回归印象"><a href="#2-知识的边界在于观念能过回归印象" class="headerlink" title="2. 知识的边界在于观念能过回归印象"></a>2. 知识的边界在于观念能过回归印象</h4><h3 id="可能的知识范围"><a href="#可能的知识范围" class="headerlink" title="可能的知识范围"></a>可能的知识范围</h3><h4 id="1-经验主义只承认有两类知识"><a href="#1-经验主义只承认有两类知识" class="headerlink" title="1. 经验主义只承认有两类知识"></a>1. 经验主义只承认有两类知识</h4><ul><li>经验知识：建立于感性知觉基础上</li><li>数学与逻辑等知识：建立于概念关系的约定规则的基础之上的知识</li></ul><h4 id="2-无法经验的东西"><a href="#2-无法经验的东西" class="headerlink" title="2. 无法经验的东西"></a>2. 无法经验的东西</h4><ul><li>无法经验的动心，又不仅是涉及我们（主体之间）约定上的概念规则的话，则不可能有知识，例如关于上帝和所谓客观规则。</li><li>所以：数学观念对实际存在没有说服力（它们是分析的），反之，经验科学的观念对实在有说服力，他们是综合的。</li></ul><h3 id="休谟的激进经验主义"><a href="#休谟的激进经验主义" class="headerlink" title="休谟的激进经验主义"></a>休谟的激进经验主义</h3><ul><li>我们只经验到不同的感觉印象，却没有什么背后的「实体」，去「承载」这些印象。</li><li>这些感觉印象会以恒常群组的方式出现，我们所说的桌子、椅子，不过就是这些群组本身──而不是背后的什么东西！</li><li>同样，我能把握的仅仅内部印象，当中有些恒常稳定成出现，但幻想背后有一「自我」，实是形而上学幻觉，一种习惯的联想</li></ul><h3 id="休谟的知觉"><a href="#休谟的知觉" class="headerlink" title="休谟的知觉"></a>休谟的知觉</h3><blockquote><p>现代哲学一般接受某种观念理论 (theory of ideas)：认为思想直接对象的是某种心灵之内项目或观念，而不是外在的物理客观。休姆统称观念之为「知觉」(perceptions)。</p></blockquote><ul><li>印象：包括各类感觉 (sensations)，也包含欲望 (desires)、情感 (passions)、情绪 (emotions) 等。</li><li>观念：则是印象「在思想与推理中的模糊影像 (faint images)」。</li><li><strong>观念和印象的关系：摹本原则（简单印象总是先于简单观念）</strong></li></ul><blockquote><p>因为感受 (feeling) 与思想 (thinking) 的差别是清晰的，故此印象与观念之分别亦然。(例当下吃柠檬塔的味觉 vs 记得上周吃过的味道)。</p></blockquote><h4 id="印象"><a href="#印象" class="headerlink" title="印象"></a>印象</h4><ul><li>感觉印象：感觉印象或称为「原初印象」 (original impressions) 。它们包括通过五官而得到各种感觉，以及痛感与快感 (pains and pleasures)。它们之所以称为「原初」，是因为它们是思考不可再回溯的始点，要再探究它们的原因，我们便会跨出经验以外。</li><li>反思印象：反思印象则包括欲望、情绪、情感等等。本质上，它们是心灵对于观念之反应，故此对比于原初印象，休姆称之为第二序印象。例如：对于去年患感冒的记忆是观念，它是去年的原初印象 (患流感的感觉)之影像。此时记起这段记忆，让你感到「害怕」 这年秋冬还会患上流感、「希望」不会再患上流感，等等。</li></ul><h4 id="观念之间的关系"><a href="#观念之间的关系" class="headerlink" title="观念之间的关系"></a>观念之间的关系</h4><blockquote><p><strong>联想关系</strong></p></blockquote><ul><li>思想内容的心理连结，一者引起我想到另一者。</li><li>休姆自许为首位对「联想原则」作系统分类的哲学家。</li><li>分三类联想：<ul><li>(1) 相似 (resemblance)；</li><li>(2) 时空连续 (contiguity in  space and time)；</li><li>(3) 因果 (causation) 。</li></ul></li><li>例子：<ul><li>(1) 画作及其所描绘的主题实物；</li><li>(2) 提及房子的大门入口，想起它的玄关；</li><li>(3) 想到一个伤口，想起它带来的疼痛感。</li></ul></li></ul><h4 id="知觉分类"><a href="#知觉分类" class="headerlink" title="知觉分类"></a>知觉分类</h4><ul><li>简单的：黄、酸、香味，等等。</li><li>复合的：复合印象由简单印象组成，例如「柠檬」的印象 = 黄 + 酸 + 柠檬香味，等等。这些个别的印象是简单印象，因为它们没有组成部份。</li></ul><blockquote><p>印象与观念之别在于力度 (degree of force)或活泼度 (degree of vivacity)。印象比观念更有力、更鲜明与活泼。(休姆没有完全满意这个区分的规定方式)</p></blockquote><h3 id="休谟对因果论的批判"><a href="#休谟对因果论的批判" class="headerlink" title="休谟对因果论的批判"></a>休谟对因果论的批判</h3><ul><li>休谟指出，当我们讨论因果时，我们认为：<ul><li>某现象随另一现象而来。→ 相继性</li><li>两个现象间有接触。→ 接触性</li><li>随接触而来的现象必然发生。→ 必然性</li></ul></li><li>但我们能否真的知道上述3点？<ul><li>休谟：我们能知道1 与 2，但不能知道 3！</li></ul></li></ul><h3 id="对因果论批判的回应"><a href="#对因果论批判的回应" class="headerlink" title="对因果论批判的回应"></a>对因果论批判的回应</h3><ul><li>我们透过归纳法，一再重复的现象关系，使我们可推论出因果关系。</li><li>休谟：只能知道迄今现象关系确是如此，不能说我们知道其确是如此，而且将会如此。</li><li>归纳法与自然科学过往成功显示这类推论有效而可堪继续使用。</li><li>休谟：此论诉诸自然齐一观，但自然齐一若非归纳，便为形上假设。</li><li>若非出于归纳推论，因果概念从何而来？</li><li>休谟：因果概念不过是我们的心理习惯或心理预期。</li></ul><h2 id="康德"><a href="#康德" class="headerlink" title="康德"></a>康德</h2><h3 id="著作-1"><a href="#著作-1" class="headerlink" title="著作"></a>著作</h3><ul><li>《纯粹理性批判》(Critique of Pure Reason, 1781, 第2版 1787)</li><li>《未来形而上学导论》(Prolegomena to Any Future Metaphysics, 1783)</li><li>《道德形而上学原理》(Groundwork of the Metaphysics of Morals, 1785)</li><li>《实践理性批判》(Critique of Practical Reason, 1788)</li><li>《判断力批判》(Critique of Judgement) Pure Reason, 1790)</li><li>《单在理性范围内的宗教》(Religion within the Limits of Reason Alone, 1793) </li><li>〈永久和平论〉(“Perpetual Peace”, 1795)</li></ul><h3 id="康德哲学的定位"><a href="#康德哲学的定位" class="headerlink" title="康德哲学的定位"></a>康德哲学的定位</h3><blockquote><p>一般定位：启蒙运动的哲学代表，理性主义与经验主义的集大定者。</p></blockquote><ul><li>理性主义的立场：<ul><li>心灵拥有天赋观念 (innate ideas)。</li><li>只需以理性分析与思想相关的观念，我们便可掌握世界之真相(至少关于最重大议题之真相，例如灵魂是否不朽，上帝是否存在，意志是否自由等等)。</li><li>以数学、逻辑为知识典范</li><li>代表人物: Descartes, Spinoza, Leibniz</li></ul></li><li>经验主义的立场：<ul><li>并无所谓天赋观念，一切观念皆经由经验习得，人的心灵是生而如「白纸」(tabula rasa)，不存在先有的蓝图、内容或架构。</li><li>一切知识，皆来自经验；知识之建立有赖于有方法地对自然进行考察。</li><li>以自然科学为知识典范</li><li>代表人物： Locke, Berkeley, Hume</li></ul></li></ul><h3 id="批判（康德）"><a href="#批判（康德）" class="headerlink" title="批判（康德）"></a><strong>批判（康德）</strong></h3><ul><li><p>康德的批判是指：根据理性具有普遍必然的科学知识对理性的一般认识能力进行分析，通过分析来确立一种衡量知识是否科学知识的一般标准，然后以此来衡量形而上学的命运。在当时，批判的含义首先是针对莱布尼兹-沃尔夫体系提出的，其次，它还要通过对不依赖经验因素的纯粹理性的批判，为数学、自然科学提供哲学论证，同时又限制理性的活动范围，为宗教信仰保留地盘。</p></li><li><p>（PPT）所谓「批判」不是指单纯的「批评」(criticism)，而是指：</p><ul><li>(1) 限制、划定界限论域的有效范围；</li><li>(2) 有别于对论域有效性的「朴素」(naively)接受，对其进行反思，阐释其构成原则。</li></ul></li></ul><h3 id="判断上的线索"><a href="#判断上的线索" class="headerlink" title="判断上的线索"></a>判断上的线索</h3><ul><li>给定了完整具体的经验是命题性的，那么，表达命题的判断即可成为探索经验超验条件的线索，包括：先验综合判断的线索<ul><li>综合判断 vs. 分析判断 (主谓概念的分析与非分析的关系──「清华大学男多女少」vs. 「三角形有三只角」)</li><li>经验综命判断 vs. 先验综合判断</li><li>先验综合判断的例子：「两点之间最短者为直线」、「凡变化均有原因」</li></ul></li><li>非经验字词的线索 (例如「有些」、「和」、「或者」)</li><li>判断逻辑形式的线索 ( “S is  P” 的量、质、模态与关系的可能变化)</li></ul><h4 id="简述康德的“先天综合判断”理论。"><a href="#简述康德的“先天综合判断”理论。" class="headerlink" title="简述康德的“先天综合判断”理论。"></a>简述康德的“先天综合判断”理论。</h4><ul><li>康德为了解决经验知识的普遍必然性问题而提出了“先天综合判断”理论。康德认为，知识的基本单位是判断，一种是分析判断，一种是综合判断。分析判断的宾词蕴含在主词当中，具有普遍必然性，但不能给我们提供新的知识，经验知识属于综合判断，宾词不包含在主词中。具有普遍必然性的经验知识必有两个来源：感官提供的后天质料和头脑中固有的先天认识形式。具有这种特征的判断称为先天综合判断。先天综合判断的命题可以分为三类：数学命题、自然科学命题、形而上学命题。</li></ul><h3 id="超越"><a href="#超越" class="headerlink" title="超越"></a>超越</h3><ul><li>「超越」与「经验」相对，指关于经验可能性的先验条件(超越哲学即关于这些条件之严格学问)。</li></ul><h3 id="康德的哥白尼转向"><a href="#康德的哥白尼转向" class="headerlink" title="康德的哥白尼转向"></a>康德的哥白尼转向</h3><ul><li>自然科学的哥白尼革命：从地心说转向日心说。</li><li>康德哲学的哥白尼革命：从表象实在论 (representational realism) 到转移超验论 (transcendentalism)<ul><li>表象实在论：认知主体受客体影响而产生表象，进而产生对象性知识 (观念)。</li><li>超验论：客体是因为经受主体先行的安排与整顿，方能树立为对象性，故此对象依赖于主体的经验与思维方式。</li></ul></li></ul><h3 id="康德-VS-休谟"><a href="#康德-VS-休谟" class="headerlink" title="康德 VS 休谟"></a>康德 VS 休谟</h3><ul><li>休姆的正确洞见：知识起源于经验，而单是感性经验的管道本身无法提供「必然而普遍有效东西」；诉诸个殊感性所接收的内容无法说明因果性。</li><li>休姆的错谬：因为感性经验管道无法说明因果的来源，故此因果性无客观有效性，只是主观的心理习惯。</li><li>休姆的假设：经验只是零散的、无秩序的材料之累积和收集而已。</li><li>康德：经验一旦发生，便总已具有普遍有效的秩序；经验是「命题性」的。(我们的知觉经验所相对的是事物、对象，以至整全的事态，而并非在一堆零散的「杂多讯息」之堆积。)</li></ul><h3 id="超越的三性"><a href="#超越的三性" class="headerlink" title="超越的三性"></a>超越的三性</h3><blockquote><p>康德的超越论的设定：这些既存于经验的秩序是由认知主体的不同机能所赋予，这些机能包括：(1) 感性 (sensibility)；(2) 知性 (understanding)；(3) 理性 (reason)。</p></blockquote><h4 id="感性（康德）"><a href="#感性（康德）" class="headerlink" title="感性（康德）"></a><strong>感性（康德）</strong></h4><ul><li>感性是指主体自我借助于感性经验而形成的感性直观知识的先天认识能力，包括两个方面，一是经验直观，一是纯直观。前者是后天的质料，后者是先天的形式。感性的先天形式是空间和时间，感性与感觉经验结合后形成数学知识。</li></ul><h4 id="知性（康德）"><a href="#知性（康德）" class="headerlink" title="知性（康德）"></a><strong>知性（康德）</strong></h4><ul><li>知性是指主体自我对感性对象进行思维，把特殊、没有联系的感性对象加以综合，并且联结成为有规律的自然科学知识的先天认识能力。知性的先天认识形式是知性纯概念，即“范畴”。用这些范畴把感性知识结合起来，使其具有一定的形式，成为知识。知性与感觉经验结合形成自然科学知识。</li></ul><h4 id="理性（康德）"><a href="#理性（康德）" class="headerlink" title="理性（康德）"></a><strong>理性（康德）</strong></h4><ul><li>理性指在经验中无法达到的知识的完备性和无条件性，即要求认识世界、灵魂和上帝的认识能力。理性是认识的最高阶段，要求认识自在之物本身，获得关于世界的绝对认识，即理念。但是理性自身没有先天形式，只能借用知性范畴。但用认识有限对象的知性范畴去把握无限对象，理性必然陷入不可解决的矛盾，因此形而上学是不可能的。</li></ul><h3 id="超越的演绎"><a href="#超越的演绎" class="headerlink" title="超越的演绎"></a>超越的演绎</h3><ul><li>「超越的演绎」(transcendental deduction) 的目标是透过阐明感性的直观形式和知性的先验范畴构成对象性经验的程序，显示这些先验条件的有效性。这个程序涉及三个层次的综合：<ul><li>a)    直观之统握 (Apprehension in der Anschauung; Apprehension in the Intuition)：初步赋予感性摄取回来的杂多资料一个时空秩序的形式，如时间上的共时与相续。</li><li>b)    想象力的再造 (Reproduktion in der Einbildung; Reproduction in the Imagination)：将直观逐一经历者重新呈现，并使之合成为一个统一的「意象」。</li><li>c)    知性概念之重认 (Rekognition im Begriff; Recognition in the Concept)：依据先验概念，将已被直观统握和想象力再造的杂多，确认之为某物的表象。</li></ul></li></ul><blockquote><p>超越演绎描述的是一个互相协调下的广义思考活动，背后统一的思考者即某个超越的、形式性的、主动的「我」(I)，称为超越统觉 (transcendental apperception)。康德认为，正因为我的所有经验皆过此超越的我之统觉思考，故「我思」总是能够伴随着一切我的表象的。</p></blockquote><h3 id="知识的消极批判：有效知识的限度"><a href="#知识的消极批判：有效知识的限度" class="headerlink" title="知识的消极批判：有效知识的限度"></a>知识的消极批判：有效知识的限度</h3><ul><li>现象学 (phenomenon) 与物自身 (thing in itself) (或「智思物」(noumenon))的区分。</li><li>具体判准：现象为知性(概念)与感性(直观)协作而成；任何无法感性直观给予的对象，我们对之皆无法建立积极的知识。</li><li>二律背反(antinomy)及独断形上学的谬误。例如「世界是有限/无限」；「自然因果性以外还有自由的因果性/ 自然因果性通贯决定一切」。</li></ul><h4 id="二律背反-antinomy"><a href="#二律背反-antinomy" class="headerlink" title="二律背反 (antinomy)"></a>二律背反 (antinomy)</h4><ul><li>显示独断的形上学是不一致的，因为它们涉及一些超出感性经验以外的事情。</li><li>二律背反的积极价值：时空实在只是现象，自由即使不容于现象，也不代表它不能是某种实在。</li></ul><h4 id="经验的实在论-empirical-realism"><a href="#经验的实在论-empirical-realism" class="headerlink" title="经验的实在论 (empirical realism)"></a>经验的实在论 (empirical realism)</h4><ul><li><p>：对于可直观呈现的经验对象来说，时空、范畴等先验条件皆为构成「实在」的一环。</p><h4 id="超越的观念论-transcendental-idealism"><a href="#超越的观念论-transcendental-idealism" class="headerlink" title="超越的观念论 (transcendental idealism)"></a>超越的观念论 (transcendental idealism)</h4></li><li><p>对于无法直观的、超离于感性经验以外的事物来说，时空、范畴等不过是观念 (一些虚的想法)，我们无法针对它们建立积极的知识。</p></li></ul><h3 id="伦理学"><a href="#伦理学" class="headerlink" title="伦理学"></a>伦理学</h3><h4 id="理性主义-VS-经验主义"><a href="#理性主义-VS-经验主义" class="headerlink" title="理性主义 VS 经验主义"></a>理性主义 VS 经验主义</h4><ul><li>理性主义：有些根本的道德观念和原则是天赋或先验的，我们可透过理性反省来掌握它们──就如我们可以透过理性反省我们的推理行为，而获得一些先验而普遍有效的逻辑观念与逻辑原则。</li><li>经验主义反之认为，道德只是偶然的人性与欲望的产物，例如Hume 认为，道德是基于同情共感 (同情心)，而同情心是人性偶然的产物，若人性不同，人便可能有不同的欲望与感情，由此也会有不同的道德原则。道德原则只是偶然的经验原则，而理性只是满足欲望与情感的手段。(理性是也应是情感的奴隶！)</li></ul><h4 id="康德伦理学立场"><a href="#康德伦理学立场" class="headerlink" title="康德伦理学立场"></a>康德伦理学立场</h4><ul><li>道德之基础是理性而非偶然的人性欲望与情感，道德原则是必然而非偶然的。否则无法解释道德的特殊规范力：它对所有理性存在者之行为皆普遍有效。(我们不但要求人应当公正、诚实、尊重他人、保护弱者，等等，而是任何有理性者皆当如此！)</li><li>当然，道德也需实践，但要策动实践道德原则之行为，我们所依赖的不是偶然的欲望，而是理性的意志。</li><li>针对道德领域，超验哲学的反思要阐明的是：纯粹理性自身如何可能是实践的。</li></ul><h4 id="实践理性与道德原则"><a href="#实践理性与道德原则" class="headerlink" title="实践理性与道德原则"></a>实践理性与道德原则</h4><blockquote><p>对于康德来说，人类实践之理性表现在于它是在法则意识下的行动。(依法则行动 vs. 依法则表象而行动)<br>有限实践理性与道德规范力或强制力：义务 (Duty, Pflicht) 的优先性。</p></blockquote><ul><li>令式与两种应该：<ul><li>假言令式</li><li><ul><li>如果要减肥，你就不应该在晚上吃很多。</li></ul></li><li>定言令式</li><li><ul><li>不应该滥杀无辜。</li></ul></li></ul></li></ul><blockquote><p>康德认为，真实的道德是为道德而道德，或为义务而义务，故其相应的令式为定言令式。</p></blockquote><h4 id="道德原则即为可普遍化原则"><a href="#道德原则即为可普遍化原则" class="headerlink" title="道德原则即为可普遍化原则"></a>道德原则即为可普遍化原则</h4><ul><li>康德认为是有的，他同样也称之为定然令式(狭义)。</li><li>康德对之有几组不同的表述，其中一组强调普遍化，为了辨识之故，我们可以称之为「普遍化原则」(Principle of Universalization)：</li><li>「仅据如此格准 (maxim) 行动，即你能同时意愿之成为普遍遍法则。」</li><li>(「格准」是康德的术语，意指主观的行动原则。)</li><li><p>「可普遍化」这个判准告诉我们甚么可以做(道德上容许的)，甚么不可以做。</p></li><li><p>栗子：</p><ul><li>许假承诺（自我矛盾，因为之所以许诺就是为了未来能够达成）</li><li>即使有能力，也不要帮助他人（意志上的矛盾）</li></ul></li></ul><h4 id="普遍化原则所表达的道德观念"><a href="#普遍化原则所表达的道德观念" class="headerlink" title="普遍化原则所表达的道德观念"></a>普遍化原则所表达的道德观念</h4><ul><li>道德上对的行为，即某意义上合理的行为。</li><li>理性的特征是普遍的，在道德上合理，即行为在某意义上是可以普遍化的。</li><li>为此，我们要检讨某个行为是否道德上正确与否，便应建立一套程序，显示如何可在普遍的观点下考察该行为，并尝试阐明，符合什么特征时，该行为才是合理的。</li><li>检测流程：<ul><li>第一阶段：主观原则（陈述行动背后的标准）</li><li><ul><li>栗子：每当我需要的时候，我就许假承诺。</li></ul></li><li>第二阶段：陈述行动的客观原则</li><li><ul><li>栗子：每当任何人有需要的时候他们都许假承诺。</li></ul></li><li>第三阶段：按能否普遍化或其它标准，判定行动在道德上是否允许。</li></ul></li></ul><h4 id="对普遍化原则的批判"><a href="#对普遍化原则的批判" class="headerlink" title="对普遍化原则的批判"></a>对普遍化原则的批判</h4><ul><li>Anscombe 的反驳 ：只要加上恰当的条件，说谎便可容许，例如，「若旨在拯救无辜，说谎也无妨」以乎可以普遍化。</li><li>回应：我们无法肯定知道行动的结果──例如以为说谎可救忠良，免其受暴政追捕，但却有可能阴差阳错，导致无辜者陷入罗网──，但却肯定知道行动有无违反义务。故此，我们理当行其义不计其功，避免因任何后果计算，违反已知的道德义务。康德认为，既行其义，我们便以尽了自己的责任，致于行动后果是否美好，也不是我们的过错。(因为此点其实我们无法肯定的)。</li><li>Rachels 的反驳：康德认为，我们须为说谎行为的坏结果负责(例如误让无辜者被捕)，但却不需要为说真话的坏后果负责？──这并不合理。</li></ul><h4 id="三个表达式"><a href="#三个表达式" class="headerlink" title="三个表达式"></a>三个表达式</h4><ul><li>自然法则原则 (Principle of the Law of Nature)：「如此行动，宛如藉由你的意志，你的行动格准变成普遍的自然法则。」</li><li>目的原则 (Principle of Ends)：「如此行动，致使无论是在你自身人格中的或是其他人的人格中的人性，皆被当作目的而非仅当作手段 (means) 看待。」</li><li>自律原则 (Principle of Autonomy)：「如此行动，致使你的意志藉由自身的格准，能够同时自视为在制订普遍法则。」</li></ul><h4 id="道德行动的预设"><a href="#道德行动的预设" class="headerlink" title="道德行动的预设"></a>道德行动的预设</h4><blockquote><p>道德行动有三个设准 (预设)(postulate)，这些设准之实在性不能被证明，但却对实践生活极为重要：</p></blockquote><ul><li>自由意志：「意志独立于任何东西，而仅仅遵从道德法则」→ 自由意志是「拱心石」。</li><li>灵魂不朽：实现 summum bonum 至善即德福一致的预设。</li><li>上帝：实现 summum bonum 至善即德福一致的预设。</li></ul><h3 id="美学"><a href="#美学" class="headerlink" title="美学"></a>美学</h3><h4 id="审美与反思判断"><a href="#审美与反思判断" class="headerlink" title="审美与反思判断"></a>审美与反思判断</h4><ul><li>审美能力依于判断能力 (power of judgment)</li><li>判断能力的一般性格：将个殊 (particular) 隶归到普遍 (universal)</li><li>判断力有两种：<ul><li>决定式判断力 （determinant judgment）：先有「普遍」，再将它应用到特殊之上。</li><li>反思式判断力（reflective judgment）：先面对特殊各物，而找一些普遍原理来涵盖。</li></ul></li><li>反思式判断力的特点：<ul><li>愉悦感：发现规律去涵盖纷杂现象时，自然会产生。</li><li>自然的合目的性：寻找普遍律，即预设有「律」可寻找，而假定自然界具有某种规律或是事先设计的秩序一样。</li></ul></li></ul><h4 id="审美判断的特点"><a href="#审美判断的特点" class="headerlink" title="审美判断的特点"></a>审美判断的特点</h4><ul><li>康德把「审美判断」包含在「反思判断」中。他没有明确解释原因，但主要有三个要点可说：<br>美的欣赏一样要面对一些杂多的现象，并加以反省或观照。<ul><li>一样涉及「合目的性」这个原则，虽然于此是所谓「主观的合目的性」。</li><li>会涉及「某种快感」，而且感受就是判断的基础。</li></ul></li></ul><blockquote><p>我们说某物为「美」时，我们往往虽只诉诸我们对该物的感受，但仿佛又将「美」当作事物昭明的客观性质，要求每个(有品味的)人皆能辨察。以康德的术语说：审美判断具普遍有效性(universal validity)，它们具有某种「必然性」(necessity)或在某程度上是「先验的」(a priori)。</p></blockquote><h4 id="判断力批判的任务"><a href="#判断力批判的任务" class="headerlink" title="判断力批判的任务"></a>判断力批判的任务</h4><ul><li>笼统来说，《判断力批判》(Critique of Judgment) 的主要任务对人的判断能力作超越的分析，以阐明「审美判断」与「目的论判断」是如何可能。</li><li>就美学而言，《判断力批判》要说明的是：单纯依主观的基础(审美的愉悦感)而判定某物为美，但同时要求此判断被普遍认同──这如何可能？</li><li>美感缘何能够成普遍有效性的基础？</li></ul><h4 id="审美判断力的分析"><a href="#审美判断力的分析" class="headerlink" title="审美判断力的分析"></a>审美判断力的分析</h4><ul><li>品味判断：<ul><li>性质 (Quality)</li><li>数量 (Quantity)</li><li>目的关联 (Relation of the Purpose)</li><li>模式/模态 (Modality)</li></ul></li></ul><h5 id="美的性质"><a href="#美的性质" class="headerlink" title="美的性质"></a>美的性质</h5><ul><li>就性质而言，「美」是一种愉悦的感受，而审美判断则相应是主观的，其基础消极来说不在于对事物的概念性的知识，而是在单纯的观看 (contemplation) 中得感受到的愉悦或不愉悦感。(康德认为实践上的好坏是概念性，审美上的美丑则不然)。</li><li>纯粹的审美判断必须是无「利害关心」的 (disinterested)，我们审美时不但悬搁我们的知识兴趣、欲求与道德意愿，我们甚至不关心对象是否实存。(因此美食往往不是纯粹的美，美色亦然。)</li></ul><blockquote><p> 在质上，康德的总结性论断如下：「鉴赏力/品味能力是通过不带任何利害的(without interest)愉悦或不悦而对一个对象或一个对象的表象方式作评判的能力。一个这样的愉悦的对象就叫做美的」。</p></blockquote><h5 id="审美判断的量"><a href="#审美判断的量" class="headerlink" title="审美判断的量"></a>审美判断的量</h5><ul><li>康德就「量」方面的主要论断是:「凡是那单个没有概念而普遍令人喜欢的东西就是美的」。因为审美愉悦完全脱离于个人的个别需要和欲望，所以它具有某种独特的普遍性。单个：在对象的量上，审美判断和关于感官快适的判断一样，严格而言都是针对眼前某个个殊东西的判断。(「这朵玫瑰是漂亮的」；「这块蛋糕很好吃」)</li><li>无概念而普遍：但两者有一点关键的不同：在判断感官快适时，我根本上就我个人而言而下判断的(例如别人可以认为这块蛋糕太甜或太淡或太多奶油而不爱吃的)，反之，判断对象美与不美时，主体却不是单为了他本人，也同时是为所有人下判断的。</li><li>基于概念而产生，事实上，康德认，纯粹审美判断全部的如上所说，审美主体要求所有人都认同他的判断，但这种普遍性不是「客观关涉」都只是仅在于眼前这个不能被概念化的、独一无二的现象。</li></ul><h5 id="审美判断的关系"><a href="#审美判断的关系" class="headerlink" title="审美判断的关系"></a>审美判断的关系</h5><ul><li>关系: 「美是一个对象的合目的性之形式，如果这形式是没有一个目的的表象而在对象身上被知觉到的话」。<br>审美判断是以美感为基础，而美感是一种快感。然而快感之所以产生，当中应涉及某种「适然的」状况：应该是由于审美对象在某个意义下对我是「适然的」，故此我才会感到愉悦。可是上述分析已指明，审美快感并非出于满足于我的某种特殊的感性欲望或理性欲望，那么它是之所适是适于什么东西？<br>康德认为，既然美感是单纯因为观照而产生，那么美感之所适便是适于人的知觉，故此单从品鉴审美对象，便能产生审美的愉悦。用现代的术语来表达审美愉悦的基础可说并不在于知觉对象的某些实存的性质，而是在于审美知觉活动 (perceptual activity) 本身的特殊方式。﹝犹如游戏的愉悦不在于其对象，而是由游戏活动本身一般。﹞</li></ul><h5 id="审美判断的模态"><a href="#审美判断的模态" class="headerlink" title="审美判断的模态"></a>审美判断的模态</h5><ul><li>模态:「那没有概念而被认作一个必然愉悦的对象的东西就是美的」。</li><li>审美判断判定某物必然带来美感的愉悦，但这种必然性之基础不在于某种依于概念上的推证的必然 (apodeictic 的必然性，而是exemplary (展示某不可明示的规则) 。</li><li>康德以为，审美判断的主观普遍性的基础，最终在于共通感 (sensus communis。</li><li>审美判断的第四个特点是其「模态」上的必然性：品味判断基于审美愉悦感，康德的分析将这愉悦感归因于审美主体内部的超验认知能力之和谐游戏，因此，审美判断所隐含的普遍有效的宣称便有一先验的基础。此先验基础使对象的美感有着某种「必然性」(每个人皆应该认同我的判断，皆应该感到此对象之美)，但这种必然性不是按照明确规定的法则而树立，而只是「主观的」或「典范性」(exemplary) 的。</li><li>康德说，这里的「典范性」是指「所有人皆须同意某个判断的必然性，此判断是被视作某个我们无法表明的普遍法则之范例」。</li></ul><h2 id="德国观念论"><a href="#德国观念论" class="headerlink" title="德国观念论"></a>德国观念论</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>德国观念论是德国后康德时期哲学的主流，在18世纪末、19世纪初盛行。以批判地承接康德为特征，与启蒙运动 (the Enlightenment) 及浪漫主义 (Romanticism)，密切关系。</li></ul><h3 id="代表人物"><a href="#代表人物" class="headerlink" title="代表人物"></a>代表人物</h3><ul><li>德国观念论主要有三家，按其照跃时候，费希特 (Johann Gottlieb Fichte)、谢林(Friedrich Schelling)及黑格尔 (Georg Wilhelm Friedrich Hegel)。</li></ul><h2 id="费希特"><a href="#费希特" class="headerlink" title="费希特"></a>费希特</h2><h3 id="著作-2"><a href="#著作-2" class="headerlink" title="著作"></a>著作</h3><ul><li>《试论一切天启之批判》(Versuch einer Kritik aller Offenbarung)</li><li>《全体知识学之基础》(Grundlage der gesamten Wissenschaftslehre)</li><li>《自然权之基础》(Grundlage der Naturrechts) </li><li>《伦理学体系》(Das System der Sittenlehre)</li></ul><h3 id="费希特-VS-康德"><a href="#费希特-VS-康德" class="headerlink" title="费希特 VS 康德"></a>费希特 VS 康德</h3><ul><li>自认承接和「忠于」发展康德学说，认为康德哲学有<strong>两个漏洞或不足</strong>：<ul><li>物自身的假设 (独断论 (dogmatism) 的假定)</li><li>理论理性与实践理性之分离</li></ul></li><li>费希等眼中，康德的基本洞见为：实践理性至于理论理性之优先地位；自由为理性的事实。</li><li><p>舍弃「物自身」(Ding an sich) 概念，而由「我自身」(Ich an sich) 为绝对基点出发，建立一元的主观观念论 (subjective Idealism)</p></li><li><p>费希特的基本进路：</p><ul><li>消除独断论，建立彻底的观念论。</li><li>以绝对自我为始点的主观观念论，整合理论理性与实践理性(两者为同一自我的两种表现)。</li></ul></li><li><p>我自身 (绝对自我) 为始的存在模式：</p><ul><li>消极：自我  物、客体、对象、实体。</li><li>积极：自我在于「活动」、「行动」(Handlung)；其为「即活动即存在」，「事行合一」(费希特称之为 Tathandlung) 。</li></ul></li><li><p>独断论与观念论争议无法在理论上终极解决──它是「倾向与关心」之争：「最高的关必或即其他关心的根据，乃是对我们自己的关心。哲学家的情形亦然。」「一个人选择何种哲学，端看他是那一种人。」</p></li></ul><h3 id="知识学"><a href="#知识学" class="headerlink" title="知识学"></a>知识学</h3><blockquote><p>主观观念论以自我之事行为根本原理，演绎其他一切。</p></blockquote><h4 id="自我（费希特）"><a href="#自我（费希特）" class="headerlink" title="自我（费希特）"></a>自我（费希特）</h4><ul><li>费希特反对康德通过设定自在之物为经验寻找依据，而认为全部经验的根据就是“自我”。“自我”查知经验客体而不依赖于经验客体，自我通过主体的自我反省建立起来，通过绝对自我的理智觉察主体的存在。自我没有规定，没有限制，没有间接认识，是一种直觉。</li><li>（PPT）费希特所谓的「自我」，乃绝对自我 (das absolute Ich)，而并非经验心理学意味的个别的人。绝对自我乃康德的超验统觉，并揉合笛卡儿的「我思、我在」，去掉后者的实在论假定之形上学化概念。(「我在」是第一序的，而我思则被理解为超验的、建构性的思想)</li></ul><h4 id="三个建立客体知识的原则"><a href="#三个建立客体知识的原则" class="headerlink" title="三个建立客体知识的原则"></a>三个建立客体知识的原则</h4><ol><li>第一原理：</li></ol><ul><li>自我设定自身：所谓「设定」(setzen, posit) 是指在意识中确立起来。自我设定自身即意识中确立自己的存在。对应于 “A = A” 的命题，为绝对无条件的原理。</li></ul><ol><li>第二原理：</li></ol><ul><li>自我设定非我。费希特认为此对应 “~A ≠ A” 的命题，由于否定性 (「不是」)并非衍生自肯定性(「是」)，故此设定非我的事行也是一形式本原的行动，只有<br>内容上有预设 (非我以「我」为前提)。</li></ul><ol><li>第三原理：</li></ol><ul><li>自我在自身中设定一个可分(割)的非我与可分(割)的自我相对立。</li></ul><ol><li>第三原理以先行两个原理为基：</li></ol><ul><li>非我是自我的否定，但因为我是建构性的，也是非我的设定者、没有自我就没有非我。(非我既不是我，但又是我)</li><li>于是在一定程度，我与非我、A与~A、实在与否定虽要结合起来。</li><li>第一原理中的自我是无条件的绝对自我；第二原理中的自我是受非我限制、与之对立的有条件自我。故第三原理所表达的是：有条件的自我与有条件的非我相对立，但两者皆从属于绝对的自我。</li><li>费希特认为，第三原理即知识的最高的综合 (以绝对自我综合主客关系)。</li></ul><h2 id="谢林"><a href="#谢林" class="headerlink" title="谢林"></a>谢林</h2><h3 id="著作-3"><a href="#著作-3" class="headerlink" title="著作"></a>著作</h3><ul><li>《超验观念论体系》(System des transcendentalen Idealismus, 1800)</li><li>《哲学与宗教》</li></ul><h3 id="自然学说"><a href="#自然学说" class="headerlink" title="自然学说"></a>自然学说</h3><ul><li>自然哲学中的自然：并非自我设定的对象(非我)、整体、内在的动力结构与普遍原理，自然之为自然的条件。</li><li>自然哲学 = 思辨物理学 (speculative physics)。</li><li>自然并非与意识、理智对立，它不过是暗哑和尚未成熟的理智。(谢林的构想与唯物刚巧相反：把自然还原为初阶的精、理智。)</li><li>自然哲学即旨在显示，自然发展如何使得主体渐渐出现，并勾勒从「质料」、「无机物」到「有机物」至最终出现精神的过程。</li><li>这个发展的逻辑，谢林以「对立统一」表释之。</li></ul><h3 id="对立统一的例子"><a href="#对立统一的例子" class="headerlink" title="对立统一的例子"></a>对立统一的例子</h3><ol><li>质料层次：引力与斥力。引力表现客观、物质、自然；斥力表现为主观、自我、精神性。二种力物质和精神的共同基础，引力把外在世界的运动变化凝聚到内在的感觉世界，构成我们的内部经验，谢林以之配对时间的先验基础；斥力则是向外在世动，构成外部经验，是空间的先验基础。</li><li>二元对立和统一推动着无机领域向有机领域的转化。谢林以为电、磁现象即此转化的关系。自然哲学中的自然：并非自我设定的对象(非我)、整体、内在的动力结构与普遍原理，自然之为自然的条件。</li></ol><h3 id="同一性哲学"><a href="#同一性哲学" class="headerlink" title="同一性哲学"></a>同一性哲学</h3><ul><li>谢林是以费希特为始点而发展出自己的思想道路的：</li></ul><ol><li>预备时期 (1797)：完备费希特的「知识学」而发展自然哲学(自然哲学作为超验哲学的一个补充部份)</li></ol><ul><li>第1期 (1799)：以「自然哲学」冠名自己的思想，以之与康德的批判哲学及费希特的知识学相对比。</li><li>第2期 (1800)：发表《超验观念论体系》，并举自然哲学与超验哲学两部份，合构成「同一性哲学」。</li><li>同一性哲学的观念：知识学的最高原理 = 自我 = 主观的主客合一、自然哲学：客观的主客合一。完全从绝对本原出发：主客绝对的同一 (尚未分离意义的同一)。</li></ul><h3 id="（立场）费希特-VS-谢林"><a href="#（立场）费希特-VS-谢林" class="headerlink" title="（立场）费希特 VS 谢林"></a>（立场）费希特 VS 谢林</h3><ul><li>相同点是克服康德的超验哲学的主客体分离的二元框架，贯彻观念论的立场，质疑越出建构性主体以外的「物自身」的设定。<ul><li>费希特：以主体收摄客体，客体只是主体以内所确立的「非我」。</li><li>前期谢林：以自然哲学 (把主体视作自然本身的发展的目标) 补足费希特的主体观念论 (把客体视作主体的观念)。</li><li>后期谢林：追溯前于主客体区分的「绝对者」、「同一者」，其表征及掌握超出概念思维以外，或诉诸艺术直观，或诉诸宗教体验。</li></ul></li><li>费希特可说是超验哲学化的笛卡儿主义，而谢林则是超验哲学化的史宾诺莎主义。</li></ul><h2 id="黑格尔"><a href="#黑格尔" class="headerlink" title="黑格尔"></a>黑格尔</h2><h3 id="著作-4"><a href="#著作-4" class="headerlink" title="著作"></a>著作</h3><ul><li>【处女作】《论费希特与谢林哲学体系的差异》(1801)</li><li>【生前出版（书）】《精神现象学》(The Phenomenology of Mind)</li><li>【生前出版（书）】《逻辑学》(Science of Logic)</li><li>【生前出版（教材或讲义）】《哲学全书纲要》(Encylopedia of the Philosophical Sciences in Outline)</li><li>【生前出版（教材或讲义）】《自然法与政治学纲要·法哲学原理》(Natural Law and Politics in Outline. The Principles of the Philosophy of Right)</li><li>柏林时代的遗稿：（整理的课堂笔记）<ul><li>《历史哲学》</li><li>《美学》</li><li>《宗教哲学》</li><li>《哲学史》</li></ul></li></ul><h3 id="思想特点"><a href="#思想特点" class="headerlink" title="思想特点"></a>思想特点</h3><ul><li>古典基础：<ul><li>(1) 存在与思维合一的构想 (Parmenides, Plato)；</li><li>(2) 概念或观念的存在论意味 (Plato, Aristotle) </li></ul></li><li>近代基础：康德至费希特、谢林一脉的德国观念论发展。</li><li>注重哲学思想及其课题的历史性与社会文化脉络 (“philosophy is its own time apprehended in thoughts“)。</li><li>有别于谢林只追溯(超验)哲学的前历史，黑格尔也描述其后续的历史发展之逻辑与目的<br>以辩证法取代演绎法，以之为：(1) 哲学方法；(2) 存在本身的逻辑</li></ul><h3 id="康德基础上的黑格尔"><a href="#康德基础上的黑格尔" class="headerlink" title="康德基础上的黑格尔"></a>康德基础上的黑格尔</h3><ul><li>就如其他德国观念论者一样，黑格尔也是以康德的超验哲学中的主客对立(我与物自身的分离)为思考的始点：物自身意味，知识与对象有「差距」：<ul><li>(1) 要么是指经验意义或一般；</li><li>(2) 要么是指超验的意义 (康德的问题, transcendental gap)</li></ul></li><li><p>若 (1) ，则只涉及知识(思想)调节，务求思想与现实吻合的问题。但若 (2)，则黑格尔认为，同样理应调节思想，以便吻合于现实，形成超验知识。只是问题是：此时的思想是超验的、建构性的思想。故此……</p></li><li><p>调节思想便同时意味以新的形式建构它的客体 (产生新的transz. gap)，原来的物自身(「自在之物」)变成对象，但同时又产生新的「自在之物」</p></li><li><p>思想 – 知识 – 对象 – 自在物 乃一串连动的环节，调节一者则整系列皆有改变。</p></li><li><p>例子：《精神现象学》的感性确定</p></li><li>结论：<ul><li>(1)知识与对象间的落差会推动知识自身的发展，但对象与自在物也同时会变化；</li><li>(2) 调节思想以与实在一致，此历程称为辩证法。</li></ul></li></ul><h3 id="辩证法-Dialectics"><a href="#辩证法-Dialectics" class="headerlink" title="辩证法 (Dialectics)"></a>辩证法 (Dialectics)</h3><ul><li>原意：对话，即人际的现象→ </li><li>哲学转化 (柏拉图苏格拉底传统)：心灵的自我对话，以趋向真理的表述 (定义)的历史</li><li>黑格尔的转化：D. = 主体思想与客观实在的共同规定。</li></ul><h3 id="辩证法的历史"><a href="#辩证法的历史" class="headerlink" title="辩证法的历史"></a>辩证法的历史</h3><ul><li>古典的辩证法：<ul><li>(1) Heraclitus的自然辩证法；</li><li>(2) Zeno 的论辩的辩证法；</li><li>(3) Socrates的对话的辩证法。</li></ul></li><li>近代的辩证法：康德的消极的理性辩证法 (二律背反)</li></ul><h3 id="辩证法的层次"><a href="#辩证法的层次" class="headerlink" title="辩证法的层次"></a>辩证法的层次</h3><ul><li>哲学思想与心理学层次：D. = 思想/认识的发展逻辑 (如正题、反题、合题)</li><li>存在论层次：D. = 思想(观念)</li><li>与实在融合的过程：一方面，实在观念化、思想化；另一方面则是思想的实在化。最终达致，思维与存在合一，「凡是现实均为合理，是合理的均为现实」</li><li>宇宙论层次：为精神实体自身发展的逻辑，从目的处回头考察各个阶段的合理位置与意义 。《精神现象学》考察从最个殊具体(感性意识)至普遍(绝对精神)的辩证发展；《逻辑学》则考察从最普遍 (存在一般) 至最个殊的概念之辩证发展。</li></ul><h3 id="黑格尔的辩证法"><a href="#黑格尔的辩证法" class="headerlink" title="黑格尔的辩证法"></a>黑格尔的辩证法</h3><ul><li>辩证法的基本运动：否定性</li><li>但辩证的否定性是具体的否定性，不是虚无主义的抽象否定 (negation as negation of…)<br>辩证的否定，黑格尔以德语 “aufheben” (扬弃) 表述其特征，即<ul><li>(1) 否定、终止；</li><li>(2)保持；</li><li>(3) 提升；</li></ul></li></ul><h3 id="辩证法的例子"><a href="#辩证法的例子" class="headerlink" title="辩证法的例子"></a>辩证法的例子</h3><h4 id="例一：《逻辑学》的最初三个概念"><a href="#例一：《逻辑学》的最初三个概念" class="headerlink" title="例一：《逻辑学》的最初三个概念"></a>例一：《逻辑学》的最初三个概念</h4><ul><li>正题：存在 (Being)</li><li>反题：无 (Nothing)</li><li>合题：变化 (Becoming)</li><li>阶段之间不是逻辑蕴涵关系，而是某种思想的必然发展。</li></ul><h5 id="例二：《精神现象学》的主奴辩证"><a href="#例二：《精神现象学》的主奴辩证" class="headerlink" title="例二：《精神现象学》的主奴辩证"></a>例二：《精神现象学》的主奴辩证</h5><ul><li>自我意识须通过他人的自我意识而成为自身</li><li>阶段1：物化他人，显示只有自己是「主」(例如战争、暴力中以消灭他人为目的)。</li><li>阶段2：奴役他人 (留其命以事奉自己)，被「承认」的主体。</li><li>阶段3 ：主奴的依从地位颠倒</li><li>主人因为过于依赖奴隶，最终丧失自主的能力。</li><li>奴隶反因通过生产与制造，意识自己能够改造世界的独立主体能力。</li></ul><h3 id="辩证法的原文"><a href="#辩证法的原文" class="headerlink" title="辩证法的原文"></a>辩证法的原文</h3><ul><li><p>§ 130<br>Being is the indeterminate immediate; it is free from determinateness in relation to essence and also from any which it can possess within itself. This reflectionless being is being as it is immediately in its own self alone.</p></li><li><p>§ 131<br>Because it is indeterminate being, it lacks all quality; but in itself, the character of indeterminateness attaches to it only in contrast to what is determinate or qualitative. But determinate being stands in contrast to being in general, so that the very indeterminateness of the latter constitutes its quality. It will therefore be shown that the first being is in itself determinate, and therefore, secondly, that it passes over into determinate being — is determinate being — but that this latter as finite being sublates itself and passes over into the infinite relation of being to its own self, that is, thirdly, into being-for-self.</p></li><li><p>§ 132<br>Being, pure being, without any further determination. In its indeterminate immediacy it is equal only to itself. It is also not unequal relatively to an other; it has no diversity within itself nor any with a reference outwards. It would not be held fast in its purity if it contained any determination or content which could be distinguished in it or by which it could be distinguished from an other. It is pure indeterminateness and emptiness. There is nothing to be intuited in it, if one can speak here of intuiting; or, it is only this pure intuiting itself. Just as little is anything to be thought in it, or it is equally only this empty thinking. Being, the indeterminate immediate, is in fact nothing, and neither more nor less than nothing.</p></li><li><p>§ 133<br>Nothing, pure nothing: it is simply equality with itself, complete emptiness, absence of all determination and content — undifferentiatedness in itself. In so far as intuiting or thinking can be mentioned here, it counts as a distinction whether something or nothing is intuited or thought. To intuit or think nothing has, therefore, a meaning; both are distinguished and thus nothing is (exists) in our intuiting or thinking; or rather it is empty intuition and thought itself, and the same empty intuition or thought as pure being. Nothing is, therefore, the same determination, or rather absence of determination, and thus altogether the same as, pure being.</p></li><li><p>§ 134<br>Pure Being and pure nothing are, therefore, the same. What is the truth is neither being nor nothing, but that being — does not pass over but has passed over — into nothing, and nothing into being. But it is equally true that they are not undistinguished from each other, that, on the contrary, they are not the same, that they are absolutely distinct, and yet that they are unseparated and inseparable and that each immediately vanishes in its opposite. Their truth is therefore, this movement of the immediate vanishing of the one into the other: becoming, a movement in which both are distinguished, but by a difference which has equally immediately resolved itself.</p></li></ul><h2 id="三位哲学家的观念比较"><a href="#三位哲学家的观念比较" class="headerlink" title="三位哲学家的观念比较"></a>三位哲学家的观念比较</h2><h4 id="洛克"><a href="#洛克" class="headerlink" title="洛克"></a>洛克</h4><ul><li>表象实在论：实际有那么一个东西，然后心里才有这样的观念。</li></ul><h4 id="柏克莱-1"><a href="#柏克莱-1" class="headerlink" title="柏克莱"></a>柏克莱</h4><ul><li>存在即被感知</li></ul><h4 id="休谟"><a href="#休谟" class="headerlink" title="休谟"></a>休谟</h4><ul><li>既无物理实在，也无精神实体</li></ul><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="http://otn4ut2th.bkt.clouddn.com/studyhistory.png" alt="西方哲学史结构图"></p><p><img src="http://otn4ut2th.bkt.clouddn.com/studystudybloghistory.png" alt="此处输入图片的描述"></p><h2 id="考试题预测复习"><a href="#考试题预测复习" class="headerlink" title="考试题预测复习"></a>考试题预测复习</h2><h3 id="印象与观念（休谟）"><a href="#印象与观念（休谟）" class="headerlink" title="印象与观念（休谟）"></a>印象与观念（休谟）</h3><ul><li>休谟提出一个命题：“除了知觉，一切都是不可知的。”在论证这一命题时，休谟把感觉经验叫做知觉，认为知觉可分为印象和观念。进入心灵时，最强烈、最活泼的知觉是印象，包括感觉、情感和情绪；观念则是感觉、情感和情绪在思维和推理中的微弱的意象。印象又可分为感觉印象和反省印象两种，而感觉是观念和反省印象的基础，观念则是感觉印象的精神的表象。观念可分为复合观念和简单观念，复合观念则是简单观念的集合或复合。</li></ul><h3 id="观念联想（休谟）"><a href="#观念联想（休谟）" class="headerlink" title="观念联想（休谟）"></a>观念联想（休谟）</h3><ul><li>休谟把感觉经验统称为知觉，然后又把“知觉”分为“印象与观念”。观念区别于印象，是由于它们具有较低程度的“生动性和强烈性”。又因为一些观念以某种未经解释的方式，带着印象的生动性与强烈再现，或者，“产生”了他所谓的“反省印象”的“新印象”。因此，反省是从感觉派生的。一切事实（知觉）都从感觉派生，而感觉印象来源于不知道的原因。简单观念之区别于简单印象仅仅是由于它们比较缺乏生动性和强烈性。通过这种“观念联想”就形成了关系、情状和实体的复杂观念。</li></ul><h3 id="简述休谟的因果关系理论。（休谟）"><a href="#简述休谟的因果关系理论。（休谟）" class="headerlink" title="简述休谟的因果关系理论。（休谟）"></a>简述休谟的因果关系理论。（休谟）</h3><ul><li>休谟坚持人们只能在经验的范围内研究因果性的问题。他认为在经验中，我们关于因果关系的观念是从对象间的某种关系得来的。首先，人们看到两个对象之间的接近关系，因此只有在时间上和学问上接近的东西才能相互作用，其次，人们看到两个对象在时间上的先后关系，因先于果，果接续因，接近关系和接续关系是我们形成两个对象之间因果关系的必要条件，但还不能由此提出一个完善的因果性观念，即两个对象之间必须存在着必然的联系。这是因为，观念即对象总是特殊的、各别的。我们从经验中最多只能看到两个对象之间的接近或接续关系，但是，我们永远看不到它们中间有任何纽带”，即必然联系，看不到原因中存在着某种必然产生结果的能力。休谟认为，原因和结果是两个根本不同的东西，二者之间不可能存在什么必然的联系。人们之所以觉得因果之间有着必然联系，是因为这种观念是从对象的恒常会合中引出来的，是对象恒常会合在人心中形成的一种习惯。</li></ul><h3 id="休谟怀疑论思想述评。"><a href="#休谟怀疑论思想述评。" class="headerlink" title="休谟怀疑论思想述评。"></a>休谟怀疑论思想述评。</h3><ul><li>休谟认为人通过感性知觉只能知道经验中一些表面的个别的现象，超出这个范围的事物的性质、本质、内部联系等等都是不可知的。他拒绝回答知觉的起源问题。他说：“用什么论证可以证明，心灵的各种知觉，一定是由一些虽然与他的相似，但是与他们完全不同的外物引起的，而不能由心灵本身的能力，或者由某种我们更不知道的其它原因产生呢？对于这个问题，经验是没有什么话可说的，也必须完全保持沉默。在心灵前面主观的，除了知觉以外，是根本没有别的东西的，它绝不能经验到知觉与对象的联系。因此，我们假定这样一种联系，是没有任何根据性的。显然，休谟拒绝回答感性知觉是由物质还是由精神引起的问题，实质上是拒绝公开回答哲学的根本问题。</li><li>休谟称自己的不可知论为“温和的怀疑论”，休谟的怀疑论把人的认识和外部世界隔绝，根本怀疑外部世界的存在，完全否认认识世界的可能性。在哲学史上，休谟的这种观点称为不可知论。休谟的不可知论，不过是贝克莱的直接否定物质世界客观存在的另一说法而已。    休谟从不可知论出发，在事物的现象和本质之间建立了一条不可超越的鸿沟，否认人们能认识事物的内在因果联系和本质。他说：“结果和原因是完全不一样的，因此我们也就不能在原因中表现出结果来。”休谟否认客观因果性。</li></ul><h3 id="简述费希特知识学的三条基本原理。"><a href="#简述费希特知识学的三条基本原理。" class="headerlink" title="简述费希特知识学的三条基本原理。"></a>简述费希特知识学的三条基本原理。</h3><ul><li>费希特知识学简单说来，以三条原理为中心内容。</li><li>第一原理，“自我建立自我”。自我建立自我是基于自我反省的认识。在认识之前，假定有一个绝对的自我，绝对自我通过主体的自我反省建立起来，于是设定自我。自我在设定自我时，把自我作为认识对象，与认识事实不同，它是一种直觉，还没有规定，没有限制。</li><li>第二原理，“自我建立非我”。自我在认识“自我”时，由于把自我作为一个对象看待，必然产生一种对象意识，即与“自我”相对立的东西，这就是“非我”。但非我并不是唯物主义所说的“自然界”，它是“自我”建立起来的，是自我能动的创造物。</li><li>第三原理，“自我与非我的统一”。自我与非我，主体与客体，主观与客观，意识与存在，精神与物质都统一于自我意识之中，相互限制，相互决定。这种自我与非我之间的统一关系即自我与非我的统一。</li><li>这三个阶段是辩证发展的，自我在不断创造非我时不断丰富自己，自我的创造过程也是自我的认识过程，自我不断丰富着对非我的认识，从而对自我的认识也丰富了。</li></ul><h3 id="绝对同一（谢林）"><a href="#绝对同一（谢林）" class="headerlink" title="绝对同一（谢林）"></a>绝对同一（谢林）</h3><ul><li>谢林的“绝对同一”指“无差别的同一”。它既非主体，亦非客体，而是“主体与客体的绝对无差别”。其中主体与客体、思维与存在都融合为一，没有差别。“绝对同一”是一种不自觉的精神力量，使自己和自己区别开来，从而产生出主体和客体、思维和存在、精神和物质的差别和矛盾，并复归于绝对同一。</li></ul><h3 id="简述谢林的历史观。"><a href="#简述谢林的历史观。" class="headerlink" title="简述谢林的历史观。"></a>简述谢林的历史观。</h3><ul><li>第一，谢林认为，自然界和人类历史是一个由低级到高级的不断发展的过程。</li><li>第二，谢林认为，矛盾是自然界和人类历史不断发展的动力。他说：“对立在每一刻都重新产生，又在每一刻被消除。对立在每一时刻都这样一再产生又一再消除，必定是一切运动的根据。</li><li>第三，谢林认为，人类社会的发展规律是不依人的主观意识为转移的。他认为人类历史乃是一个有意识的自由创造的过程，但正如无意识的必然的自然界中存在着有意识和自由一样，在有意识的自由的社会历史的创造活动中也存在着无意识必然的东西。这种东西就是不依人的主观意识为转移的历史规律。</li><li>第四，谢林认为，贯穿于自然界和人类社会历史中的意志的自由性和规律的必然性根源于“绝对同一性”，整个历史都是对这种绝对的启示和表露。</li></ul><h3 id="自在之物（康德）"><a href="#自在之物（康德）" class="headerlink" title="自在之物（康德）"></a>自在之物（康德）</h3><ul><li>在康德哲学中，“自在之物”与“现象界”相对，有三种不同含义：<ul><li>（1）指外在事物，在其认识论中常用，意思是在人认识外界事物时，先由这些事物刺激人们的感官而产生杂乱的印象与观念，然后由感性形式与知性范畴加以改造而形成现象界，人只能认识现象界，对自在物则不得而知。</li><li>（2）在《纯粹理性批判》的先验辩证部分中认为理性所试图达到的三个理念：一是一切精神现象的最高统一体“灵魂”；二是一切物理现象的最高统一体“世界”；三是无条件的全体统一。但人们对这些事物的统一仍然用知性的有限范畴去认识，因而理性陷入二律背反和谬误，以此说明自在之物存在于现象的彼岸，并不具有经验材料，不能形成知识，但可以通过伦理学思想而达到对它的假设。</li><li>（3）指与本体意义接近的极限概念，见于《纯粹理性批判》知性理论中论述本体与现象对立的部分。这种用法强调自在之物的不可知的性质，认为人的认识到此为止，不能超越这个界限，极限之内是现象界，可以认识，自在之物不能认识。从这个意义提出本体概念，作为对自在之物的另一种表述。辩证唯物主义承认自在之物，但否认自在之物与现象之间有不可逾越的界限。</li></ul></li></ul><h3 id="现象（康德）"><a href="#现象（康德）" class="headerlink" title="现象（康德）"></a>现象（康德）</h3><ul><li>在康德哲学中，“现象”与“自在之物”相对，是指在直观中对人呈现的东西。凡人经验所及，皆属现象范围，但并不是指客观事物的表面现象，而是指一种主观表象。这种表象由自在之物作用于人的感官形式，但它不反映自在之物的性质，而只是一种纯粹的主观心理状态。</li></ul><h3 id="二律背反（康德）"><a href="#二律背反（康德）" class="headerlink" title="二律背反（康德）"></a>二律背反（康德）</h3><ul><li>在康德哲学中，指两项原理对同一主题进行论证，其论证是矛盾的，但都是可以证明是正确的；或者两个前提推出的结论是矛盾的。二律背反的理论提出了理性思维中有矛盾的问题，但没有提出矛盾双方的统一与转化，并认为“有限”“无限”“简单”“复杂”这些说明现象界的知性范畴来说明自在之物是错误的；又认为自由与作为最初原因的上帝是属于自在之物的，而自然界则具有必然性，不能从必然性证明上帝存在，因而“自由”与“必然”“有上帝存在”与“没有上帝存在”可以存在于不同的地方，从而调和了矛盾。《纯粹理性批判》中提出理性宇宙论的四组二律背反，《实践理性批判》提出实践理性的二律背反，《判断力批判》中提出判断力的二律背反。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;明天期末考试，今天下午整理出来的复习资料，这还只是后半学期的，简直要疯了，最后还是佛系的选择随缘了！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yangkunyi.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="复习" scheme="http://yangkunyi.com/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="哲学" scheme="http://yangkunyi.com/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>不动产管理复习</title>
    <link href="http://yangkunyi.com/2018/01/03/%E4%B8%8D%E5%8A%A8%E4%BA%A7%E7%AE%A1%E7%90%86%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yangkunyi.com/2018/01/03/不动产管理复习/</id>
    <published>2018-01-03T12:10:09.000Z</published>
    <updated>2018-01-03T12:13:54.357Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天抽空整理了上个星期的不动产管理的复习题，当作复习吧，毕竟下个周就要考试了。</p></blockquote><a id="more"></a><ol><li>样品屋不是不动产。</li><li>不是定着物的特点：继续附着在建筑物上。</li><li>不动产的定义未包含<strong>预售屋</strong>。</li><li>要销售预售屋必须要有<strong>建造执照</strong>。</li><li>不动产物权只要签约就生效(X)；需要登记。</li><li>物权优先于债权。</li><li>关于地上权：不以支付地租为必要,不以订定租期为必要,地上权之目标为土地。</li><li>一坪 = 3.3058平方公尺</li><li>一平方公尺 = 0.3025坪</li><li>描述土地的词语：面积，位置，形状（密度不是）。</li><li>都市计划法包括的内容：乡镇计划，乡街计划，特定区计划。</li><li>基地面积100平方公尺,建蔽率50%,总楼地板面积25000平方公尺,容积率为多少?(<strong>容积率:楼地板面积除以建蔽率</strong>) <strong>500%</strong></li><li>容积率500%,基地面积100平方公尺,建蔽率50%,可盖几楼? (<strong>容积率除以建蔽率</strong>)10楼</li><li>从地籍图无法知道市价。</li><li>土地的性质不包括：异质性。</li><li>预售屋：<strong>高风险高报酬</strong>（自备款比中古屋少，总价负担重）。</li><li>房地产的特性：不可移动性，消费性，投资性。产品一致性不是房地产的特性。</li><li>在非都市土地中,山坡地保育区所兴建的房屋会属于何者用地?丙（老丙建）(甲:乡村 乙:乡村 丙:山坡 丁:工业)</li><li>所有权类型： 单独持有，分别共有，共同共有。</li><li>分别共有的特性：应有部分均等，着重应有部分，可自由处分应有部分。</li><li>房地产的声明周期：<strong>投资-&gt;生产-&gt;交易-&gt;使用</strong>。</li><li>共同共有：合伙财产（合伙人），共同财产（夫妻），未分割的遗产（继承）。</li><li>不是市地重划的原因：使用为公共交通促进土地合理之需要者（非都市）。</li><li>市地重划：经政府选定指定范围办理市地重划；人民申请优先办理；奖励私人自办重划。</li><li>市地重划描述错误的：重划后的土地按抽签的方式分配给原土地所有权人（按原位）。</li><li>市地重划中,土地所有权人共同负担不可超过?  <strong>45%</strong></li><li>市地重划的效益：增加土地供给，促进土地利用，提高土地价值。不是为了增进当地人口数。</li><li>市地重划（一定是都市土地）的原因：新设都市地区的全部或一部分，实施开发建设；旧都市地区为公共安全促进土地合理需要者；都市土地开发新社区者。</li><li>市地重划后土地所有人最少可领回? <strong>55%</strong></li><li>桃园航空城属于哪一种征收？ 区段征收</li><li>有关区段征收的描述，错误的是：仅适用于都市土地</li><li>区段征收：国家因公益需要的征收私有土地；土地征收程序第一步是举办公听会；新设都市地区的全部或一部分，实施开发者可以进行区段征收。</li><li>区段征收与市地重划的比较何者错误? 区段征收较公平（区段征收不公平）</li><li>一般征收与区段征收之描述何者错误?一般征收之原因不一定要为公共事业需要者（征收的土地一定要用于公共事业）–正确的：区段征收执行较为困难；区段征收公共设施较多样性；市地重划民众参与较多；区段征收的原因是开发建设或者促进土地利用；区段征收以现金、抵债地予以补偿；区段征收就是一定区域内的土地全部征收。</li><li>国泰禾</li><li>定型化契约是根据<strong>消费者保护法</strong>定下的。</li><li>登记面积超过3%就可以解约了。</li><li>预售屋定型化契约不得记载事项：广告仅供参考/使用面积销售等</li><li>公寓大厦管理条理的适用描述：建物形态相关</li><li>住户权益义务说法错误：不须负担共同壁的管线维修费用（需要）</li><li>物业管理范围不包括个人财务管理。</li><li>消费者保护法和公平交易法的描述错误的是：广告不实无法依据公交法向业者开罚。</li><li>适用于公平交易法：先付订金才可看契约,没有接露重要信息（违反了市场交易秩序）</li><li>社会住宅的用意：只租不卖；帮助经济弱势；协助社会弱势。</li><li>都市更新不包括：合建。</li><li>约定专用部分说明正确的：经约定将共享部分给特定区分所有权人使用</li><li>权利变换正确的是：（都市更新）立体分配的概念，重新分配土地和建物</li><li>物权具有排他性,请求权,追及性</li><li>凉亭是建筑物，门框铁窗是固定物，售票亭不是不动产</li><li>使用执照是卖之后才有</li><li>区段征收执行比较困难也应该是最后一个手段,公共设施比较多样性(因为政府拿比较多)所以市地重划的公社是比较少的。</li><li>保留增收:还不知道做甚么用先保留</li><li>区段征收:大规模大面积征收</li><li>一并征收:我要征收这边这边有小块一并征收</li><li>区段增收:<strong>抽签</strong> 市地重划:<strong>原位</strong></li><li>公同共有:双方因法律关系共同持有这个东西</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天抽空整理了上个星期的不动产管理的复习题，当作复习吧，毕竟下个周就要考试了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yangkunyi.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="复习" scheme="http://yangkunyi.com/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="不动产" scheme="http://yangkunyi.com/tags/%E4%B8%8D%E5%8A%A8%E4%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>WeeklyMind-6</title>
    <link href="http://yangkunyi.com/2017/12/30/WeeklyMind-6/"/>
    <id>http://yangkunyi.com/2017/12/30/WeeklyMind-6/</id>
    <published>2017-12-30T15:11:06.000Z</published>
    <updated>2018-01-01T15:12:33.181Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2017就这样过了，今天已经是2018年了，想来这一年确实发生了太多的事情，自己的价值观也在这些事情中一次次的改变和塑造着，未来的路在昨天的铺垫中慢慢成型，在今天的过程中慢慢延伸，在明天的憧憬理慢慢向前。这个周开始进入考试复习周，下周三就开始考试了，但自己在假期里显得十分的懒散，可能是因为自己这两天一直在想这一年自己到底干了什么，事情太多，整整两个日记本了，这应该就是自己的成长吧，在这里还是不想太多，就说说这个周。</p></blockquote><a id="more"></a><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul><li>web课程已经结束了。下周三期末考试，作为自己最不担心的一门课程，只希望自己不要粗心吧。</li><li>行销管理的小组报告自己有想好好做出来，做一个成品，之后也可以拿得出手，所以自己把自己当作这个小组的组长，一直在拉着整个报告的进度，但是这个假期还是懈怠了很多，不过假期嘛，大家都没有将心思放在这上面，所以打算回来后继续。</li><li>不动产管理课程也结束了，因为元旦下周的课程放掉了，下下周直接考试，这门课也希望自己能不留遗憾的完成，毕竟是缘分让自己选了这门课。</li><li>财务管理一直是自己不喜欢又带有些害怕的课程，考试范围也算是出来了，所以只能说努力吧。</li><li>西方哲学史也因为假期结课了，最后仍是考试，这门课自己倒不是很担心。</li><li>体育课已经结课了，从来不担心的课程，应该是一个不错的成绩。</li><li>人际管理课程报告也结束了，还有最后两节课和与一个期末总结就完成了，成绩应该也算理想，报告自己觉得做得也不错。</li></ul><blockquote><p>所有课程都进入尾声，自己在这边的学习生活也只剩下最后的15天了。来到这里就说自己要做点什么，然后度过前一周的新鲜期之后陷入深深的迷茫期，感觉不知道做什么，课程前期比较轻松，大把的时间让自己思考，突然不知道该做些什么，直到找到真正的目的——体验，才真正算是投入了这边的生活，这时候在想这五个多月自己没有辜负，完成了这一次体验的行程，自己也清楚的感受到，除了知识，这一次的体验拓展了自己的太多，就想自己开始说的那样，这段经历也是自己人生路的铺垫。</p></blockquote><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul><li>因为小组报告，自己又认识了一群来自不同地方的朋友。一双眼睛只能看到一个世界，但不同双眼睛就能看到不同的世界，自己在这些朋友的眼睛里又看到了不同的世界，那是自己不曾接触过的，却充满智慧，充满乐趣。</li><li>不动产管理的老师请全班的同学吃了披萨，虽然不是老师第一次请吃东西，但是这种氛围自己是第一次感受。从小，在自己的眼里，老师都是要尊敬的，这样自己和老师之间从来都没有向朋友一样亲近过，因为自己在老师面前就是无法将自己视为老师的朋友，但是那个时候我真的没有把筱蓉当作老师来看待，当然不仅仅是因为一顿批萨，而是筱蓉身上散发出来的气场，那种亲和的态度，我也不是说之前的老师不亲和，反正就是个人觉得自己是真的很喜欢筱蓉，也很喜欢她不拘小节的课程。</li><li>原校下周就要选课了，自己想来其实也没有太困难，就是物流的课程需要补回来，其余都还好，所以没必要那么担心。</li></ul><blockquote><p>人间一趟，看看太阳。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2017就这样过了，今天已经是2018年了，想来这一年确实发生了太多的事情，自己的价值观也在这些事情中一次次的改变和塑造着，未来的路在昨天的铺垫中慢慢成型，在今天的过程中慢慢延伸，在明天的憧憬理慢慢向前。这个周开始进入考试复习周，下周三就开始考试了，但自己在假期里显得十分的懒散，可能是因为自己这两天一直在想这一年自己到底干了什么，事情太多，整整两个日记本了，这应该就是自己的成长吧，在这里还是不想太多，就说说这个周。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="周记" scheme="http://yangkunyi.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>PHP绘图</title>
    <link href="http://yangkunyi.com/2017/12/24/PHP%E7%BB%98%E5%9B%BE/"/>
    <id>http://yangkunyi.com/2017/12/24/PHP绘图/</id>
    <published>2017-12-24T04:25:09.000Z</published>
    <updated>2017-12-24T04:27:16.457Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>web课程的笔记和一些实例代码。还有一份自定义图形作业，感觉还不错，简单做了一个二维码。（全是画矩形，确实有点无聊了，有空画点有趣的图）</p></blockquote><a id="more"></a><h3 id="PHP绘图"><a href="#PHP绘图" class="headerlink" title="PHP绘图"></a>PHP绘图</h3><h4 id="1-GD（Graphics-Dynamic-Library）"><a href="#1-GD（Graphics-Dynamic-Library）" class="headerlink" title="1. GD（Graphics Dynamic Library）"></a>1. GD（Graphics Dynamic Library）</h4><ul><li>GD1 / GD2</li><li>可以通过<code>phpinfo()</code>来查询</li></ul><h4 id="2-绘图流程"><a href="#2-绘图流程" class="headerlink" title="2. 绘图流程"></a>2. 绘图流程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">// 确定绘画图片的格式</div><div class="line">// 格式有：jpg，png，gif</div><div class="line">header(&quot;Content-type:image/格式&quot;);</div><div class="line"></div><div class="line">// 1. 建立一个画布（分配存储空间）</div><div class="line">$image = ImageCreate(长度,宽度);// 一般画布</div><div class="line">$image = ImageCreateTrueColor(长度,宽度);// 高清</div><div class="line"></div><div class="line">// 2. 建立颜色板</div><div class="line">$bgcolor=ImageColorAllocate($image,0,255,0);// 默认背景颜色</div><div class="line"></div><div class="line">// 3. PHP绘图命令</div><div class="line">// 点  ImageSetPixel($image,x,y,$color)</div><div class="line">ImageSetPixel($image,90,40,$textcolor);</div><div class="line">// 线  ImageLine($image,x1,y1,x2,y2,$color)</div><div class="line">ImageLine($image,0,0,$bgcolor);</div><div class="line">// 弧  ImageArc($image,x,y,高,宽,开始角度,结束角度,$color)</div><div class="line">ImageArc($image,50,25,90,40,0,360,$textcolor1);</div><div class="line">// 巨型  ImageRectangle($image,x1,y1,x2,y2,$color)</div><div class="line">ImageRectangle($image,20,10,80,40,$textcolor);</div><div class="line">// 空心多边形  ImagePolygon($image,$点数组,点数,$color)</div><div class="line">ImagePolygon($image,$point,count($point)/2,$textcolor);</div><div class="line">// 实心多边形  ImageFilledPolygon($image,$点数组,点数,$color)</div><div class="line">ImageFilledPolygon($image,$point,count($point)/2,$textcolor);</div><div class="line">// 透明  ImageColorTransparent($image,$color)</div><div class="line">ImageColorTransparent($image,$textcolor);</div><div class="line">// 文字输出 ImageTTFtext($image,大小,角度,x,y,$color,字体绝对路径,string)</div><div class="line">ImageTTFtext($image,32,0,0,50,$textcolor,&quot;simhei.ttf&quot;,$string);</div><div class="line"></div><div class="line"></div><div class="line">// 4. 显示/导出  ImageXXX($image[,储存图形的位置和名称])</div><div class="line">Imagepng($image);</div><div class="line"></div><div class="line">// 5. 结束 释放空间</div><div class="line">ImageDestroy($image);</div></pre></td></tr></table></figure><h3 id="实例：二维码绘制"><a href="#实例：二维码绘制" class="headerlink" title="实例：二维码绘制"></a>实例：二维码绘制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line">&lt;?php </div><div class="line">    // 文件输出图片格式为png</div><div class="line">    header(&quot;Content-type:image/png&quot;);</div><div class="line">    // 建立一个画布</div><div class="line">    $image = ImageCreate(100,100);</div><div class="line">    // 设定画布的北京颜色</div><div class="line">    $bgcolor = ImageColorAllocate($image,255,255,255);</div><div class="line">    ImageFill($image,0,0,$bgcolor);</div><div class="line">    // 画笔的颜色</div><div class="line">    $black = ImageColorAllocate($image,0,0,0);    </div><div class="line">    $white = ImageColorAllocate($image,255,255,255);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,0,0,28,28,$black);</div><div class="line">    ImageFilledRectangle($image,4,4,24,24,$white);</div><div class="line">    ImageFilledRectangle($image,8,8,20,20,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,72,0,500,28,$black);</div><div class="line">    ImageFilledRectangle($image,76,4,96,24,$white);</div><div class="line">    ImageFilledRectangle($image,80,8,92,20,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,0,72,28,500,$black);</div><div class="line">    ImageFilledRectangle($image,4,76,24,96,$white);</div><div class="line">    ImageFilledRectangle($image,8,80,20,92,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,64,64,84,84,$black);</div><div class="line">    ImageFilledRectangle($image,68,68,80,80,$white);</div><div class="line">    ImageFilledRectangle($image,72,72,76,76,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,0,32,20,44,$black);</div><div class="line">    ImageFilledRectangle($image,4,36,8,40,$white);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,4,44,12,48,$black);</div><div class="line">    ImageFilledRectangle($image,0,48,4,68,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,8,52,12,56,$black);</div><div class="line">    ImageFilledRectangle($image,12,48,20,68,$black);</div><div class="line">    ImageFilledRectangle($image,16,52,20,64,$white);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,32,4,36,8,$black);</div><div class="line">    ImageFilledRectangle($image,40,0,44,8,$black);</div><div class="line">    ImageFilledRectangle($image,48,0,52,4,$black);</div><div class="line">    ImageFilledRectangle($image,52,4,56,8,$black);</div><div class="line">    ImageFilledRectangle($image,60,4,64,8,$black);</div><div class="line">    ImageFilledRectangle($image,64,0,68,4,$black);</div><div class="line">    ImageFilledRectangle($image,64,8,68,12,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,48,8,52,16,$black);</div><div class="line">    ImageFilledRectangle($image,52,12,56,20,$black);</div><div class="line">    ImageFilledRectangle($image,56,8,60,16,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,24,56,32,68,$black);</div><div class="line">    ImageFilledRectangle($image,24,60,28,64,$white);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,24,40,28,44,$black);</div><div class="line">    ImageFilledRectangle($image,24,48,28,52,$black);</div><div class="line">    ImageFilledRectangle($image,28,44,32,48,$black);</div><div class="line">    ImageFilledRectangle($image,32,40,36,44,$black);</div><div class="line">    ImageFilledRectangle($image,36,48,44,52,$black);</div><div class="line">    ImageFilledRectangle($image,32,12,44,16,$black);</div><div class="line">    ImageFilledRectangle($image,36,16,40,24,$black);</div><div class="line">    ImageFilledRectangle($image,32,20,36,28,$black);</div><div class="line">    ImageFilledRectangle($image,24,32,40,36,$black);</div><div class="line">    ImageFilledRectangle($image,36,28,48,32,$black);</div><div class="line">    ImageFilledRectangle($image,40,24,44,28,$black);</div><div class="line">    ImageFilledRectangle($image,44,20,68,24,$black);</div><div class="line">    ImageFilledRectangle($image,48,24,52,28,$black);</div><div class="line">    ImageFilledRectangle($image,56,24,60,28,$black);</div><div class="line">    ImageFilledRectangle($image,64,24,68,28,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,32,68,36,100,$black);</div><div class="line">    ImageFilledRectangle($image,32,76,36,80,$white); </div><div class="line"></div><div class="line">    ImageFilledRectangle($image,68,84,84,88,$black);</div><div class="line">    ImageFilledRectangle($image,88,88,92,92,$black);</div><div class="line">    ImageFilledRectangle($image,84,68,88,84,$black);</div><div class="line">    ImageFilledRectangle($image,88,64,92,88,$black);</div><div class="line">    ImageFilledRectangle($image,88,76,92,80,$white);</div><div class="line">    ImageFilledRectangle($image,92,72,96,88,$black);</div><div class="line">    ImageFilledRectangle($image,96,72,100,100,$black);</div><div class="line">    ImageFilledRectangle($image,76,96,96,100,$black);</div><div class="line">    ImageFilledRectangle($image,76,88,80,96,$black);</div><div class="line">    ImageFilledRectangle($image,80,92,88,96,$black);</div><div class="line">    ImageFilledRectangle($image,88,88,92,92,$black);</div><div class="line">    ImageFilledRectangle($image,68,96,72,100,$black);</div><div class="line">    ImageFilledRectangle($image,64,92,68,96,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,68,32,72,36,$black);</div><div class="line">    ImageFilledRectangle($image,76,32,80,44,$black);</div><div class="line">    ImageFilledRectangle($image,84,32,88,36,$black);</div><div class="line">    ImageFilledRectangle($image,92,32,96,44,$black);</div><div class="line">    ImageFilledRectangle($image,64,36,68,44,$black);</div><div class="line">    ImageFilledRectangle($image,68,40,72,44,$black);</div><div class="line">    ImageFilledRectangle($image,84,40,88,44,$black);</div><div class="line">    ImageFilledRectangle($image,96,36,100,48,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,64,48,76,56,$black);</div><div class="line">    ImageFilledRectangle($image,68,52,80,60,$black);</div><div class="line">    ImageFilledRectangle($image,68,52,76,56,$white);</div><div class="line">    </div><div class="line">    ImageFilledRectangle($image,80,48,84,52,$black);</div><div class="line">    ImageFilledRectangle($image,64,60,72,64,$black);</div><div class="line">    ImageFilledRectangle($image,80,60,88,64,$black);</div><div class="line">    ImageFilledRectangle($image,84,52,88,64,$black);</div><div class="line">    ImageFilledRectangle($image,88,48,100,52,$black);</div><div class="line">    ImageFilledRectangle($image,92,52,96,60,$black);</div><div class="line">    ImageFilledRectangle($image,96,56,100,64,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,44,32,48,36,$black);</div><div class="line">    ImageFilledRectangle($image,56,28,64,32,$black);</div><div class="line">    ImageFilledRectangle($image,52,32,60,36,$black);</div><div class="line">    ImageFilledRectangle($image,48,36,56,40,$black);</div><div class="line">    ImageFilledRectangle($image,40,36,44,44,$black);</div><div class="line">    ImageFilledRectangle($image,56,40,64,48,$black);</div><div class="line">    ImageFilledRectangle($image,48,44,52,52,$black);</div><div class="line">    ImageFilledRectangle($image,52,48,56,56,$black);</div><div class="line">    ImageFilledRectangle($image,44,56,64,60,$black);</div><div class="line">    ImageFilledRectangle($image,56,60,60,64,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,36,56,40,64,$black);</div><div class="line">    ImageFilledRectangle($image,40,64,44,72,$black);   </div><div class="line">    ImageFilledRectangle($image,44,60,48,68,$black);  </div><div class="line">    ImageFilledRectangle($image,48,68,56,72,$black);  </div><div class="line">    ImageFilledRectangle($image,52,72,56,80,$black);  </div><div class="line">    ImageFilledRectangle($image,56,72,60,76,$black);  </div><div class="line">    ImageFilledRectangle($image,48,76,52,84,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,36,72,40,88,$black);</div><div class="line">    ImageFilledRectangle($image,40,76,44,84,$black);</div><div class="line">    ImageFilledRectangle($image,36,96,40,100,$black);</div><div class="line">    ImageFilledRectangle($image,44,88,48,100,$black);</div><div class="line">    ImageFilledRectangle($image,48,88,52,92,$black);</div><div class="line">    ImageFilledRectangle($image,60,68,64,72,$black);</div><div class="line">    ImageFilledRectangle($image,56,80,64,84,$black);</div><div class="line">    ImageFilledRectangle($image,56,92,60,96,$black);</div><div class="line">    </div><div class="line">    // 形成图像</div><div class="line">    Imagepng($image);</div><div class="line">    // 释放空间</div><div class="line">    ImageDestroy($image);</div><div class="line">?&gt;</div></pre></td></tr></table></figure><h5 id="结果（扫一扫啊，哈哈哈）"><a href="#结果（扫一扫啊，哈哈哈）" class="headerlink" title="结果（扫一扫啊，哈哈哈）"></a>结果（扫一扫啊，哈哈哈）</h5><p><img src="http://otn4ut2th.bkt.clouddn.com/bloggenerate.png" alt="二维码"></p><hr><h2 id="更新图"><a href="#更新图" class="headerlink" title="更新图"></a>更新图</h2><h4 id="图一"><a href="#图一" class="headerlink" title="图一"></a>图一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    // 一幅随机图</div><div class="line">    </div><div class="line">    // 文件输出图片格式为png</div><div class="line">    header(&quot;Content-type:image/png&quot;);</div><div class="line">    // 建立一个画布</div><div class="line">    $image = ImageCreate(500,550);</div><div class="line">    // 设定画布的北京颜色</div><div class="line">    $bgcolor = ImageColorAllocate($image,0,0,0);</div><div class="line">    ImageFill($image,0,0,$bgcolor);</div><div class="line">    // 画笔的颜色</div><div class="line">    $black = ImageColorAllocate($image,0,137,167);</div><div class="line"></div><div class="line">    // 绘画过程</div><div class="line"></div><div class="line">    $x2 = 0;</div><div class="line">    for($j = 0;$j &lt; 25; $j++)&#123;</div><div class="line">        // 随机生成圆半径</div><div class="line">        $radius1 = rand(7,12);</div><div class="line">        // 随机点生成一个实心圆</div><div class="line">        $x1 = rand(1,499);</div><div class="line">        $y1 = rand(1,499);</div><div class="line">        for($i = 1;$i &lt; $radius1;$i++)&#123;</div><div class="line">            </div><div class="line">            $w = $i;</div><div class="line">            $h = $i;</div><div class="line">            imagearc($image, $x1,  $y1,  $w,  $h,  0, 360, $black);</div><div class="line">        &#125;</div><div class="line">        if($x2 !== 0)&#123;</div><div class="line">            ImageLine($image,$x1,$y1,$x2,$y2,$black);</div><div class="line">        &#125;</div><div class="line">        // 随机生成圆半径</div><div class="line">        $radius2 = rand(7,12);</div><div class="line">        // 随机再生成一点连接上一点</div><div class="line">        $x2 = rand(1,499);</div><div class="line">        $y2 = rand(1,499);</div><div class="line">        for($i = 1;$i &lt; $radius2;$i++)&#123;</div><div class="line">            </div><div class="line">            $w = $i;</div><div class="line">            $h = $i;</div><div class="line">            imagearc($image, $x2,  $y2,  $w,  $h,  0, 360, $black);</div><div class="line">        &#125;</div><div class="line">        ImageLine($image,$x1,$y1,$x2,$y2,$black);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    // 打出名字</div><div class="line">    $string = &quot;x1067017 杨坤怡&quot;;</div><div class="line">    ImageTTFtext($image,12,0,360,530,$black,&quot;c:/windows/fonts/FZPXJW.TTF&quot;,$string);</div><div class="line"></div><div class="line">    // 形成图像</div><div class="line">    Imagepng($image);</div><div class="line">    // 释放空间</div><div class="line">    ImageDestroy($image);</div><div class="line">?&gt;</div></pre></td></tr></table></figure><h4 id="图二"><a href="#图二" class="headerlink" title="图二"></a>图二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    // 一幅随机图</div><div class="line">    </div><div class="line">    // 文件输出图片格式为png</div><div class="line">    header(&quot;Content-type:image/png&quot;);</div><div class="line">    // 建立一个画布</div><div class="line">    $image = ImageCreate(400,420);</div><div class="line">    // 设定画布的北京颜色</div><div class="line">    $bgcolor = ImageColorAllocate($image,55,60,56);</div><div class="line">    ImageFill($image,0,0,$bgcolor);</div><div class="line">    // 画笔的颜色</div><div class="line">    $black = ImageColorAllocate($image,0,137,108);</div><div class="line"></div><div class="line">    // 绘画过程</div><div class="line"></div><div class="line">    // 随机生成空心三角形</div><div class="line">    $point=array();</div><div class="line">    for($j = 1;$j &lt; 10;$j++)&#123;</div><div class="line">        for($i = 1;$i &lt; 4;$i++)&#123;</div><div class="line">            $x = rand(1,399);</div><div class="line">            $y = rand(1,399);</div><div class="line">            array_push($point,$x,$y);</div><div class="line">        &#125;</div><div class="line">        ImagePolygon($image,$point,count($point)/2,$black);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 打出名字</div><div class="line">    $string = &quot;x1067017 杨坤怡&quot;;</div><div class="line">    ImageTTFtext($image,12,0,250,410,$black,&quot;c:/windows/fonts/FZPXJW.TTF&quot;,$string);</div><div class="line"></div><div class="line">    // 形成图像</div><div class="line">    Imagepng($image);</div><div class="line">    // 释放空间</div><div class="line">    ImageDestroy($image);</div><div class="line">?&gt;</div></pre></td></tr></table></figure><h4 id="图三"><a href="#图三" class="headerlink" title="图三"></a>图三</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    // 绘画一个A字母</div><div class="line">    // 文件输出图片格式为png</div><div class="line">    header(&quot;Content-type:image/png&quot;);</div><div class="line">    // 建立一个画布</div><div class="line">    $image = ImageCreate(400,400);</div><div class="line">    // 设定画布的北京颜色</div><div class="line">    $bgcolor = ImageColorAllocate($image,0,0,0);</div><div class="line">    ImageFill($image,0,0,$bgcolor);</div><div class="line">    // 画笔的颜色</div><div class="line">    $black = ImageColorAllocate($image,241,124,103);</div><div class="line"></div><div class="line">    // 绘画过程</div><div class="line"></div><div class="line">    // for($i = 1;$i &lt; 6;$i++)&#123;</div><div class="line">    //     $w = $i * 15;</div><div class="line">    //     $h = $i * 15;</div><div class="line">    //     imagearc($image, 250,  250,  $w,  $h,  0, 360, $black);</div><div class="line">    // &#125;</div><div class="line"></div><div class="line">    $start = 0;</div><div class="line">    $stop = 120;</div><div class="line">    for($i = 1;$i &lt; 13;$i++)&#123;</div><div class="line">        $w = $i * 25;</div><div class="line">        $h = $i * 25;</div><div class="line">        imagearc($image, 200,  200,  $w,  $h,  $start, $stop, $black);</div><div class="line">        $start += 1*$i;</div><div class="line">        $stop -= 1*$i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $start = 120;</div><div class="line">    $stop = 240;</div><div class="line">    for($i = 1;$i &lt; 13;$i++)&#123;</div><div class="line">        $w = $i * 25;</div><div class="line">        $h = $i * 25;</div><div class="line">        imagearc($image, 200,  200,  $w,  $h,  $start, $stop, $black);</div><div class="line">        $start += 1*$i;</div><div class="line">        $stop -= 1*$i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $start = 240;</div><div class="line">    $stop = 360;</div><div class="line">    for($i = 1;$i &lt; 13;$i++)&#123;</div><div class="line">        $w = $i * 25;</div><div class="line">        $h = $i * 25;</div><div class="line">        imagearc($image, 200,  200,  $w,  $h,  $start, $stop, $black);</div><div class="line">        $start += 1*$i;</div><div class="line">        $stop -= 1*$i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 打出名字</div><div class="line">    $string = &quot;x1067017 杨坤怡&quot;;</div><div class="line">    ImageTTFtext($image,12,0,250,370,$black,&quot;c:/windows/fonts/FZPXJW.TTF&quot;,$string);</div><div class="line"></div><div class="line"></div><div class="line">    // 形成图像</div><div class="line">    Imagepng($image);</div><div class="line">    // 释放空间</div><div class="line">    ImageDestroy($image);</div><div class="line">?&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;web课程的笔记和一些实例代码。还有一份自定义图形作业，感觉还不错，简单做了一个二维码。（全是画矩形，确实有点无聊了，有空画点有趣的图）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yangkunyi.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="PHP" scheme="http://yangkunyi.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>WeeklyMind-5</title>
    <link href="http://yangkunyi.com/2017/12/24/WeeklyMind-5/"/>
    <id>http://yangkunyi.com/2017/12/24/WeeklyMind-5/</id>
    <published>2017-12-24T04:23:09.000Z</published>
    <updated>2017-12-24T04:24:03.666Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本周开始学习都开始进入最后的报告和复习阶段，不动产报告， 人际关系报告，以及接下来的行销报告和各种总结，然后是期末考试复习，所以这两个周不太有时间自学了。<br><a id="more"></a></p></blockquote><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul><li><p>不动产管理小组报告：可能因为对这边的一些名词不太熟悉，所以报告的时候自己有一点说不清楚，不知道该如何表达自己的想法；不过也是没有准备充分的表现。</p></li><li><p>人际关系小组报告：我们小组的主题是社交软件对大学生人际关系的影响，自己准备的ying<br>影响的好坏部分，这次就好很多了，自己有事先练习自己不熟悉的稿子，报告的时候就能很顺利的讲下来。</p></li><li><p>行销管理小组讨论：这样的小组讨论是很重要的我觉得，以后作为一个想要在互联网公司工作的人，这种小组讨论的能力是必须具备的，而自己在讨论中的表现还算行，队友们也很给力，最后分工也很快敲定下来，希望最后的小组报告也能一切顺利。</p></li><li><p>财务管理和西方哲学史也都剩下最后一节课了，所以要抓紧时间复习了啊！</p></li></ul><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul><li>本周的天气都不错，前两天很冷，后面都有着充足的阳光。</li><li>周四人际关系报告完回寝室的路上，在马路中间和它相遇了，它就好像在那里等我一样，我当时还在看手机，却不经意的一个转头，看见它就那样安静的躺在马路上，心里当时唯一的想法就是不要让来往的车辆压着它了，于是把它带了回来。<br><img src="http://otn4ut2th.bkt.clouddn.com/blogTIM%E5%9B%BE%E7%89%8720171224121759.jpg" alt="此处输入图片的描述"></li><li>今天是平安夜，明天是圣诞节，作为一个不怎么过圣诞节的我来说，吃一个苹果就足够了，还有就是今晚和室友约着去吃火（tang）锅，这可能是自己在这边的最后一顿火锅了吧！</li><li>周五去看了旁边的交大，只是去吃了有名的松饼，所以也没有来得及细看整个学校，唯一的感觉就是看到的建筑都很有设计感。</li></ul><h2 id="待更新事项"><a href="#待更新事项" class="headerlink" title="待更新事项"></a>待更新事项</h2><ul><li>不动产管理上节课的评价和学期总结</li><li>关于台湾的三千字</li><li>复习</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本周开始学习都开始进入最后的报告和复习阶段，不动产报告， 人际关系报告，以及接下来的行销报告和各种总结，然后是期末考试复习，所以这两个周不太有时间自学了。&lt;br&gt;
    
    </summary>
    
    
      <category term="-周记" scheme="http://yangkunyi.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>WeeklyMind-4</title>
    <link href="http://yangkunyi.com/2017/12/17/WeeklyMind-4/"/>
    <id>http://yangkunyi.com/2017/12/17/WeeklyMind-4/</id>
    <published>2017-12-17T04:52:37.000Z</published>
    <updated>2017-12-17T04:54:01.515Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这个周开始都开始准备各科的报告和总结了，所以不是在写报告就是在做ppt，周五下午有抽空学习node，看了N-blog项目的大概，但是困难出在MongoDB，虽然连上了，项目跑起来了，但是并没有懂其中的原理，之后会继续理解。</p></blockquote><a id="more"></a><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><ul><li>web学了PHP的绘画，还画了一个二维码。</li><li>不动产管理报告</li><li>人际关系报告</li><li>完成了毛概</li><li>不定期更新微信</li></ul><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><ul><li>进入自己想要的规律状态，但是每天运动量还是太少了，可能是气温太低了，自己也没有想出门。</li><li>今天晚上准备去买水果，维生素还是不能少</li><li>真的不是很喜欢这边的食物，吃的不是很开心，开始想奶奶做得菜了</li><li>昨晚和一个同龄的妹子聊到了父母的期望和自己想做的有偏差，自己将自己想做的都告诉了她，那是因为自己也想像自己所说的那么坚持，坚持做自己想做的事情，父母的期望并不想辜负，尽自己最大的努力去达到他们想看到的样子，但是这并不意味着我不能做自己，这并不是矛盾的关系，很多情况下自己的想法和父母的想法是可以共存的。父母希望自己把心思放在学习上，只不过想自己的成绩能够过得去，那自己在保证了成绩的前提下做的事情父母也会接受的，获许还更可能得到支持。所以我觉得不能把自己的想法和父母的想法完全对立起来吧，换一种看法，就像前面所说的，是可以共存的。</li></ul><h3 id="待更进事项"><a href="#待更进事项" class="headerlink" title="待更进事项"></a>待更进事项</h3><ul><li>西方哲学整理复习</li><li>财务管理复习（考课后题，我就把课后题全做一遍总可以了吧！死记硬背我都给你过了。。。）</li><li>行销管理报告，视频，ppt</li><li>继续学习英语</li></ul><blockquote><p>已经开始倒数着回去的日子了，是真的想家了吧！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这个周开始都开始准备各科的报告和总结了，所以不是在写报告就是在做ppt，周五下午有抽空学习node，看了N-blog项目的大概，但是困难出在MongoDB，虽然连上了，项目跑起来了，但是并没有懂其中的原理，之后会继续理解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="周记" scheme="http://yangkunyi.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>NeverLimitYourself</title>
    <link href="http://yangkunyi.com/2017/12/14/NeverLimitYourself/"/>
    <id>http://yangkunyi.com/2017/12/14/NeverLimitYourself/</id>
    <published>2017-12-14T13:01:57.000Z</published>
    <updated>2017-12-14T13:10:43.630Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看完C菌的视频有感而发，想说一些话！</p></blockquote><a id="more"></a><p>自己正是出于这样的原因选择来到台湾交流学习，我想看看那远离我的生活的地方有什么不一样，那里的生活是怎么样的？那里的人是怎么样的？那里的猫也是那么懒吗？…</p><p>于是九月四日踏上里人生的第一次飞机之旅，短短三个小时，来到了这个离家一千多千米的岛上。一切都是那么好奇，现在的我已经在这里快四个月了，学习生活也都很顺手了，该体验的自己也都体验到了，再也不会像刚来的前几周那样充满不安的焦虑，或许这就是成长吧。</p><p>在申请这个交换机会的时候，自己曾给自己找各种理由，但最后还是只能说：我就是想看看。</p><p>自己在最开始的时候焦虑一个是因为陌生环境的压力；另一个原因是自己看到了自己相看的东西之后，心里突然之间有一瞬间感觉空空的，不知道自己之后该做什么了，整个人好像在这里生活着没什么意思了，同时本校也开学了，看着同学们开学的动态，那种叫做孤独的东西一下子就从心里冒了出来。可是别人还在“羡慕”的“恭维”和祝贺自己来到这里，所以自己还要打起精神来应付，为了来这里之前说下的那句：“我想去看看！”没错，那个时候每天都很丧，过得很混沌。</p><p>那个时候只有父母算生活动力，想着他们为了让自己出来看看所做的努力，自己真的没理由就这样混沌的过，但同时这种压抑的感觉又让自己整个人感觉很紧绷，所以也是压力吧。自己没有自觉与他们联系的习惯，在本校的时候一个月也是要回家的时候才会联系一下，所以根本不知道平时有什么好跟他们说的。不过为了让他们不担心自己的生活和学习，自己还是学会了每隔两天报告一下平安，是真的只有一个“报”字的报平安。不过母上大人还是想自己的，偶尔会在晚上和自己视频一下，说一下家里的情况，自己也会简单的报告一下自己的近况，虽然自己初中以来就是住校，但这次毕竟隔得比较远，所以其实真的是有些想他们了。</p><p>然后终于那句：“意义这种事情只有在做过之后才知道，之前说的意义都是肤浅的认知罢了！”解决了让自己失眠一个周的问题，终于将急躁的心放到了肚子里，开始慢慢享受每一天的生活，早起，看书，上课，写作业，跑步…终于生活算是步入了正轨。</p><p>正式抱着这样的心态，中间出去短途旅行了三次，那才叫真的看到了自己看到的，由于马上要期末考试了，所以之后应该不会再出去了。不过这三次的记忆就足以抵上前三个月的努力了，接下来就好好准备课程相关报告和考试吧。</p><p>经过这四个月的生活后，那种不知名意义好像快要浮出水面的时候，看到了C菌的Nerver Limit Yourself，自己终于找到了可以表达自己心情的句子：</p><blockquote><p>Never limit yourself because of others’ limited imagination; never limit others because of your own limited imagination.<br>— MAE JEMISON</p></blockquote><p>ps:如果想了解本人在台湾的更多近况，可以扫描下面的公众号二维码。（可能这就是广告吧。）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;看完C菌的视频有感而发，想说一些话！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="日常" scheme="http://yangkunyi.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="随笔记" scheme="http://yangkunyi.com/tags/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
      <category term="观后感" scheme="http://yangkunyi.com/tags/%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>WeeklyMind-3</title>
    <link href="http://yangkunyi.com/2017/12/10/WeeklyMind-3/"/>
    <id>http://yangkunyi.com/2017/12/10/WeeklyMind-3/</id>
    <published>2017-12-10T09:30:09.000Z</published>
    <updated>2017-12-10T11:35:18.462Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本周很日常，只是感觉自己有点缺乏锻炼，所以显得不是特别的精神，可能也和天气有关系，开始凉了，自己也没带什么厚衣服，所以没课都不怎么出门的那种。</p></blockquote><a id="more"></a><h4 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h4><ul><li>各科课程进行正常</li><li>但并没有完成本校作业</li><li>完成了第一次不动产小组报告，虽然内容很尬，但是表现自己还算满意</li><li>关于人际关系的人际圈，自己在课堂上画出不同的圈也让自己十分的意外，但这也是自己本身的看法罢了，或许这才是最真实的自己</li><li>让自己丧了一天的财务管理期中成绩也是真的令自己心碎啊</li><li>了解了一些数据库的知识，应该叫复习了，毕竟之前还是多少学了一点</li><li>node要努力了，时间的零碎学起来也是很零碎</li></ul><h4 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h4><ul><li>这一周缺乏锻炼，怎么感觉又长胖了。。。</li><li>稍微一点混沌，可能躺太多</li><li>手臂在乒乓球课崴了，一直一点酸疼</li><li>吃饭特别不规律！！！这一点下个周一定得改了</li><li>对了，微信终于开始了，不过进度貌似不能保证每天，所以自己准备改一下，暂时上学期间频率保持一周两篇吧，如果空闲的周可以多做一点</li></ul><h4 id="待更进事项"><a href="#待更进事项" class="headerlink" title="待更进事项"></a>待更进事项</h4><ul><li>通信作业的问题回答</li><li>还是抽时间把毛概的论文写了吧，毕竟回去可能还真的可以考试呢</li><li>node</li><li>php继续学习</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本周很日常，只是感觉自己有点缺乏锻炼，所以显得不是特别的精神，可能也和天气有关系，开始凉了，自己也没带什么厚衣服，所以没课都不怎么出门的那种。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="周记" scheme="http://yangkunyi.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>用户验证与数据库</title>
    <link href="http://yangkunyi.com/2017/12/06/%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yangkunyi.com/2017/12/06/用户验证与数据库/</id>
    <published>2017-12-06T12:22:28.000Z</published>
    <updated>2017-12-06T12:25:46.194Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是今天web课程的笔记，亲自尝试了前面两种验证方式，第三种方式之前也有所接触，还都算比较好理解。后面还有一些数据库的简单解释。</p></blockquote><a id="more"></a><h2 id="验证用户方法"><a href="#验证用户方法" class="headerlink" title="验证用户方法"></a>验证用户方法</h2><h3 id="1-HTTP自带的验证"><a href="#1-HTTP自带的验证" class="headerlink" title="1. HTTP自带的验证"></a>1. HTTP自带的验证</h3><blockquote><p>这种方式是利用HTTP所提供的验证头信息来对用户进行身份验证。由于这种凡是对大量的使用者缺乏有效的管理，在用户太多时并没有太大用处，因此少量用户时使用。例如开发人员。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;?php </div><div class="line">    // 如果 $PHP_AUTH_USER 不等于 &quot;tea&quot;，就进不去网站。 </div><div class="line">    if($_SERVER[&apos;PHP_AUTH_USER&apos;] !=&apos;tea&apos; || $_SERVER[&apos;PHP_AUTH_PW&apos;] !=&apos;ok&apos;)&#123; </div><div class="line">    //通过头部信息告知浏览器验证</div><div class="line">    header(&apos;WWW-Authenticate: Basic realm=&quot;「需验证」---请输入账户/密码&quot;&apos;); </div><div class="line">    header(&apos;HTTP/1.0 401 Unauthorized&apos;); </div><div class="line">    echo &quot;账号或密码错误。请刷新重新输入。&quot;; </div><div class="line">    </div><div class="line">    //记得要加上 exit() 离开，不然就跟没有验证一样了！ </div><div class="line">    exit(); </div><div class="line">    &#125; </div><div class="line">    /* </div><div class="line">    如果用户输入正确的账户和密码，下面的 HTML 就会显示 </div><div class="line">    */ </div><div class="line">    ?&gt; </div><div class="line">&lt;HTML&gt; </div><div class="line">    &lt;HEAD&gt; </div><div class="line">        &lt;TITLE&gt;&lt;/TlTLE&gt; </div><div class="line">    &lt;/HEAD&gt; </div><div class="line"></div><div class="line">    &lt;BODY&gt; </div><div class="line">        &lt;P&gt;Hello World！&lt;/P&gt; </div><div class="line">    &lt;/BODY&gt; </div><div class="line">&lt;/HTML&gt;</div></pre></td></tr></table></figure><h3 id="2-htaccess方式的验证"><a href="#2-htaccess方式的验证" class="headerlink" title="2. htaccess方式的验证"></a>2. <code>htaccess</code>方式的验证</h3><blockquote><p>这种凡是其实时Apche所提供的加强版HTTP验证方式，利用Apche所提供的<code>htpasswd</code>来设定使用者账号和密码。但是任然不适用过多用户。</p></blockquote><h4 id="首先建立用户数据（授权的动作）"><a href="#首先建立用户数据（授权的动作）" class="headerlink" title="首先建立用户数据（授权的动作）"></a>首先建立用户数据（授权的动作）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 第一次 -c，第二次添加就不需要了</div><div class="line">c:\appserv\apache\bin&gt; htpasswd -c htusers Tom </div><div class="line">New password: ←输入用户密码 </div><div class="line">Re-type new password: ←再次输入 </div><div class="line">Adding password for user Tom</div><div class="line"></div><div class="line">c:\appserv\apache\bin&gt; htpasswd htusers Jack </div><div class="line">New password: </div><div class="line">Re-type new password: </div><div class="line">Adding password for user Jack</div><div class="line"></div><div class="line">// 可以将不同的人进行分组，group是群组名称</div><div class="line">group:Tom Jack</div></pre></td></tr></table></figure><h4 id="然后在需要权限才可以进入的路径中建-htaccess文档（将已授权和访问地址联系到一起）"><a href="#然后在需要权限才可以进入的路径中建-htaccess文档（将已授权和访问地址联系到一起）" class="headerlink" title="然后在需要权限才可以进入的路径中建.htaccess文档（将已授权和访问地址联系到一起）"></a>然后在需要权限才可以进入的路径中建<code>.htaccess</code>文档（将已授权和访问地址联系到一起）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 显示给用户看的提示</div><div class="line">AuthName &quot;登陆时需要输入账号和密码「账号」与「密码」&quot; </div><div class="line">// 验证时不编码</div><div class="line">AuthType Basic </div><div class="line">// 之前建立的用户数据</div><div class="line">AuthUserFile c:\appserv\apache\bin\htusers </div><div class="line">#AuthGroupFile c:\appserv\apache\bin\htgroup </div><div class="line">// 所有访问的都需要验证</div><div class="line">require valid-user </div><div class="line">#require user jollen </div><div class="line">#require group ieem316 </div><div class="line">// 定义说拒绝所有，允许个别</div><div class="line">order deny,allow </div><div class="line">deny from all </div><div class="line">#allow from .nthu.edu.tw </div><div class="line">allow from 140.114.70.31</div></pre></td></tr></table></figure><h3 id="3-数据库存储用户数据"><a href="#3-数据库存储用户数据" class="headerlink" title="3. 数据库存储用户数据"></a>3. 数据库存储用户数据</h3><blockquote><p>最有效，最普遍的做法，将用户的账户和密码存在数据库中，每次登陆到数据库中查找数据，最后返回有无和正确性。</p></blockquote><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol><li>登陆的表单</li><li>登陆的程序</li><li>建好用户的资料库，至少要包括账号和密码</li></ol><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>通过表单获取用户账号与密码</li><li>到数据库中查找对应的账号和密码</li><li>失败就返回重新获取信息，直到成功为止</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 本程序通过头信息获取的用户的账户和密码</div><div class="line">&lt;?php </div><div class="line">    // 如果用户沒有输入账户，要求用户重新验证。 </div><div class="line">    IF(!isset($PHP_AUTH_USER))&#123; </div><div class="line">        header(&apos;WWW-Authenticate: Basic realm=&quot;请输入账号和密码&quot;&apos;); </div><div class="line">        header(&apos;HTTP/1.0 401 Unauthorized&apos;); </div><div class="line">        echo &quot;刷新后重新登陆&quot;; </div><div class="line">        exit(); </div><div class="line">    &#125;</div><div class="line">    else&#123; </div><div class="line">        mysql_connect(&quot;localhost&quot;,&quot;admin&quot;,&quot;asdee4&quot;) or die (&quot;无法连接 MySQL&quot;); </div><div class="line">        rnysql_select_db(&quot;members&quot;) or die(&quot;无法连接数据库&quot;); </div><div class="line">        $query=&quot;select id from users where username=&apos;$PHP_AUTH_USER&apos; and </div><div class="line">        password=&apos;$PHP_AUTH_PW&apos;&quot;; </div><div class="line">        $result=mysql_query($query); </div><div class="line">        $n_rows=mysql_num_rows($result); </div><div class="line">        mysql_close(); </div><div class="line">        // 当row&lt;1时，用户账号与密码有错，重新登陆</div><div class="line">        if($n_rows &lt; 1)&#123; </div><div class="line">            header(&apos;WWW_Authenticate: Basic realm=&quot;请输入账号和密码&quot;&apos;); </div><div class="line">            header(&apos;HTTP/1.0 401 Unauthorized&apos;); </div><div class="line">            echo &quot;刷新重新登陆&quot;; </div><div class="line">            exit(); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">?&gt;</div></pre></td></tr></table></figure><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="数据库系统-数据库管理系统-数据库"><a href="#数据库系统-数据库管理系统-数据库" class="headerlink" title="数据库系统 = 数据库管理系统 + 数据库"></a>数据库系统 = 数据库管理系统 + 数据库</h3><h4 id="DBMS（数据库管理系统）：database-management-system"><a href="#DBMS（数据库管理系统）：database-management-system" class="headerlink" title="DBMS（数据库管理系统）：database management system"></a>DBMS（数据库管理系统）：database management system</h4><ul><li>只是一个软件</li><li>作用：资料的管理和维护</li></ul><h4 id="DB（数据库）：database"><a href="#DB（数据库）：database" class="headerlink" title="DB（数据库）：database"></a>DB（数据库）：database</h4><h3 id="SQL（structure-query-language）：结构化查询语句"><a href="#SQL（structure-query-language）：结构化查询语句" class="headerlink" title="SQL（structure query language）：结构化查询语句"></a>SQL（structure query language）：结构化查询语句</h3><ul><li>第一代：89</li><li>第二代：92（绝大部分数据库所遵循的规则）</li><li>第三代：99（没有成立）</li></ul><h4 id="DDL（data-definition-language）：数据库和数据表定义语言"><a href="#DDL（data-definition-language）：数据库和数据表定义语言" class="headerlink" title="DDL（data definition language）：数据库和数据表定义语言"></a>DDL（data definition language）：数据库和数据表定义语言</h4><ul><li>create<ul><li>database</li><li>table</li></ul></li><li>drop<ul><li>database</li><li>table</li></ul></li><li>alter（改变数据库的结构）<ul><li>table</li></ul></li></ul><h4 id="DML（data-manipulation-language）：数据处理语言"><a href="#DML（data-manipulation-language）：数据处理语言" class="headerlink" title="DML（data manipulation language）：数据处理语言"></a>DML（data manipulation language）：数据处理语言</h4><ul><li>select（查询）</li><li>insert [into]（添加）</li><li>delete（删除）</li><li>updata（单个属性的改变）</li></ul><h4 id="DCL（data-control-language）：数据库控制语言"><a href="#DCL（data-control-language）：数据库控制语言" class="headerlink" title="DCL（data control language）：数据库控制语言"></a>DCL（data control language）：数据库控制语言</h4><ul><li>grant（授权）</li><li>revoke（取消授权）</li></ul><h3 id="使用者"><a href="#使用者" class="headerlink" title="使用者"></a>使用者</h3><ul><li>DBO（database operater）</li><li>DBA（database administrator）：root/password</li></ul><h3 id="简单的结构"><a href="#简单的结构" class="headerlink" title="简单的结构"></a>简单的结构</h3><pre><code>DB Server（数据库服务器） DB（数据库）  table（数据表）   record（）    field     charset</code></pre><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol><li>链接数据库</li><li>use/create：database</li><li>create：table/改变资料表里面的数据</li></ol><h3 id="数据库操作方法"><a href="#数据库操作方法" class="headerlink" title="数据库操作方法"></a>数据库操作方法</h3><ul><li>通过程式（php）</li><li>通过命令行<ul><li>-u：使用者</li><li>-h：主机</li><li>-p：密码</li></ul></li><li>通过图形界面（软件）</li></ul><h3 id="PHP-amp-数据库"><a href="#PHP-amp-数据库" class="headerlink" title="PHP &amp; 数据库"></a>PHP &amp; 数据库</h3><h4 id="1-连接数据库"><a href="#1-连接数据库" class="headerlink" title="1. 连接数据库"></a>1. 连接数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$db = mysql_connect（数据库主机名称或ip,数据库账号,数据库密码）;</div><div class="line">      or die(&quot;无法连接数据库服务器&quot;);</div></pre></td></tr></table></figure><h4 id="2-使用数据库"><a href="#2-使用数据库" class="headerlink" title="2. 使用数据库"></a>2. 使用数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql_ select_db(名称,$db);</div><div class="line">    or die(&quot;无法连接数据库&quot;);</div></pre></td></tr></table></figure><h4 id="3-对数据进行操作"><a href="#3-对数据进行操作" class="headerlink" title="3. 对数据进行操作"></a>3. 对数据进行操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sql = &quot;(此处就是SQL指令)&quot;;</div></pre></td></tr></table></figure><h4 id="4-用变量对数据进行存取"><a href="#4-用变量对数据进行存取" class="headerlink" title="4. 用变量对数据进行存取"></a>4. 用变量对数据进行存取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$result = mysql_query($sql,$db);</div></pre></td></tr></table></figure><h4 id="5-最后关闭数据库"><a href="#5-最后关闭数据库" class="headerlink" title="5. 最后关闭数据库"></a>5. 最后关闭数据库</h4><blockquote><p>当取到数据的时候就可以关掉了，这样可以降低数据库风险。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql_close($db);</div></pre></td></tr></table></figure><h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><ul><li>sql指令可以大小写，但各种数据库名称和数据表名称要区别大小写。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是今天web课程的笔记，亲自尝试了前面两种验证方式，第三种方式之前也有所接触，还都算比较好理解。后面还有一些数据库的简单解释。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yangkunyi.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="PHP" scheme="http://yangkunyi.com/tags/PHP/"/>
    
      <category term="验证" scheme="http://yangkunyi.com/tags/%E9%AA%8C%E8%AF%81/"/>
    
      <category term="数据库" scheme="http://yangkunyi.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>坎帕斯学院讨论日常-2</title>
    <link href="http://yangkunyi.com/2017/12/03/%E5%9D%8E%E5%B8%95%E6%96%AF%E5%AD%A6%E9%99%A2%E6%97%A5%E5%B8%B8%E8%AE%A8%E8%AE%BA-2/"/>
    <id>http://yangkunyi.com/2017/12/03/坎帕斯学院日常讨论-2/</id>
    <published>2017-12-03T13:23:28.000Z</published>
    <updated>2017-12-03T13:25:19.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是第二次整理讨论的内容，本次内容有点深奥，值得细嚼慢咽。<br><a id="more"></a></p></blockquote><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul><li>高并发(High Concurrency)<ul><li>指通过设计保证系统能够同时并行处理很多请求。</li><li>是互联网分布式系统架构设计中必须考虑的因素之一。</li></ul></li><li>高性能(High performance)<ul><li>目前理解就是提高浏览网页的速度。</li></ul></li><li>高可用(High Availability)<ul><li>通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。</li></ul></li><li>高扩展性(High Extensibility)<ul><li>通常和可伸缩性混为一谈.在软件范畴上，是软件系统本身的属性，或者进一步说是设计的属性，代码的属性。 </li></ul></li><li>高可维护性(High Maintainability)<ul><li>是衡量一个系统的可修复(恢复)性和可改进性的难易程度。</li></ul></li></ul><h3 id="接口的高可用性"><a href="#接口的高可用性" class="headerlink" title="接口的高可用性"></a>接口的高可用性</h3><blockquote><p>保证这个接口在任何情况下都可以正确的取到数据。</p></blockquote><ul><li>方案一：每次访问的时候将a接口的数据存在本地，第二次访问的时候接口如果gg了，可以直接在本地获取数据，然后渲染出来；（前提是访问过a接口）</li><li>方案二：推oss或者cdn；每次访问了一个接口，然后服务器把返回的数据生成文件推送到一个静态资源服务器上去；<ul><li>好处：比如某人访问了接口，静态资源服务器就会缓存a里面的数据，这时候gg了，其他人依然可以请求到oss上的数据；（逻辑是前端做到的，但是数据推到oss上是从后台推上去的）</li><li>oss几乎不可能gg，原因是它只是一个静态资源存储的地方；</li></ul></li><li>默认数据：（假数据）当接口不可用的时候，用这个自己做的数据；</li></ul><blockquote><p>目前企业的解决方案是：先走服务器接口，若是gg了；再访问本地缓存；若没有，则访问oss。</p></blockquote><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><ul><li>优点：<ul><li>如果第一次没有访问对应的接口就没有本地缓存；</li><li>数据的时效性不够；</li></ul></li><li>缺点：<ul><li>快，不用通过网络请求；</li></ul></li></ul><h4 id="缓存地点"><a href="#缓存地点" class="headerlink" title="缓存地点"></a>缓存地点</h4><ul><li>缓存类型：<ul><li><code>sessionStorage</code>：只在当次回话有效，不会带到每一个请求里面去；</li><li><code>indexDB</code>：浏览器支持度很低，也就是说兼容问题很大；</li><li><code>cookie</code>：过期时间可以设置，默认是浏览器当期回话结束失效；cookie很小；每次对应域名是会在每个请求头带过去，浪费资源，所以限制了大小，如果不限制，就会跟上传文件没有区别了，会导致特别慢；对于数据接口，我们不能保证内容有多大，而且每个接口数据都要缓存，所以不能用cookie。</li><li><code>localstorage</code>：没有大小限制；</li></ul></li></ul><blockquote><p>以上都属于这两种类型：</p><ol><li>（私有）浏览器缓存：单个用户，你浏览过的页面浏览器缓存起来。</li><li>（共享）代理缓存：多个用户，所在公司自己架构的，减少网络拥堵与延迟。</li></ol></blockquote><h3 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h3><h4 id="浏览器请求一个资源，是怎么判断取缓存还是找服务器下载？"><a href="#浏览器请求一个资源，是怎么判断取缓存还是找服务器下载？" class="headerlink" title="浏览器请求一个资源，是怎么判断取缓存还是找服务器下载？"></a>浏览器请求一个资源，是怎么判断取缓存还是找服务器下载？</h4><p><img src="http://otn4ut2th.bkt.clouddn.com/blog201211281402438011.png" alt="浏览器缓存"></p><h4 id="状态码304是怎么产生的？"><a href="#状态码304是怎么产生的？" class="headerlink" title="状态码304是怎么产生的？"></a>状态码304是怎么产生的？</h4><ul><li>是因为本地文件设置的信息头部过期了，去服务器拉取，然后服务器告诉我，其实你的文件还尚未过期，让你回自己本地取资源；</li></ul><h4 id="状态码200（from-cache）是怎么产生的？"><a href="#状态码200（from-cache）是怎么产生的？" class="headerlink" title="状态码200（from cache）是怎么产生的？"></a>状态码200（from cache）是怎么产生的？</h4><ul><li>一定是通过了请求并且成功然后返回的状态码，方式<code>get</code>或者<code>post</code>。</li></ul><blockquote><p>以上的问题只是有所了解了，但是关于浏览器的缓存机制还没有系统的了解，自己在看官方文档的时候，感觉有点困惑，所以先在这里埋个种子。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是第二次整理讨论的内容，本次内容有点深奥，值得细嚼慢咽。&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yangkunyi.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="问题" scheme="http://yangkunyi.com/tags/%E9%97%AE%E9%A2%98/"/>
    
      <category term="讨论" scheme="http://yangkunyi.com/tags/%E8%AE%A8%E8%AE%BA/"/>
    
      <category term="浏览器缓存" scheme="http://yangkunyi.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    
      <category term="状态码" scheme="http://yangkunyi.com/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>WeeklyMind-2</title>
    <link href="http://yangkunyi.com/2017/12/02/WeeklyMind-2/"/>
    <id>http://yangkunyi.com/2017/12/02/WeeklyMind-2/</id>
    <published>2017-12-02T04:29:09.000Z</published>
    <updated>2017-12-02T06:43:47.499Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>忙碌的一周，这都是浪三天的后遗症。上周的周记都在浪中忘记了，但是心情还是很开心的。</p></blockquote><a id="more"></a><h3 id="总结上两周"><a href="#总结上两周" class="headerlink" title="总结上两周"></a>总结上两周</h3><h5 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h5><blockquote><p>期中考试和报告全部完成，成绩一般，接下来又要开始准备期末考试了，来台湾三个月了，自己也在想这一趟来的值不值。</p></blockquote><ul><li><p>课程：</p><ul><li>突然对不动产的作业很是上心，希望在同学和老师们面前不丢咱大陆学生的脸</li><li>为了行销管理的期中报告，自己也算是呕心沥血了，希望不要太差</li><li>西方哲学到康德部分，开始有点抽象到不懂了，还是知识面太狭窄了</li><li>财务管理课程让自己彻底对经融课程失望了，自己是真的不适合学习，修这门课都当作了解吧</li><li>突然觉得人际交往是一门很重要的课程，既认识了自己，也认识了别人</li><li>这两个周因为中间的各种考试和报告，时间有点混乱，所以接下来应该好好计划</li></ul></li><li><p>其它</p><ul><li>http缓存机制的了解，周末希望能理解完</li><li>继续学习了php</li><li>了解php架构包中如何建wordpress以及评论板块（但是发现自己对数据库的认识还不够，导致在尝试过程中老是出现问题）</li></ul></li></ul><h5 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h5><blockquote><p>上个周末算是很精彩了，一趟三天两夜的旅行回来，也导致了博客的的各种托更。</p></blockquote><ul><li><p>台南：</p><ul><li>赤崁楼</li><li>安平古堡</li><li>安平树屋</li><li>安平老街</li></ul></li><li><p>高雄</p><ul><li>夜市</li><li>爱河</li><li>真爱码头</li><li>西子湾</li><li>中山大学</li></ul></li></ul><p>也算是见过真正的浪了！</p><h5 id="待更进事项"><a href="#待更进事项" class="headerlink" title="待更进事项"></a>待更进事项</h5><ul><li>12月计划</li><li>微信订阅号</li><li>各种作业</li><li>前端书籍（每天给点时间来做，积累最重要）</li></ul><blockquote><p>今年的最后一个月，完成你年初的计划可好，少年！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;忙碌的一周，这都是浪三天的后遗症。上周的周记都在浪中忘记了，但是心情还是很开心的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="周记" scheme="http://yangkunyi.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>WeeklyMind-1</title>
    <link href="http://yangkunyi.com/2017/11/19/WeeklyMind-1/"/>
    <id>http://yangkunyi.com/2017/11/19/WeeklyMind-1/</id>
    <published>2017-11-19T06:11:30.000Z</published>
    <updated>2017-12-02T06:43:35.669Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>寻常的一周，不过做了许多的决定，之后每一周也希望自己能坚持做一下简单的总结。</p></blockquote><a id="more"></a><h3 id="总结上周"><a href="#总结上周" class="headerlink" title="总结上周"></a>总结上周</h3><h4 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h4><ul><li>新买的T恤很喜欢</li><li>吃得很随便，但不失营养，老年人一样的生活，哈哈哈</li><li>住的寝室，还是比较宅，之后希望有时间，还是多出去走走看看</li><li>这周没怎么出门，最近在准备各种考试和期中报告</li></ul><h4 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h4><ul><li><p>课程：</p><ul><li>人际考试</li><li>周三运动会放假</li><li>复习财管</li><li>其它课程一切照常进行</li><li>完成日常作业</li></ul></li><li><p>其它</p><ul><li>申请和绑定了域名</li><li>博客主题修改</li><li>了解nodeppt</li><li>简单的看了一下网易云api（有准备做一个音乐播放器）</li></ul></li></ul><h2 id="待更进事项"><a href="#待更进事项" class="headerlink" title="待更进事项"></a>待更进事项</h2><ul><li>复习财管（周三考试）</li><li>电商案例分析</li><li>人际期中报告</li><li>不动产课堂报告</li><li>课程小节论文</li><li>通信英语ppt</li><li>继续学习php</li><li>更新博客</li><li>日常作业</li></ul><blockquote><p>最后还有锻炼，这个事情还是比较重要的。按照自己的计划腾出锻炼的时间，保持健康，毕竟在这个遥远的地方没有买保险。。。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;寻常的一周，不过做了许多的决定，之后每一周也希望自己能坚持做一下简单的总结。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="周记" scheme="http://yangkunyi.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
</feed>
