<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨坤怡</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yangkunyi.com/"/>
  <updated>2018-01-07T15:40:00.538Z</updated>
  <id>http://yangkunyi.com/</id>
  
  <author>
    <name>杨坤怡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WeeklyMind-7</title>
    <link href="http://yangkunyi.com/2018/01/07/WeeklyMind-7/"/>
    <id>http://yangkunyi.com/2018/01/07/WeeklyMind-7/</id>
    <published>2018-01-07T15:39:16.000Z</published>
    <updated>2018-01-07T15:40:00.538Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>期末周真的很崩溃，赶各种报告，还要复习，命天要考不动产管理和西方哲学史，不动产管理自己都快要放弃了，今天下午又整理出而是页pdf的知识点，也是选择随缘了，反正这个周就是很忙碌就对了，为了复习自己周末都去图书馆了，真实不敢相信！！！</p></blockquote><a id="more"></a><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul><li>web网页程序设计已经结课了，这个对有基础的自己来说，不难，也没有担心什么，成绩也在自己的规划之中。</li><li>行销管理的报告初步形态也基本完成，明天早起去把名片打印出来就行了。</li><li>再来是明天要考试的两门，脑子已经不够用了！</li><li>周三的财务管理也算复习了三个单元了，但还是不算有底，主要是有一个数据不会算！！！这个问题要在明天和后天晚上的时间里面解决了。</li><li>最后周四还有一门课堂的期末报告，不过时间还够，所以不用太担心。</li><li>还有就是自己的博客有改一些个性化设置，更新了主题。</li></ul><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul><li>明明前两天都还是清空万里，到考试就大雨滂沱，自己不太喜欢雨天，所以有点点影响心情吧。</li><li>这个周都睡得比较晚，生物钟感觉都已经变了，不过自己也能接受。</li><li>其实就是很普通的一个周，所以自己也想不起太多想写的东西。</li></ul><h2 id="待更进事项"><a href="#待更进事项" class="headerlink" title="待更进事项"></a>待更进事项</h2><ul><li>走之前给自己写一封信</li><li>走之前给家里写一封信</li><li>思想报告</li><li>期末报告</li><li>联系老师商量考试安排</li></ul><blockquote><p>今天雨，可是我们在一起</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;期末周真的很崩溃，赶各种报告，还要复习，命天要考不动产管理和西方哲学史，不动产管理自己都快要放弃了，今天下午又整理出而是页pdf的知识点，也是选择随缘了，反正这个周就是很忙碌就对了，为了复习自己周末都去图书馆了，真实不敢相信！！！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="周记" scheme="http://yangkunyi.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>西方哲学史期末复习</title>
    <link href="http://yangkunyi.com/2018/01/07/%E8%A5%BF%E6%96%B9%E5%93%B2%E5%AD%A6%E5%8F%B2%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yangkunyi.com/2018/01/07/西方哲学史期末复习/</id>
    <published>2018-01-07T15:22:08.000Z</published>
    <updated>2018-01-07T15:26:13.213Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>明天期末考试，今天下午整理出来的复习资料，这还只是后半学期的，简直要疯了，最后还是佛系的选择随缘了！</p></blockquote><a id="more"></a><h2 id="柏克莱"><a href="#柏克莱" class="headerlink" title="柏克莱"></a>柏克莱</h2><h3 id="著作"><a href="#著作" class="headerlink" title="著作"></a>著作</h3><ul><li>《视觉新论》（Essay towards a New Theory of Vision,1709）</li><li>《人类知识原理》（A Treatise concerning the Princeples of Human Knowledge,1710）</li><li>《西利斯和斐罗诺斯得三篇对话》（Three Dialogues between Hylas and Phlionus,1713）</li></ul><h3 id="存在就是被感知（柏克莱）"><a href="#存在就是被感知（柏克莱）" class="headerlink" title="存在就是被感知（柏克莱）"></a>存在就是被感知（柏克莱）</h3><blockquote><p>一切物体的存在都离不开能感知它们的心灵或者说存在于心灵之中。</p></blockquote><ul><li>贝克莱的命题。他站在经验论的立场上，对外物的存在不做断定，认为存在就是观念的存在，而观念的存在，就是观念的感知和被感知，即使没有人感知事物的存在，上帝的心灵也会感知它。从而否认了物质概念的实在性，承认了上帝的存在。</li><li>贝克莱的这一命题是肯定外物客观实在性的基本观点。按照这个命题，根本不存在任何独立于感觉观念的事物，所谓事物无非是被“心灵”实体感知的一组观念，事物和观念是同一个东西，它们的存在只在于被心灵所感知，这夸大经验中的观念，从而陷入了主观唯心主义。</li><li>像洛克一样，贝克莱认为人类知识的对象就是“观念”，而无论哪一种观念都只存在于能感知的能动的实体即心灵之中。换言之，认识的对象是观念，观念只存在于心灵之中，它们不可能离开心灵而独立存在，因此观念的存在就在于被感知。</li><li>既然观念的存在就在于被感知，那就意味着感觉事物的存在就在于被感知，因而一切事物的存在就在于被感知。因为“具有一个观念与感知一个概念是一回事”，“事实上，对象和感觉是一种东西”。所以，事物的存在就是被感知。</li><li>存在就是被感知在贝克莱那里是逻辑地从“物是观念的集合”这一命题中推演出来的。</li></ul><h2 id="休谟（David-Hume）"><a href="#休谟（David-Hume）" class="headerlink" title="休谟（David Hume）"></a>休谟（David Hume）</h2><h3 id="经验主义认识论：观念与印象"><a href="#经验主义认识论：观念与印象" class="headerlink" title="经验主义认识论：观念与印象"></a>经验主义认识论：观念与印象</h3><h4 id="1-认识的起源：表象的分类"><a href="#1-认识的起源：表象的分类" class="headerlink" title="1. 认识的起源：表象的分类"></a>1. 认识的起源：表象的分类</h4><ul><li>印象：强烈而活跃的直觉<ul><li>对外：直接的感性直觉，如视觉、听觉</li><li>对内：直接的心里经验，如愤恨、喜悦</li></ul></li><li>观念：基于先有印象然后产生的心里图像，念的产生有可能经过我们的组合和排序</li></ul><h4 id="2-知识的边界在于观念能过回归印象"><a href="#2-知识的边界在于观念能过回归印象" class="headerlink" title="2. 知识的边界在于观念能过回归印象"></a>2. 知识的边界在于观念能过回归印象</h4><h3 id="可能的知识范围"><a href="#可能的知识范围" class="headerlink" title="可能的知识范围"></a>可能的知识范围</h3><h4 id="1-经验主义只承认有两类知识"><a href="#1-经验主义只承认有两类知识" class="headerlink" title="1. 经验主义只承认有两类知识"></a>1. 经验主义只承认有两类知识</h4><ul><li>经验知识：建立于感性知觉基础上</li><li>数学与逻辑等知识：建立于概念关系的约定规则的基础之上的知识</li></ul><h4 id="2-无法经验的东西"><a href="#2-无法经验的东西" class="headerlink" title="2. 无法经验的东西"></a>2. 无法经验的东西</h4><ul><li>无法经验的动心，又不仅是涉及我们（主体之间）约定上的概念规则的话，则不可能有知识，例如关于上帝和所谓客观规则。</li><li>所以：数学观念对实际存在没有说服力（它们是分析的），反之，经验科学的观念对实在有说服力，他们是综合的。</li></ul><h3 id="休谟的激进经验主义"><a href="#休谟的激进经验主义" class="headerlink" title="休谟的激进经验主义"></a>休谟的激进经验主义</h3><ul><li>我们只经验到不同的感觉印象，却没有什么背后的「实体」，去「承载」这些印象。</li><li>这些感觉印象会以恒常群组的方式出现，我们所说的桌子、椅子，不过就是这些群组本身──而不是背后的什么东西！</li><li>同样，我能把握的仅仅内部印象，当中有些恒常稳定成出现，但幻想背后有一「自我」，实是形而上学幻觉，一种习惯的联想</li></ul><h3 id="休谟的知觉"><a href="#休谟的知觉" class="headerlink" title="休谟的知觉"></a>休谟的知觉</h3><blockquote><p>现代哲学一般接受某种观念理论 (theory of ideas)：认为思想直接对象的是某种心灵之内项目或观念，而不是外在的物理客观。休姆统称观念之为「知觉」(perceptions)。</p></blockquote><ul><li>印象：包括各类感觉 (sensations)，也包含欲望 (desires)、情感 (passions)、情绪 (emotions) 等。</li><li>观念：则是印象「在思想与推理中的模糊影像 (faint images)」。</li><li><strong>观念和印象的关系：摹本原则（简单印象总是先于简单观念）</strong></li></ul><blockquote><p>因为感受 (feeling) 与思想 (thinking) 的差别是清晰的，故此印象与观念之分别亦然。(例当下吃柠檬塔的味觉 vs 记得上周吃过的味道)。</p></blockquote><h4 id="印象"><a href="#印象" class="headerlink" title="印象"></a>印象</h4><ul><li>感觉印象：感觉印象或称为「原初印象」 (original impressions) 。它们包括通过五官而得到各种感觉，以及痛感与快感 (pains and pleasures)。它们之所以称为「原初」，是因为它们是思考不可再回溯的始点，要再探究它们的原因，我们便会跨出经验以外。</li><li>反思印象：反思印象则包括欲望、情绪、情感等等。本质上，它们是心灵对于观念之反应，故此对比于原初印象，休姆称之为第二序印象。例如：对于去年患感冒的记忆是观念，它是去年的原初印象 (患流感的感觉)之影像。此时记起这段记忆，让你感到「害怕」 这年秋冬还会患上流感、「希望」不会再患上流感，等等。</li></ul><h4 id="观念之间的关系"><a href="#观念之间的关系" class="headerlink" title="观念之间的关系"></a>观念之间的关系</h4><blockquote><p><strong>联想关系</strong></p></blockquote><ul><li>思想内容的心理连结，一者引起我想到另一者。</li><li>休姆自许为首位对「联想原则」作系统分类的哲学家。</li><li>分三类联想：<ul><li>(1) 相似 (resemblance)；</li><li>(2) 时空连续 (contiguity in  space and time)；</li><li>(3) 因果 (causation) 。</li></ul></li><li>例子：<ul><li>(1) 画作及其所描绘的主题实物；</li><li>(2) 提及房子的大门入口，想起它的玄关；</li><li>(3) 想到一个伤口，想起它带来的疼痛感。</li></ul></li></ul><h4 id="知觉分类"><a href="#知觉分类" class="headerlink" title="知觉分类"></a>知觉分类</h4><ul><li>简单的：黄、酸、香味，等等。</li><li>复合的：复合印象由简单印象组成，例如「柠檬」的印象 = 黄 + 酸 + 柠檬香味，等等。这些个别的印象是简单印象，因为它们没有组成部份。</li></ul><blockquote><p>印象与观念之别在于力度 (degree of force)或活泼度 (degree of vivacity)。印象比观念更有力、更鲜明与活泼。(休姆没有完全满意这个区分的规定方式)</p></blockquote><h3 id="休谟对因果论的批判"><a href="#休谟对因果论的批判" class="headerlink" title="休谟对因果论的批判"></a>休谟对因果论的批判</h3><ul><li>休谟指出，当我们讨论因果时，我们认为：<ul><li>某现象随另一现象而来。→ 相继性</li><li>两个现象间有接触。→ 接触性</li><li>随接触而来的现象必然发生。→ 必然性</li></ul></li><li>但我们能否真的知道上述3点？<ul><li>休谟：我们能知道1 与 2，但不能知道 3！</li></ul></li></ul><h3 id="对因果论批判的回应"><a href="#对因果论批判的回应" class="headerlink" title="对因果论批判的回应"></a>对因果论批判的回应</h3><ul><li>我们透过归纳法，一再重复的现象关系，使我们可推论出因果关系。</li><li>休谟：只能知道迄今现象关系确是如此，不能说我们知道其确是如此，而且将会如此。</li><li>归纳法与自然科学过往成功显示这类推论有效而可堪继续使用。</li><li>休谟：此论诉诸自然齐一观，但自然齐一若非归纳，便为形上假设。</li><li>若非出于归纳推论，因果概念从何而来？</li><li>休谟：因果概念不过是我们的心理习惯或心理预期。</li></ul><h2 id="康德"><a href="#康德" class="headerlink" title="康德"></a>康德</h2><h3 id="著作-1"><a href="#著作-1" class="headerlink" title="著作"></a>著作</h3><ul><li>《纯粹理性批判》(Critique of Pure Reason, 1781, 第2版 1787)</li><li>《未来形而上学导论》(Prolegomena to Any Future Metaphysics, 1783)</li><li>《道德形而上学原理》(Groundwork of the Metaphysics of Morals, 1785)</li><li>《实践理性批判》(Critique of Practical Reason, 1788)</li><li>《判断力批判》(Critique of Judgement) Pure Reason, 1790)</li><li>《单在理性范围内的宗教》(Religion within the Limits of Reason Alone, 1793) </li><li>〈永久和平论〉(“Perpetual Peace”, 1795)</li></ul><h3 id="康德哲学的定位"><a href="#康德哲学的定位" class="headerlink" title="康德哲学的定位"></a>康德哲学的定位</h3><blockquote><p>一般定位：启蒙运动的哲学代表，理性主义与经验主义的集大定者。</p></blockquote><ul><li>理性主义的立场：<ul><li>心灵拥有天赋观念 (innate ideas)。</li><li>只需以理性分析与思想相关的观念，我们便可掌握世界之真相(至少关于最重大议题之真相，例如灵魂是否不朽，上帝是否存在，意志是否自由等等)。</li><li>以数学、逻辑为知识典范</li><li>代表人物: Descartes, Spinoza, Leibniz</li></ul></li><li>经验主义的立场：<ul><li>并无所谓天赋观念，一切观念皆经由经验习得，人的心灵是生而如「白纸」(tabula rasa)，不存在先有的蓝图、内容或架构。</li><li>一切知识，皆来自经验；知识之建立有赖于有方法地对自然进行考察。</li><li>以自然科学为知识典范</li><li>代表人物： Locke, Berkeley, Hume</li></ul></li></ul><h3 id="批判（康德）"><a href="#批判（康德）" class="headerlink" title="批判（康德）"></a><strong>批判（康德）</strong></h3><ul><li><p>康德的批判是指：根据理性具有普遍必然的科学知识对理性的一般认识能力进行分析，通过分析来确立一种衡量知识是否科学知识的一般标准，然后以此来衡量形而上学的命运。在当时，批判的含义首先是针对莱布尼兹-沃尔夫体系提出的，其次，它还要通过对不依赖经验因素的纯粹理性的批判，为数学、自然科学提供哲学论证，同时又限制理性的活动范围，为宗教信仰保留地盘。</p></li><li><p>（PPT）所谓「批判」不是指单纯的「批评」(criticism)，而是指：</p><ul><li>(1) 限制、划定界限论域的有效范围；</li><li>(2) 有别于对论域有效性的「朴素」(naively)接受，对其进行反思，阐释其构成原则。</li></ul></li></ul><h3 id="判断上的线索"><a href="#判断上的线索" class="headerlink" title="判断上的线索"></a>判断上的线索</h3><ul><li>给定了完整具体的经验是命题性的，那么，表达命题的判断即可成为探索经验超验条件的线索，包括：先验综合判断的线索<ul><li>综合判断 vs. 分析判断 (主谓概念的分析与非分析的关系──「清华大学男多女少」vs. 「三角形有三只角」)</li><li>经验综命判断 vs. 先验综合判断</li><li>先验综合判断的例子：「两点之间最短者为直线」、「凡变化均有原因」</li></ul></li><li>非经验字词的线索 (例如「有些」、「和」、「或者」)</li><li>判断逻辑形式的线索 ( “S is  P” 的量、质、模态与关系的可能变化)</li></ul><h4 id="简述康德的“先天综合判断”理论。"><a href="#简述康德的“先天综合判断”理论。" class="headerlink" title="简述康德的“先天综合判断”理论。"></a>简述康德的“先天综合判断”理论。</h4><ul><li>康德为了解决经验知识的普遍必然性问题而提出了“先天综合判断”理论。康德认为，知识的基本单位是判断，一种是分析判断，一种是综合判断。分析判断的宾词蕴含在主词当中，具有普遍必然性，但不能给我们提供新的知识，经验知识属于综合判断，宾词不包含在主词中。具有普遍必然性的经验知识必有两个来源：感官提供的后天质料和头脑中固有的先天认识形式。具有这种特征的判断称为先天综合判断。先天综合判断的命题可以分为三类：数学命题、自然科学命题、形而上学命题。</li></ul><h3 id="超越"><a href="#超越" class="headerlink" title="超越"></a>超越</h3><ul><li>「超越」与「经验」相对，指关于经验可能性的先验条件(超越哲学即关于这些条件之严格学问)。</li></ul><h3 id="康德的哥白尼转向"><a href="#康德的哥白尼转向" class="headerlink" title="康德的哥白尼转向"></a>康德的哥白尼转向</h3><ul><li>自然科学的哥白尼革命：从地心说转向日心说。</li><li>康德哲学的哥白尼革命：从表象实在论 (representational realism) 到转移超验论 (transcendentalism)<ul><li>表象实在论：认知主体受客体影响而产生表象，进而产生对象性知识 (观念)。</li><li>超验论：客体是因为经受主体先行的安排与整顿，方能树立为对象性，故此对象依赖于主体的经验与思维方式。</li></ul></li></ul><h3 id="康德-VS-休谟"><a href="#康德-VS-休谟" class="headerlink" title="康德 VS 休谟"></a>康德 VS 休谟</h3><ul><li>休姆的正确洞见：知识起源于经验，而单是感性经验的管道本身无法提供「必然而普遍有效东西」；诉诸个殊感性所接收的内容无法说明因果性。</li><li>休姆的错谬：因为感性经验管道无法说明因果的来源，故此因果性无客观有效性，只是主观的心理习惯。</li><li>休姆的假设：经验只是零散的、无秩序的材料之累积和收集而已。</li><li>康德：经验一旦发生，便总已具有普遍有效的秩序；经验是「命题性」的。(我们的知觉经验所相对的是事物、对象，以至整全的事态，而并非在一堆零散的「杂多讯息」之堆积。)</li></ul><h3 id="超越的三性"><a href="#超越的三性" class="headerlink" title="超越的三性"></a>超越的三性</h3><blockquote><p>康德的超越论的设定：这些既存于经验的秩序是由认知主体的不同机能所赋予，这些机能包括：(1) 感性 (sensibility)；(2) 知性 (understanding)；(3) 理性 (reason)。</p></blockquote><h4 id="感性（康德）"><a href="#感性（康德）" class="headerlink" title="感性（康德）"></a><strong>感性（康德）</strong></h4><ul><li>感性是指主体自我借助于感性经验而形成的感性直观知识的先天认识能力，包括两个方面，一是经验直观，一是纯直观。前者是后天的质料，后者是先天的形式。感性的先天形式是空间和时间，感性与感觉经验结合后形成数学知识。</li></ul><h4 id="知性（康德）"><a href="#知性（康德）" class="headerlink" title="知性（康德）"></a><strong>知性（康德）</strong></h4><ul><li>知性是指主体自我对感性对象进行思维，把特殊、没有联系的感性对象加以综合，并且联结成为有规律的自然科学知识的先天认识能力。知性的先天认识形式是知性纯概念，即“范畴”。用这些范畴把感性知识结合起来，使其具有一定的形式，成为知识。知性与感觉经验结合形成自然科学知识。</li></ul><h4 id="理性（康德）"><a href="#理性（康德）" class="headerlink" title="理性（康德）"></a><strong>理性（康德）</strong></h4><ul><li>理性指在经验中无法达到的知识的完备性和无条件性，即要求认识世界、灵魂和上帝的认识能力。理性是认识的最高阶段，要求认识自在之物本身，获得关于世界的绝对认识，即理念。但是理性自身没有先天形式，只能借用知性范畴。但用认识有限对象的知性范畴去把握无限对象，理性必然陷入不可解决的矛盾，因此形而上学是不可能的。</li></ul><h3 id="超越的演绎"><a href="#超越的演绎" class="headerlink" title="超越的演绎"></a>超越的演绎</h3><ul><li>「超越的演绎」(transcendental deduction) 的目标是透过阐明感性的直观形式和知性的先验范畴构成对象性经验的程序，显示这些先验条件的有效性。这个程序涉及三个层次的综合：<ul><li>a)    直观之统握 (Apprehension in der Anschauung; Apprehension in the Intuition)：初步赋予感性摄取回来的杂多资料一个时空秩序的形式，如时间上的共时与相续。</li><li>b)    想象力的再造 (Reproduktion in der Einbildung; Reproduction in the Imagination)：将直观逐一经历者重新呈现，并使之合成为一个统一的「意象」。</li><li>c)    知性概念之重认 (Rekognition im Begriff; Recognition in the Concept)：依据先验概念，将已被直观统握和想象力再造的杂多，确认之为某物的表象。</li></ul></li></ul><blockquote><p>超越演绎描述的是一个互相协调下的广义思考活动，背后统一的思考者即某个超越的、形式性的、主动的「我」(I)，称为超越统觉 (transcendental apperception)。康德认为，正因为我的所有经验皆过此超越的我之统觉思考，故「我思」总是能够伴随着一切我的表象的。</p></blockquote><h3 id="知识的消极批判：有效知识的限度"><a href="#知识的消极批判：有效知识的限度" class="headerlink" title="知识的消极批判：有效知识的限度"></a>知识的消极批判：有效知识的限度</h3><ul><li>现象学 (phenomenon) 与物自身 (thing in itself) (或「智思物」(noumenon))的区分。</li><li>具体判准：现象为知性(概念)与感性(直观)协作而成；任何无法感性直观给予的对象，我们对之皆无法建立积极的知识。</li><li>二律背反(antinomy)及独断形上学的谬误。例如「世界是有限/无限」；「自然因果性以外还有自由的因果性/ 自然因果性通贯决定一切」。</li></ul><h4 id="二律背反-antinomy"><a href="#二律背反-antinomy" class="headerlink" title="二律背反 (antinomy)"></a>二律背反 (antinomy)</h4><ul><li>显示独断的形上学是不一致的，因为它们涉及一些超出感性经验以外的事情。</li><li>二律背反的积极价值：时空实在只是现象，自由即使不容于现象，也不代表它不能是某种实在。</li></ul><h4 id="经验的实在论-empirical-realism"><a href="#经验的实在论-empirical-realism" class="headerlink" title="经验的实在论 (empirical realism)"></a>经验的实在论 (empirical realism)</h4><ul><li><p>：对于可直观呈现的经验对象来说，时空、范畴等先验条件皆为构成「实在」的一环。</p><h4 id="超越的观念论-transcendental-idealism"><a href="#超越的观念论-transcendental-idealism" class="headerlink" title="超越的观念论 (transcendental idealism)"></a>超越的观念论 (transcendental idealism)</h4></li><li><p>对于无法直观的、超离于感性经验以外的事物来说，时空、范畴等不过是观念 (一些虚的想法)，我们无法针对它们建立积极的知识。</p></li></ul><h3 id="伦理学"><a href="#伦理学" class="headerlink" title="伦理学"></a>伦理学</h3><h4 id="理性主义-VS-经验主义"><a href="#理性主义-VS-经验主义" class="headerlink" title="理性主义 VS 经验主义"></a>理性主义 VS 经验主义</h4><ul><li>理性主义：有些根本的道德观念和原则是天赋或先验的，我们可透过理性反省来掌握它们──就如我们可以透过理性反省我们的推理行为，而获得一些先验而普遍有效的逻辑观念与逻辑原则。</li><li>经验主义反之认为，道德只是偶然的人性与欲望的产物，例如Hume 认为，道德是基于同情共感 (同情心)，而同情心是人性偶然的产物，若人性不同，人便可能有不同的欲望与感情，由此也会有不同的道德原则。道德原则只是偶然的经验原则，而理性只是满足欲望与情感的手段。(理性是也应是情感的奴隶！)</li></ul><h4 id="康德伦理学立场"><a href="#康德伦理学立场" class="headerlink" title="康德伦理学立场"></a>康德伦理学立场</h4><ul><li>道德之基础是理性而非偶然的人性欲望与情感，道德原则是必然而非偶然的。否则无法解释道德的特殊规范力：它对所有理性存在者之行为皆普遍有效。(我们不但要求人应当公正、诚实、尊重他人、保护弱者，等等，而是任何有理性者皆当如此！)</li><li>当然，道德也需实践，但要策动实践道德原则之行为，我们所依赖的不是偶然的欲望，而是理性的意志。</li><li>针对道德领域，超验哲学的反思要阐明的是：纯粹理性自身如何可能是实践的。</li></ul><h4 id="实践理性与道德原则"><a href="#实践理性与道德原则" class="headerlink" title="实践理性与道德原则"></a>实践理性与道德原则</h4><blockquote><p>对于康德来说，人类实践之理性表现在于它是在法则意识下的行动。(依法则行动 vs. 依法则表象而行动)<br>有限实践理性与道德规范力或强制力：义务 (Duty, Pflicht) 的优先性。</p></blockquote><ul><li>令式与两种应该：<ul><li>假言令式</li><li><ul><li>如果要减肥，你就不应该在晚上吃很多。</li></ul></li><li>定言令式</li><li><ul><li>不应该滥杀无辜。</li></ul></li></ul></li></ul><blockquote><p>康德认为，真实的道德是为道德而道德，或为义务而义务，故其相应的令式为定言令式。</p></blockquote><h4 id="道德原则即为可普遍化原则"><a href="#道德原则即为可普遍化原则" class="headerlink" title="道德原则即为可普遍化原则"></a>道德原则即为可普遍化原则</h4><ul><li>康德认为是有的，他同样也称之为定然令式(狭义)。</li><li>康德对之有几组不同的表述，其中一组强调普遍化，为了辨识之故，我们可以称之为「普遍化原则」(Principle of Universalization)：</li><li>「仅据如此格准 (maxim) 行动，即你能同时意愿之成为普遍遍法则。」</li><li>(「格准」是康德的术语，意指主观的行动原则。)</li><li><p>「可普遍化」这个判准告诉我们甚么可以做(道德上容许的)，甚么不可以做。</p></li><li><p>栗子：</p><ul><li>许假承诺（自我矛盾，因为之所以许诺就是为了未来能够达成）</li><li>即使有能力，也不要帮助他人（意志上的矛盾）</li></ul></li></ul><h4 id="普遍化原则所表达的道德观念"><a href="#普遍化原则所表达的道德观念" class="headerlink" title="普遍化原则所表达的道德观念"></a>普遍化原则所表达的道德观念</h4><ul><li>道德上对的行为，即某意义上合理的行为。</li><li>理性的特征是普遍的，在道德上合理，即行为在某意义上是可以普遍化的。</li><li>为此，我们要检讨某个行为是否道德上正确与否，便应建立一套程序，显示如何可在普遍的观点下考察该行为，并尝试阐明，符合什么特征时，该行为才是合理的。</li><li>检测流程：<ul><li>第一阶段：主观原则（陈述行动背后的标准）</li><li><ul><li>栗子：每当我需要的时候，我就许假承诺。</li></ul></li><li>第二阶段：陈述行动的客观原则</li><li><ul><li>栗子：每当任何人有需要的时候他们都许假承诺。</li></ul></li><li>第三阶段：按能否普遍化或其它标准，判定行动在道德上是否允许。</li></ul></li></ul><h4 id="对普遍化原则的批判"><a href="#对普遍化原则的批判" class="headerlink" title="对普遍化原则的批判"></a>对普遍化原则的批判</h4><ul><li>Anscombe 的反驳 ：只要加上恰当的条件，说谎便可容许，例如，「若旨在拯救无辜，说谎也无妨」以乎可以普遍化。</li><li>回应：我们无法肯定知道行动的结果──例如以为说谎可救忠良，免其受暴政追捕，但却有可能阴差阳错，导致无辜者陷入罗网──，但却肯定知道行动有无违反义务。故此，我们理当行其义不计其功，避免因任何后果计算，违反已知的道德义务。康德认为，既行其义，我们便以尽了自己的责任，致于行动后果是否美好，也不是我们的过错。(因为此点其实我们无法肯定的)。</li><li>Rachels 的反驳：康德认为，我们须为说谎行为的坏结果负责(例如误让无辜者被捕)，但却不需要为说真话的坏后果负责？──这并不合理。</li></ul><h4 id="三个表达式"><a href="#三个表达式" class="headerlink" title="三个表达式"></a>三个表达式</h4><ul><li>自然法则原则 (Principle of the Law of Nature)：「如此行动，宛如藉由你的意志，你的行动格准变成普遍的自然法则。」</li><li>目的原则 (Principle of Ends)：「如此行动，致使无论是在你自身人格中的或是其他人的人格中的人性，皆被当作目的而非仅当作手段 (means) 看待。」</li><li>自律原则 (Principle of Autonomy)：「如此行动，致使你的意志藉由自身的格准，能够同时自视为在制订普遍法则。」</li></ul><h4 id="道德行动的预设"><a href="#道德行动的预设" class="headerlink" title="道德行动的预设"></a>道德行动的预设</h4><blockquote><p>道德行动有三个设准 (预设)(postulate)，这些设准之实在性不能被证明，但却对实践生活极为重要：</p></blockquote><ul><li>自由意志：「意志独立于任何东西，而仅仅遵从道德法则」→ 自由意志是「拱心石」。</li><li>灵魂不朽：实现 summum bonum 至善即德福一致的预设。</li><li>上帝：实现 summum bonum 至善即德福一致的预设。</li></ul><h3 id="美学"><a href="#美学" class="headerlink" title="美学"></a>美学</h3><h4 id="审美与反思判断"><a href="#审美与反思判断" class="headerlink" title="审美与反思判断"></a>审美与反思判断</h4><ul><li>审美能力依于判断能力 (power of judgment)</li><li>判断能力的一般性格：将个殊 (particular) 隶归到普遍 (universal)</li><li>判断力有两种：<ul><li>决定式判断力 （determinant judgment）：先有「普遍」，再将它应用到特殊之上。</li><li>反思式判断力（reflective judgment）：先面对特殊各物，而找一些普遍原理来涵盖。</li></ul></li><li>反思式判断力的特点：<ul><li>愉悦感：发现规律去涵盖纷杂现象时，自然会产生。</li><li>自然的合目的性：寻找普遍律，即预设有「律」可寻找，而假定自然界具有某种规律或是事先设计的秩序一样。</li></ul></li></ul><h4 id="审美判断的特点"><a href="#审美判断的特点" class="headerlink" title="审美判断的特点"></a>审美判断的特点</h4><ul><li>康德把「审美判断」包含在「反思判断」中。他没有明确解释原因，但主要有三个要点可说：<br>美的欣赏一样要面对一些杂多的现象，并加以反省或观照。<ul><li>一样涉及「合目的性」这个原则，虽然于此是所谓「主观的合目的性」。</li><li>会涉及「某种快感」，而且感受就是判断的基础。</li></ul></li></ul><blockquote><p>我们说某物为「美」时，我们往往虽只诉诸我们对该物的感受，但仿佛又将「美」当作事物昭明的客观性质，要求每个(有品味的)人皆能辨察。以康德的术语说：审美判断具普遍有效性(universal validity)，它们具有某种「必然性」(necessity)或在某程度上是「先验的」(a priori)。</p></blockquote><h4 id="判断力批判的任务"><a href="#判断力批判的任务" class="headerlink" title="判断力批判的任务"></a>判断力批判的任务</h4><ul><li>笼统来说，《判断力批判》(Critique of Judgment) 的主要任务对人的判断能力作超越的分析，以阐明「审美判断」与「目的论判断」是如何可能。</li><li>就美学而言，《判断力批判》要说明的是：单纯依主观的基础(审美的愉悦感)而判定某物为美，但同时要求此判断被普遍认同──这如何可能？</li><li>美感缘何能够成普遍有效性的基础？</li></ul><h4 id="审美判断力的分析"><a href="#审美判断力的分析" class="headerlink" title="审美判断力的分析"></a>审美判断力的分析</h4><ul><li>品味判断：<ul><li>性质 (Quality)</li><li>数量 (Quantity)</li><li>目的关联 (Relation of the Purpose)</li><li>模式/模态 (Modality)</li></ul></li></ul><h5 id="美的性质"><a href="#美的性质" class="headerlink" title="美的性质"></a>美的性质</h5><ul><li>就性质而言，「美」是一种愉悦的感受，而审美判断则相应是主观的，其基础消极来说不在于对事物的概念性的知识，而是在单纯的观看 (contemplation) 中得感受到的愉悦或不愉悦感。(康德认为实践上的好坏是概念性，审美上的美丑则不然)。</li><li>纯粹的审美判断必须是无「利害关心」的 (disinterested)，我们审美时不但悬搁我们的知识兴趣、欲求与道德意愿，我们甚至不关心对象是否实存。(因此美食往往不是纯粹的美，美色亦然。)</li></ul><blockquote><p> 在质上，康德的总结性论断如下：「鉴赏力/品味能力是通过不带任何利害的(without interest)愉悦或不悦而对一个对象或一个对象的表象方式作评判的能力。一个这样的愉悦的对象就叫做美的」。</p></blockquote><h5 id="审美判断的量"><a href="#审美判断的量" class="headerlink" title="审美判断的量"></a>审美判断的量</h5><ul><li>康德就「量」方面的主要论断是:「凡是那单个没有概念而普遍令人喜欢的东西就是美的」。因为审美愉悦完全脱离于个人的个别需要和欲望，所以它具有某种独特的普遍性。单个：在对象的量上，审美判断和关于感官快适的判断一样，严格而言都是针对眼前某个个殊东西的判断。(「这朵玫瑰是漂亮的」；「这块蛋糕很好吃」)</li><li>无概念而普遍：但两者有一点关键的不同：在判断感官快适时，我根本上就我个人而言而下判断的(例如别人可以认为这块蛋糕太甜或太淡或太多奶油而不爱吃的)，反之，判断对象美与不美时，主体却不是单为了他本人，也同时是为所有人下判断的。</li><li>基于概念而产生，事实上，康德认，纯粹审美判断全部的如上所说，审美主体要求所有人都认同他的判断，但这种普遍性不是「客观关涉」都只是仅在于眼前这个不能被概念化的、独一无二的现象。</li></ul><h5 id="审美判断的关系"><a href="#审美判断的关系" class="headerlink" title="审美判断的关系"></a>审美判断的关系</h5><ul><li>关系: 「美是一个对象的合目的性之形式，如果这形式是没有一个目的的表象而在对象身上被知觉到的话」。<br>审美判断是以美感为基础，而美感是一种快感。然而快感之所以产生，当中应涉及某种「适然的」状况：应该是由于审美对象在某个意义下对我是「适然的」，故此我才会感到愉悦。可是上述分析已指明，审美快感并非出于满足于我的某种特殊的感性欲望或理性欲望，那么它是之所适是适于什么东西？<br>康德认为，既然美感是单纯因为观照而产生，那么美感之所适便是适于人的知觉，故此单从品鉴审美对象，便能产生审美的愉悦。用现代的术语来表达审美愉悦的基础可说并不在于知觉对象的某些实存的性质，而是在于审美知觉活动 (perceptual activity) 本身的特殊方式。﹝犹如游戏的愉悦不在于其对象，而是由游戏活动本身一般。﹞</li></ul><h5 id="审美判断的模态"><a href="#审美判断的模态" class="headerlink" title="审美判断的模态"></a>审美判断的模态</h5><ul><li>模态:「那没有概念而被认作一个必然愉悦的对象的东西就是美的」。</li><li>审美判断判定某物必然带来美感的愉悦，但这种必然性之基础不在于某种依于概念上的推证的必然 (apodeictic 的必然性，而是exemplary (展示某不可明示的规则) 。</li><li>康德以为，审美判断的主观普遍性的基础，最终在于共通感 (sensus communis。</li><li>审美判断的第四个特点是其「模态」上的必然性：品味判断基于审美愉悦感，康德的分析将这愉悦感归因于审美主体内部的超验认知能力之和谐游戏，因此，审美判断所隐含的普遍有效的宣称便有一先验的基础。此先验基础使对象的美感有着某种「必然性」(每个人皆应该认同我的判断，皆应该感到此对象之美)，但这种必然性不是按照明确规定的法则而树立，而只是「主观的」或「典范性」(exemplary) 的。</li><li>康德说，这里的「典范性」是指「所有人皆须同意某个判断的必然性，此判断是被视作某个我们无法表明的普遍法则之范例」。</li></ul><h2 id="德国观念论"><a href="#德国观念论" class="headerlink" title="德国观念论"></a>德国观念论</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>德国观念论是德国后康德时期哲学的主流，在18世纪末、19世纪初盛行。以批判地承接康德为特征，与启蒙运动 (the Enlightenment) 及浪漫主义 (Romanticism)，密切关系。</li></ul><h3 id="代表人物"><a href="#代表人物" class="headerlink" title="代表人物"></a>代表人物</h3><ul><li>德国观念论主要有三家，按其照跃时候，费希特 (Johann Gottlieb Fichte)、谢林(Friedrich Schelling)及黑格尔 (Georg Wilhelm Friedrich Hegel)。</li></ul><h2 id="费希特"><a href="#费希特" class="headerlink" title="费希特"></a>费希特</h2><h3 id="著作-2"><a href="#著作-2" class="headerlink" title="著作"></a>著作</h3><ul><li>《试论一切天启之批判》(Versuch einer Kritik aller Offenbarung)</li><li>《全体知识学之基础》(Grundlage der gesamten Wissenschaftslehre)</li><li>《自然权之基础》(Grundlage der Naturrechts) </li><li>《伦理学体系》(Das System der Sittenlehre)</li></ul><h3 id="费希特-VS-康德"><a href="#费希特-VS-康德" class="headerlink" title="费希特 VS 康德"></a>费希特 VS 康德</h3><ul><li>自认承接和「忠于」发展康德学说，认为康德哲学有<strong>两个漏洞或不足</strong>：<ul><li>物自身的假设 (独断论 (dogmatism) 的假定)</li><li>理论理性与实践理性之分离</li></ul></li><li>费希等眼中，康德的基本洞见为：实践理性至于理论理性之优先地位；自由为理性的事实。</li><li><p>舍弃「物自身」(Ding an sich) 概念，而由「我自身」(Ich an sich) 为绝对基点出发，建立一元的主观观念论 (subjective Idealism)</p></li><li><p>费希特的基本进路：</p><ul><li>消除独断论，建立彻底的观念论。</li><li>以绝对自我为始点的主观观念论，整合理论理性与实践理性(两者为同一自我的两种表现)。</li></ul></li><li><p>我自身 (绝对自我) 为始的存在模式：</p><ul><li>消极：自我  物、客体、对象、实体。</li><li>积极：自我在于「活动」、「行动」(Handlung)；其为「即活动即存在」，「事行合一」(费希特称之为 Tathandlung) 。</li></ul></li><li><p>独断论与观念论争议无法在理论上终极解决──它是「倾向与关心」之争：「最高的关必或即其他关心的根据，乃是对我们自己的关心。哲学家的情形亦然。」「一个人选择何种哲学，端看他是那一种人。」</p></li></ul><h3 id="知识学"><a href="#知识学" class="headerlink" title="知识学"></a>知识学</h3><blockquote><p>主观观念论以自我之事行为根本原理，演绎其他一切。</p></blockquote><h4 id="自我（费希特）"><a href="#自我（费希特）" class="headerlink" title="自我（费希特）"></a>自我（费希特）</h4><ul><li>费希特反对康德通过设定自在之物为经验寻找依据，而认为全部经验的根据就是“自我”。“自我”查知经验客体而不依赖于经验客体，自我通过主体的自我反省建立起来，通过绝对自我的理智觉察主体的存在。自我没有规定，没有限制，没有间接认识，是一种直觉。</li><li>（PPT）费希特所谓的「自我」，乃绝对自我 (das absolute Ich)，而并非经验心理学意味的个别的人。绝对自我乃康德的超验统觉，并揉合笛卡儿的「我思、我在」，去掉后者的实在论假定之形上学化概念。(「我在」是第一序的，而我思则被理解为超验的、建构性的思想)</li></ul><h4 id="三个建立客体知识的原则"><a href="#三个建立客体知识的原则" class="headerlink" title="三个建立客体知识的原则"></a>三个建立客体知识的原则</h4><ol><li>第一原理：</li></ol><ul><li>自我设定自身：所谓「设定」(setzen, posit) 是指在意识中确立起来。自我设定自身即意识中确立自己的存在。对应于 “A = A” 的命题，为绝对无条件的原理。</li></ul><ol><li>第二原理：</li></ol><ul><li>自我设定非我。费希特认为此对应 “~A ≠ A” 的命题，由于否定性 (「不是」)并非衍生自肯定性(「是」)，故此设定非我的事行也是一形式本原的行动，只有<br>内容上有预设 (非我以「我」为前提)。</li></ul><ol><li>第三原理：</li></ol><ul><li>自我在自身中设定一个可分(割)的非我与可分(割)的自我相对立。</li></ul><ol><li>第三原理以先行两个原理为基：</li></ol><ul><li>非我是自我的否定，但因为我是建构性的，也是非我的设定者、没有自我就没有非我。(非我既不是我，但又是我)</li><li>于是在一定程度，我与非我、A与~A、实在与否定虽要结合起来。</li><li>第一原理中的自我是无条件的绝对自我；第二原理中的自我是受非我限制、与之对立的有条件自我。故第三原理所表达的是：有条件的自我与有条件的非我相对立，但两者皆从属于绝对的自我。</li><li>费希特认为，第三原理即知识的最高的综合 (以绝对自我综合主客关系)。</li></ul><h2 id="谢林"><a href="#谢林" class="headerlink" title="谢林"></a>谢林</h2><h3 id="著作-3"><a href="#著作-3" class="headerlink" title="著作"></a>著作</h3><ul><li>《超验观念论体系》(System des transcendentalen Idealismus, 1800)</li><li>《哲学与宗教》</li></ul><h3 id="自然学说"><a href="#自然学说" class="headerlink" title="自然学说"></a>自然学说</h3><ul><li>自然哲学中的自然：并非自我设定的对象(非我)、整体、内在的动力结构与普遍原理，自然之为自然的条件。</li><li>自然哲学 = 思辨物理学 (speculative physics)。</li><li>自然并非与意识、理智对立，它不过是暗哑和尚未成熟的理智。(谢林的构想与唯物刚巧相反：把自然还原为初阶的精、理智。)</li><li>自然哲学即旨在显示，自然发展如何使得主体渐渐出现，并勾勒从「质料」、「无机物」到「有机物」至最终出现精神的过程。</li><li>这个发展的逻辑，谢林以「对立统一」表释之。</li></ul><h3 id="对立统一的例子"><a href="#对立统一的例子" class="headerlink" title="对立统一的例子"></a>对立统一的例子</h3><ol><li>质料层次：引力与斥力。引力表现客观、物质、自然；斥力表现为主观、自我、精神性。二种力物质和精神的共同基础，引力把外在世界的运动变化凝聚到内在的感觉世界，构成我们的内部经验，谢林以之配对时间的先验基础；斥力则是向外在世动，构成外部经验，是空间的先验基础。</li><li>二元对立和统一推动着无机领域向有机领域的转化。谢林以为电、磁现象即此转化的关系。自然哲学中的自然：并非自我设定的对象(非我)、整体、内在的动力结构与普遍原理，自然之为自然的条件。</li></ol><h3 id="同一性哲学"><a href="#同一性哲学" class="headerlink" title="同一性哲学"></a>同一性哲学</h3><ul><li>谢林是以费希特为始点而发展出自己的思想道路的：</li></ul><ol><li>预备时期 (1797)：完备费希特的「知识学」而发展自然哲学(自然哲学作为超验哲学的一个补充部份)</li></ol><ul><li>第1期 (1799)：以「自然哲学」冠名自己的思想，以之与康德的批判哲学及费希特的知识学相对比。</li><li>第2期 (1800)：发表《超验观念论体系》，并举自然哲学与超验哲学两部份，合构成「同一性哲学」。</li><li>同一性哲学的观念：知识学的最高原理 = 自我 = 主观的主客合一、自然哲学：客观的主客合一。完全从绝对本原出发：主客绝对的同一 (尚未分离意义的同一)。</li></ul><h3 id="（立场）费希特-VS-谢林"><a href="#（立场）费希特-VS-谢林" class="headerlink" title="（立场）费希特 VS 谢林"></a>（立场）费希特 VS 谢林</h3><ul><li>相同点是克服康德的超验哲学的主客体分离的二元框架，贯彻观念论的立场，质疑越出建构性主体以外的「物自身」的设定。<ul><li>费希特：以主体收摄客体，客体只是主体以内所确立的「非我」。</li><li>前期谢林：以自然哲学 (把主体视作自然本身的发展的目标) 补足费希特的主体观念论 (把客体视作主体的观念)。</li><li>后期谢林：追溯前于主客体区分的「绝对者」、「同一者」，其表征及掌握超出概念思维以外，或诉诸艺术直观，或诉诸宗教体验。</li></ul></li><li>费希特可说是超验哲学化的笛卡儿主义，而谢林则是超验哲学化的史宾诺莎主义。</li></ul><h2 id="黑格尔"><a href="#黑格尔" class="headerlink" title="黑格尔"></a>黑格尔</h2><h3 id="著作-4"><a href="#著作-4" class="headerlink" title="著作"></a>著作</h3><ul><li>【处女作】《论费希特与谢林哲学体系的差异》(1801)</li><li>【生前出版（书）】《精神现象学》(The Phenomenology of Mind)</li><li>【生前出版（书）】《逻辑学》(Science of Logic)</li><li>【生前出版（教材或讲义）】《哲学全书纲要》(Encylopedia of the Philosophical Sciences in Outline)</li><li>【生前出版（教材或讲义）】《自然法与政治学纲要·法哲学原理》(Natural Law and Politics in Outline. The Principles of the Philosophy of Right)</li><li>柏林时代的遗稿：（整理的课堂笔记）<ul><li>《历史哲学》</li><li>《美学》</li><li>《宗教哲学》</li><li>《哲学史》</li></ul></li></ul><h3 id="思想特点"><a href="#思想特点" class="headerlink" title="思想特点"></a>思想特点</h3><ul><li>古典基础：<ul><li>(1) 存在与思维合一的构想 (Parmenides, Plato)；</li><li>(2) 概念或观念的存在论意味 (Plato, Aristotle) </li></ul></li><li>近代基础：康德至费希特、谢林一脉的德国观念论发展。</li><li>注重哲学思想及其课题的历史性与社会文化脉络 (“philosophy is its own time apprehended in thoughts“)。</li><li>有别于谢林只追溯(超验)哲学的前历史，黑格尔也描述其后续的历史发展之逻辑与目的<br>以辩证法取代演绎法，以之为：(1) 哲学方法；(2) 存在本身的逻辑</li></ul><h3 id="康德基础上的黑格尔"><a href="#康德基础上的黑格尔" class="headerlink" title="康德基础上的黑格尔"></a>康德基础上的黑格尔</h3><ul><li>就如其他德国观念论者一样，黑格尔也是以康德的超验哲学中的主客对立(我与物自身的分离)为思考的始点：物自身意味，知识与对象有「差距」：<ul><li>(1) 要么是指经验意义或一般；</li><li>(2) 要么是指超验的意义 (康德的问题, transcendental gap)</li></ul></li><li><p>若 (1) ，则只涉及知识(思想)调节，务求思想与现实吻合的问题。但若 (2)，则黑格尔认为，同样理应调节思想，以便吻合于现实，形成超验知识。只是问题是：此时的思想是超验的、建构性的思想。故此……</p></li><li><p>调节思想便同时意味以新的形式建构它的客体 (产生新的transz. gap)，原来的物自身(「自在之物」)变成对象，但同时又产生新的「自在之物」</p></li><li><p>思想 – 知识 – 对象 – 自在物 乃一串连动的环节，调节一者则整系列皆有改变。</p></li><li><p>例子：《精神现象学》的感性确定</p></li><li>结论：<ul><li>(1)知识与对象间的落差会推动知识自身的发展，但对象与自在物也同时会变化；</li><li>(2) 调节思想以与实在一致，此历程称为辩证法。</li></ul></li></ul><h3 id="辩证法-Dialectics"><a href="#辩证法-Dialectics" class="headerlink" title="辩证法 (Dialectics)"></a>辩证法 (Dialectics)</h3><ul><li>原意：对话，即人际的现象→ </li><li>哲学转化 (柏拉图苏格拉底传统)：心灵的自我对话，以趋向真理的表述 (定义)的历史</li><li>黑格尔的转化：D. = 主体思想与客观实在的共同规定。</li></ul><h3 id="辩证法的历史"><a href="#辩证法的历史" class="headerlink" title="辩证法的历史"></a>辩证法的历史</h3><ul><li>古典的辩证法：<ul><li>(1) Heraclitus的自然辩证法；</li><li>(2) Zeno 的论辩的辩证法；</li><li>(3) Socrates的对话的辩证法。</li></ul></li><li>近代的辩证法：康德的消极的理性辩证法 (二律背反)</li></ul><h3 id="辩证法的层次"><a href="#辩证法的层次" class="headerlink" title="辩证法的层次"></a>辩证法的层次</h3><ul><li>哲学思想与心理学层次：D. = 思想/认识的发展逻辑 (如正题、反题、合题)</li><li>存在论层次：D. = 思想(观念)</li><li>与实在融合的过程：一方面，实在观念化、思想化；另一方面则是思想的实在化。最终达致，思维与存在合一，「凡是现实均为合理，是合理的均为现实」</li><li>宇宙论层次：为精神实体自身发展的逻辑，从目的处回头考察各个阶段的合理位置与意义 。《精神现象学》考察从最个殊具体(感性意识)至普遍(绝对精神)的辩证发展；《逻辑学》则考察从最普遍 (存在一般) 至最个殊的概念之辩证发展。</li></ul><h3 id="黑格尔的辩证法"><a href="#黑格尔的辩证法" class="headerlink" title="黑格尔的辩证法"></a>黑格尔的辩证法</h3><ul><li>辩证法的基本运动：否定性</li><li>但辩证的否定性是具体的否定性，不是虚无主义的抽象否定 (negation as negation of…)<br>辩证的否定，黑格尔以德语 “aufheben” (扬弃) 表述其特征，即<ul><li>(1) 否定、终止；</li><li>(2)保持；</li><li>(3) 提升；</li></ul></li></ul><h3 id="辩证法的例子"><a href="#辩证法的例子" class="headerlink" title="辩证法的例子"></a>辩证法的例子</h3><h4 id="例一：《逻辑学》的最初三个概念"><a href="#例一：《逻辑学》的最初三个概念" class="headerlink" title="例一：《逻辑学》的最初三个概念"></a>例一：《逻辑学》的最初三个概念</h4><ul><li>正题：存在 (Being)</li><li>反题：无 (Nothing)</li><li>合题：变化 (Becoming)</li><li>阶段之间不是逻辑蕴涵关系，而是某种思想的必然发展。</li></ul><h5 id="例二：《精神现象学》的主奴辩证"><a href="#例二：《精神现象学》的主奴辩证" class="headerlink" title="例二：《精神现象学》的主奴辩证"></a>例二：《精神现象学》的主奴辩证</h5><ul><li>自我意识须通过他人的自我意识而成为自身</li><li>阶段1：物化他人，显示只有自己是「主」(例如战争、暴力中以消灭他人为目的)。</li><li>阶段2：奴役他人 (留其命以事奉自己)，被「承认」的主体。</li><li>阶段3 ：主奴的依从地位颠倒</li><li>主人因为过于依赖奴隶，最终丧失自主的能力。</li><li>奴隶反因通过生产与制造，意识自己能够改造世界的独立主体能力。</li></ul><h3 id="辩证法的原文"><a href="#辩证法的原文" class="headerlink" title="辩证法的原文"></a>辩证法的原文</h3><ul><li><p>§ 130<br>Being is the indeterminate immediate; it is free from determinateness in relation to essence and also from any which it can possess within itself. This reflectionless being is being as it is immediately in its own self alone.</p></li><li><p>§ 131<br>Because it is indeterminate being, it lacks all quality; but in itself, the character of indeterminateness attaches to it only in contrast to what is determinate or qualitative. But determinate being stands in contrast to being in general, so that the very indeterminateness of the latter constitutes its quality. It will therefore be shown that the first being is in itself determinate, and therefore, secondly, that it passes over into determinate being — is determinate being — but that this latter as finite being sublates itself and passes over into the infinite relation of being to its own self, that is, thirdly, into being-for-self.</p></li><li><p>§ 132<br>Being, pure being, without any further determination. In its indeterminate immediacy it is equal only to itself. It is also not unequal relatively to an other; it has no diversity within itself nor any with a reference outwards. It would not be held fast in its purity if it contained any determination or content which could be distinguished in it or by which it could be distinguished from an other. It is pure indeterminateness and emptiness. There is nothing to be intuited in it, if one can speak here of intuiting; or, it is only this pure intuiting itself. Just as little is anything to be thought in it, or it is equally only this empty thinking. Being, the indeterminate immediate, is in fact nothing, and neither more nor less than nothing.</p></li><li><p>§ 133<br>Nothing, pure nothing: it is simply equality with itself, complete emptiness, absence of all determination and content — undifferentiatedness in itself. In so far as intuiting or thinking can be mentioned here, it counts as a distinction whether something or nothing is intuited or thought. To intuit or think nothing has, therefore, a meaning; both are distinguished and thus nothing is (exists) in our intuiting or thinking; or rather it is empty intuition and thought itself, and the same empty intuition or thought as pure being. Nothing is, therefore, the same determination, or rather absence of determination, and thus altogether the same as, pure being.</p></li><li><p>§ 134<br>Pure Being and pure nothing are, therefore, the same. What is the truth is neither being nor nothing, but that being — does not pass over but has passed over — into nothing, and nothing into being. But it is equally true that they are not undistinguished from each other, that, on the contrary, they are not the same, that they are absolutely distinct, and yet that they are unseparated and inseparable and that each immediately vanishes in its opposite. Their truth is therefore, this movement of the immediate vanishing of the one into the other: becoming, a movement in which both are distinguished, but by a difference which has equally immediately resolved itself.</p></li></ul><h2 id="三位哲学家的观念比较"><a href="#三位哲学家的观念比较" class="headerlink" title="三位哲学家的观念比较"></a>三位哲学家的观念比较</h2><h4 id="洛克"><a href="#洛克" class="headerlink" title="洛克"></a>洛克</h4><ul><li>表象实在论：实际有那么一个东西，然后心里才有这样的观念。</li></ul><h4 id="柏克莱-1"><a href="#柏克莱-1" class="headerlink" title="柏克莱"></a>柏克莱</h4><ul><li>存在即被感知</li></ul><h4 id="休谟"><a href="#休谟" class="headerlink" title="休谟"></a>休谟</h4><ul><li>既无物理实在，也无精神实体</li></ul><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="http://otn4ut2th.bkt.clouddn.com/studyhistory.png" alt="西方哲学史结构图"></p><p><img src="http://otn4ut2th.bkt.clouddn.com/studystudybloghistory.png" alt="此处输入图片的描述"></p><h2 id="考试题预测复习"><a href="#考试题预测复习" class="headerlink" title="考试题预测复习"></a>考试题预测复习</h2><h3 id="印象与观念（休谟）"><a href="#印象与观念（休谟）" class="headerlink" title="印象与观念（休谟）"></a>印象与观念（休谟）</h3><ul><li>休谟提出一个命题：“除了知觉，一切都是不可知的。”在论证这一命题时，休谟把感觉经验叫做知觉，认为知觉可分为印象和观念。进入心灵时，最强烈、最活泼的知觉是印象，包括感觉、情感和情绪；观念则是感觉、情感和情绪在思维和推理中的微弱的意象。印象又可分为感觉印象和反省印象两种，而感觉是观念和反省印象的基础，观念则是感觉印象的精神的表象。观念可分为复合观念和简单观念，复合观念则是简单观念的集合或复合。</li></ul><h3 id="观念联想（休谟）"><a href="#观念联想（休谟）" class="headerlink" title="观念联想（休谟）"></a>观念联想（休谟）</h3><ul><li>休谟把感觉经验统称为知觉，然后又把“知觉”分为“印象与观念”。观念区别于印象，是由于它们具有较低程度的“生动性和强烈性”。又因为一些观念以某种未经解释的方式，带着印象的生动性与强烈再现，或者，“产生”了他所谓的“反省印象”的“新印象”。因此，反省是从感觉派生的。一切事实（知觉）都从感觉派生，而感觉印象来源于不知道的原因。简单观念之区别于简单印象仅仅是由于它们比较缺乏生动性和强烈性。通过这种“观念联想”就形成了关系、情状和实体的复杂观念。</li></ul><h3 id="简述休谟的因果关系理论。（休谟）"><a href="#简述休谟的因果关系理论。（休谟）" class="headerlink" title="简述休谟的因果关系理论。（休谟）"></a>简述休谟的因果关系理论。（休谟）</h3><ul><li>休谟坚持人们只能在经验的范围内研究因果性的问题。他认为在经验中，我们关于因果关系的观念是从对象间的某种关系得来的。首先，人们看到两个对象之间的接近关系，因此只有在时间上和学问上接近的东西才能相互作用，其次，人们看到两个对象在时间上的先后关系，因先于果，果接续因，接近关系和接续关系是我们形成两个对象之间因果关系的必要条件，但还不能由此提出一个完善的因果性观念，即两个对象之间必须存在着必然的联系。这是因为，观念即对象总是特殊的、各别的。我们从经验中最多只能看到两个对象之间的接近或接续关系，但是，我们永远看不到它们中间有任何纽带”，即必然联系，看不到原因中存在着某种必然产生结果的能力。休谟认为，原因和结果是两个根本不同的东西，二者之间不可能存在什么必然的联系。人们之所以觉得因果之间有着必然联系，是因为这种观念是从对象的恒常会合中引出来的，是对象恒常会合在人心中形成的一种习惯。</li></ul><h3 id="休谟怀疑论思想述评。"><a href="#休谟怀疑论思想述评。" class="headerlink" title="休谟怀疑论思想述评。"></a>休谟怀疑论思想述评。</h3><ul><li>休谟认为人通过感性知觉只能知道经验中一些表面的个别的现象，超出这个范围的事物的性质、本质、内部联系等等都是不可知的。他拒绝回答知觉的起源问题。他说：“用什么论证可以证明，心灵的各种知觉，一定是由一些虽然与他的相似，但是与他们完全不同的外物引起的，而不能由心灵本身的能力，或者由某种我们更不知道的其它原因产生呢？对于这个问题，经验是没有什么话可说的，也必须完全保持沉默。在心灵前面主观的，除了知觉以外，是根本没有别的东西的，它绝不能经验到知觉与对象的联系。因此，我们假定这样一种联系，是没有任何根据性的。显然，休谟拒绝回答感性知觉是由物质还是由精神引起的问题，实质上是拒绝公开回答哲学的根本问题。</li><li>休谟称自己的不可知论为“温和的怀疑论”，休谟的怀疑论把人的认识和外部世界隔绝，根本怀疑外部世界的存在，完全否认认识世界的可能性。在哲学史上，休谟的这种观点称为不可知论。休谟的不可知论，不过是贝克莱的直接否定物质世界客观存在的另一说法而已。    休谟从不可知论出发，在事物的现象和本质之间建立了一条不可超越的鸿沟，否认人们能认识事物的内在因果联系和本质。他说：“结果和原因是完全不一样的，因此我们也就不能在原因中表现出结果来。”休谟否认客观因果性。</li></ul><h3 id="简述费希特知识学的三条基本原理。"><a href="#简述费希特知识学的三条基本原理。" class="headerlink" title="简述费希特知识学的三条基本原理。"></a>简述费希特知识学的三条基本原理。</h3><ul><li>费希特知识学简单说来，以三条原理为中心内容。</li><li>第一原理，“自我建立自我”。自我建立自我是基于自我反省的认识。在认识之前，假定有一个绝对的自我，绝对自我通过主体的自我反省建立起来，于是设定自我。自我在设定自我时，把自我作为认识对象，与认识事实不同，它是一种直觉，还没有规定，没有限制。</li><li>第二原理，“自我建立非我”。自我在认识“自我”时，由于把自我作为一个对象看待，必然产生一种对象意识，即与“自我”相对立的东西，这就是“非我”。但非我并不是唯物主义所说的“自然界”，它是“自我”建立起来的，是自我能动的创造物。</li><li>第三原理，“自我与非我的统一”。自我与非我，主体与客体，主观与客观，意识与存在，精神与物质都统一于自我意识之中，相互限制，相互决定。这种自我与非我之间的统一关系即自我与非我的统一。</li><li>这三个阶段是辩证发展的，自我在不断创造非我时不断丰富自己，自我的创造过程也是自我的认识过程，自我不断丰富着对非我的认识，从而对自我的认识也丰富了。</li></ul><h3 id="绝对同一（谢林）"><a href="#绝对同一（谢林）" class="headerlink" title="绝对同一（谢林）"></a>绝对同一（谢林）</h3><ul><li>谢林的“绝对同一”指“无差别的同一”。它既非主体，亦非客体，而是“主体与客体的绝对无差别”。其中主体与客体、思维与存在都融合为一，没有差别。“绝对同一”是一种不自觉的精神力量，使自己和自己区别开来，从而产生出主体和客体、思维和存在、精神和物质的差别和矛盾，并复归于绝对同一。</li></ul><h3 id="简述谢林的历史观。"><a href="#简述谢林的历史观。" class="headerlink" title="简述谢林的历史观。"></a>简述谢林的历史观。</h3><ul><li>第一，谢林认为，自然界和人类历史是一个由低级到高级的不断发展的过程。</li><li>第二，谢林认为，矛盾是自然界和人类历史不断发展的动力。他说：“对立在每一刻都重新产生，又在每一刻被消除。对立在每一时刻都这样一再产生又一再消除，必定是一切运动的根据。</li><li>第三，谢林认为，人类社会的发展规律是不依人的主观意识为转移的。他认为人类历史乃是一个有意识的自由创造的过程，但正如无意识的必然的自然界中存在着有意识和自由一样，在有意识的自由的社会历史的创造活动中也存在着无意识必然的东西。这种东西就是不依人的主观意识为转移的历史规律。</li><li>第四，谢林认为，贯穿于自然界和人类社会历史中的意志的自由性和规律的必然性根源于“绝对同一性”，整个历史都是对这种绝对的启示和表露。</li></ul><h3 id="自在之物（康德）"><a href="#自在之物（康德）" class="headerlink" title="自在之物（康德）"></a>自在之物（康德）</h3><ul><li>在康德哲学中，“自在之物”与“现象界”相对，有三种不同含义：<ul><li>（1）指外在事物，在其认识论中常用，意思是在人认识外界事物时，先由这些事物刺激人们的感官而产生杂乱的印象与观念，然后由感性形式与知性范畴加以改造而形成现象界，人只能认识现象界，对自在物则不得而知。</li><li>（2）在《纯粹理性批判》的先验辩证部分中认为理性所试图达到的三个理念：一是一切精神现象的最高统一体“灵魂”；二是一切物理现象的最高统一体“世界”；三是无条件的全体统一。但人们对这些事物的统一仍然用知性的有限范畴去认识，因而理性陷入二律背反和谬误，以此说明自在之物存在于现象的彼岸，并不具有经验材料，不能形成知识，但可以通过伦理学思想而达到对它的假设。</li><li>（3）指与本体意义接近的极限概念，见于《纯粹理性批判》知性理论中论述本体与现象对立的部分。这种用法强调自在之物的不可知的性质，认为人的认识到此为止，不能超越这个界限，极限之内是现象界，可以认识，自在之物不能认识。从这个意义提出本体概念，作为对自在之物的另一种表述。辩证唯物主义承认自在之物，但否认自在之物与现象之间有不可逾越的界限。</li></ul></li></ul><h3 id="现象（康德）"><a href="#现象（康德）" class="headerlink" title="现象（康德）"></a>现象（康德）</h3><ul><li>在康德哲学中，“现象”与“自在之物”相对，是指在直观中对人呈现的东西。凡人经验所及，皆属现象范围，但并不是指客观事物的表面现象，而是指一种主观表象。这种表象由自在之物作用于人的感官形式，但它不反映自在之物的性质，而只是一种纯粹的主观心理状态。</li></ul><h3 id="二律背反（康德）"><a href="#二律背反（康德）" class="headerlink" title="二律背反（康德）"></a>二律背反（康德）</h3><ul><li>在康德哲学中，指两项原理对同一主题进行论证，其论证是矛盾的，但都是可以证明是正确的；或者两个前提推出的结论是矛盾的。二律背反的理论提出了理性思维中有矛盾的问题，但没有提出矛盾双方的统一与转化，并认为“有限”“无限”“简单”“复杂”这些说明现象界的知性范畴来说明自在之物是错误的；又认为自由与作为最初原因的上帝是属于自在之物的，而自然界则具有必然性，不能从必然性证明上帝存在，因而“自由”与“必然”“有上帝存在”与“没有上帝存在”可以存在于不同的地方，从而调和了矛盾。《纯粹理性批判》中提出理性宇宙论的四组二律背反，《实践理性批判》提出实践理性的二律背反，《判断力批判》中提出判断力的二律背反。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;明天期末考试，今天下午整理出来的复习资料，这还只是后半学期的，简直要疯了，最后还是佛系的选择随缘了！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yangkunyi.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="复习" scheme="http://yangkunyi.com/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="哲学" scheme="http://yangkunyi.com/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>不动产管理复习</title>
    <link href="http://yangkunyi.com/2018/01/03/%E4%B8%8D%E5%8A%A8%E4%BA%A7%E7%AE%A1%E7%90%86%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yangkunyi.com/2018/01/03/不动产管理复习/</id>
    <published>2018-01-03T12:10:09.000Z</published>
    <updated>2018-01-03T12:13:54.357Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天抽空整理了上个星期的不动产管理的复习题，当作复习吧，毕竟下个周就要考试了。</p></blockquote><a id="more"></a><ol><li>样品屋不是不动产。</li><li>不是定着物的特点：继续附着在建筑物上。</li><li>不动产的定义未包含<strong>预售屋</strong>。</li><li>要销售预售屋必须要有<strong>建造执照</strong>。</li><li>不动产物权只要签约就生效(X)；需要登记。</li><li>物权优先于债权。</li><li>关于地上权：不以支付地租为必要,不以订定租期为必要,地上权之目标为土地。</li><li>一坪 = 3.3058平方公尺</li><li>一平方公尺 = 0.3025坪</li><li>描述土地的词语：面积，位置，形状（密度不是）。</li><li>都市计划法包括的内容：乡镇计划，乡街计划，特定区计划。</li><li>基地面积100平方公尺,建蔽率50%,总楼地板面积25000平方公尺,容积率为多少?(<strong>容积率:楼地板面积除以建蔽率</strong>) <strong>500%</strong></li><li>容积率500%,基地面积100平方公尺,建蔽率50%,可盖几楼? (<strong>容积率除以建蔽率</strong>)10楼</li><li>从地籍图无法知道市价。</li><li>土地的性质不包括：异质性。</li><li>预售屋：<strong>高风险高报酬</strong>（自备款比中古屋少，总价负担重）。</li><li>房地产的特性：不可移动性，消费性，投资性。产品一致性不是房地产的特性。</li><li>在非都市土地中,山坡地保育区所兴建的房屋会属于何者用地?丙（老丙建）(甲:乡村 乙:乡村 丙:山坡 丁:工业)</li><li>所有权类型： 单独持有，分别共有，共同共有。</li><li>分别共有的特性：应有部分均等，着重应有部分，可自由处分应有部分。</li><li>房地产的声明周期：<strong>投资-&gt;生产-&gt;交易-&gt;使用</strong>。</li><li>共同共有：合伙财产（合伙人），共同财产（夫妻），未分割的遗产（继承）。</li><li>不是市地重划的原因：使用为公共交通促进土地合理之需要者（非都市）。</li><li>市地重划：经政府选定指定范围办理市地重划；人民申请优先办理；奖励私人自办重划。</li><li>市地重划描述错误的：重划后的土地按抽签的方式分配给原土地所有权人（按原位）。</li><li>市地重划中,土地所有权人共同负担不可超过?  <strong>45%</strong></li><li>市地重划的效益：增加土地供给，促进土地利用，提高土地价值。不是为了增进当地人口数。</li><li>市地重划（一定是都市土地）的原因：新设都市地区的全部或一部分，实施开发建设；旧都市地区为公共安全促进土地合理需要者；都市土地开发新社区者。</li><li>市地重划后土地所有人最少可领回? <strong>55%</strong></li><li>桃园航空城属于哪一种征收？ 区段征收</li><li>有关区段征收的描述，错误的是：仅适用于都市土地</li><li>区段征收：国家因公益需要的征收私有土地；土地征收程序第一步是举办公听会；新设都市地区的全部或一部分，实施开发者可以进行区段征收。</li><li>区段征收与市地重划的比较何者错误? 区段征收较公平（区段征收不公平）</li><li>一般征收与区段征收之描述何者错误?一般征收之原因不一定要为公共事业需要者（征收的土地一定要用于公共事业）–正确的：区段征收执行较为困难；区段征收公共设施较多样性；市地重划民众参与较多；区段征收的原因是开发建设或者促进土地利用；区段征收以现金、抵债地予以补偿；区段征收就是一定区域内的土地全部征收。</li><li>国泰禾</li><li>定型化契约是根据<strong>消费者保护法</strong>定下的。</li><li>登记面积超过3%就可以解约了。</li><li>预售屋定型化契约不得记载事项：广告仅供参考/使用面积销售等</li><li>公寓大厦管理条理的适用描述：建物形态相关</li><li>住户权益义务说法错误：不须负担共同壁的管线维修费用（需要）</li><li>物业管理范围不包括个人财务管理。</li><li>消费者保护法和公平交易法的描述错误的是：广告不实无法依据公交法向业者开罚。</li><li>适用于公平交易法：先付订金才可看契约,没有接露重要信息（违反了市场交易秩序）</li><li>社会住宅的用意：只租不卖；帮助经济弱势；协助社会弱势。</li><li>都市更新不包括：合建。</li><li>约定专用部分说明正确的：经约定将共享部分给特定区分所有权人使用</li><li>权利变换正确的是：（都市更新）立体分配的概念，重新分配土地和建物</li><li>物权具有排他性,请求权,追及性</li><li>凉亭是建筑物，门框铁窗是固定物，售票亭不是不动产</li><li>使用执照是卖之后才有</li><li>区段征收执行比较困难也应该是最后一个手段,公共设施比较多样性(因为政府拿比较多)所以市地重划的公社是比较少的。</li><li>保留增收:还不知道做甚么用先保留</li><li>区段征收:大规模大面积征收</li><li>一并征收:我要征收这边这边有小块一并征收</li><li>区段增收:<strong>抽签</strong> 市地重划:<strong>原位</strong></li><li>公同共有:双方因法律关系共同持有这个东西</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天抽空整理了上个星期的不动产管理的复习题，当作复习吧，毕竟下个周就要考试了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yangkunyi.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="复习" scheme="http://yangkunyi.com/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="不动产" scheme="http://yangkunyi.com/tags/%E4%B8%8D%E5%8A%A8%E4%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>WeeklyMind-6</title>
    <link href="http://yangkunyi.com/2017/12/30/WeeklyMind-6/"/>
    <id>http://yangkunyi.com/2017/12/30/WeeklyMind-6/</id>
    <published>2017-12-30T15:11:06.000Z</published>
    <updated>2018-01-01T15:12:33.181Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2017就这样过了，今天已经是2018年了，想来这一年确实发生了太多的事情，自己的价值观也在这些事情中一次次的改变和塑造着，未来的路在昨天的铺垫中慢慢成型，在今天的过程中慢慢延伸，在明天的憧憬理慢慢向前。这个周开始进入考试复习周，下周三就开始考试了，但自己在假期里显得十分的懒散，可能是因为自己这两天一直在想这一年自己到底干了什么，事情太多，整整两个日记本了，这应该就是自己的成长吧，在这里还是不想太多，就说说这个周。</p></blockquote><a id="more"></a><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul><li>web课程已经结束了。下周三期末考试，作为自己最不担心的一门课程，只希望自己不要粗心吧。</li><li>行销管理的小组报告自己有想好好做出来，做一个成品，之后也可以拿得出手，所以自己把自己当作这个小组的组长，一直在拉着整个报告的进度，但是这个假期还是懈怠了很多，不过假期嘛，大家都没有将心思放在这上面，所以打算回来后继续。</li><li>不动产管理课程也结束了，因为元旦下周的课程放掉了，下下周直接考试，这门课也希望自己能不留遗憾的完成，毕竟是缘分让自己选了这门课。</li><li>财务管理一直是自己不喜欢又带有些害怕的课程，考试范围也算是出来了，所以只能说努力吧。</li><li>西方哲学史也因为假期结课了，最后仍是考试，这门课自己倒不是很担心。</li><li>体育课已经结课了，从来不担心的课程，应该是一个不错的成绩。</li><li>人际管理课程报告也结束了，还有最后两节课和与一个期末总结就完成了，成绩应该也算理想，报告自己觉得做得也不错。</li></ul><blockquote><p>所有课程都进入尾声，自己在这边的学习生活也只剩下最后的15天了。来到这里就说自己要做点什么，然后度过前一周的新鲜期之后陷入深深的迷茫期，感觉不知道做什么，课程前期比较轻松，大把的时间让自己思考，突然不知道该做些什么，直到找到真正的目的——体验，才真正算是投入了这边的生活，这时候在想这五个多月自己没有辜负，完成了这一次体验的行程，自己也清楚的感受到，除了知识，这一次的体验拓展了自己的太多，就想自己开始说的那样，这段经历也是自己人生路的铺垫。</p></blockquote><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul><li>因为小组报告，自己又认识了一群来自不同地方的朋友。一双眼睛只能看到一个世界，但不同双眼睛就能看到不同的世界，自己在这些朋友的眼睛里又看到了不同的世界，那是自己不曾接触过的，却充满智慧，充满乐趣。</li><li>不动产管理的老师请全班的同学吃了披萨，虽然不是老师第一次请吃东西，但是这种氛围自己是第一次感受。从小，在自己的眼里，老师都是要尊敬的，这样自己和老师之间从来都没有向朋友一样亲近过，因为自己在老师面前就是无法将自己视为老师的朋友，但是那个时候我真的没有把筱蓉当作老师来看待，当然不仅仅是因为一顿批萨，而是筱蓉身上散发出来的气场，那种亲和的态度，我也不是说之前的老师不亲和，反正就是个人觉得自己是真的很喜欢筱蓉，也很喜欢她不拘小节的课程。</li><li>原校下周就要选课了，自己想来其实也没有太困难，就是物流的课程需要补回来，其余都还好，所以没必要那么担心。</li></ul><blockquote><p>人间一趟，看看太阳。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2017就这样过了，今天已经是2018年了，想来这一年确实发生了太多的事情，自己的价值观也在这些事情中一次次的改变和塑造着，未来的路在昨天的铺垫中慢慢成型，在今天的过程中慢慢延伸，在明天的憧憬理慢慢向前。这个周开始进入考试复习周，下周三就开始考试了，但自己在假期里显得十分的懒散，可能是因为自己这两天一直在想这一年自己到底干了什么，事情太多，整整两个日记本了，这应该就是自己的成长吧，在这里还是不想太多，就说说这个周。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="周记" scheme="http://yangkunyi.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>PHP绘图</title>
    <link href="http://yangkunyi.com/2017/12/24/PHP%E7%BB%98%E5%9B%BE/"/>
    <id>http://yangkunyi.com/2017/12/24/PHP绘图/</id>
    <published>2017-12-24T04:25:09.000Z</published>
    <updated>2017-12-24T04:27:16.457Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>web课程的笔记和一些实例代码。还有一份自定义图形作业，感觉还不错，简单做了一个二维码。（全是画矩形，确实有点无聊了，有空画点有趣的图）</p></blockquote><a id="more"></a><h3 id="PHP绘图"><a href="#PHP绘图" class="headerlink" title="PHP绘图"></a>PHP绘图</h3><h4 id="1-GD（Graphics-Dynamic-Library）"><a href="#1-GD（Graphics-Dynamic-Library）" class="headerlink" title="1. GD（Graphics Dynamic Library）"></a>1. GD（Graphics Dynamic Library）</h4><ul><li>GD1 / GD2</li><li>可以通过<code>phpinfo()</code>来查询</li></ul><h4 id="2-绘图流程"><a href="#2-绘图流程" class="headerlink" title="2. 绘图流程"></a>2. 绘图流程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">// 确定绘画图片的格式</div><div class="line">// 格式有：jpg，png，gif</div><div class="line">header(&quot;Content-type:image/格式&quot;);</div><div class="line"></div><div class="line">// 1. 建立一个画布（分配存储空间）</div><div class="line">$image = ImageCreate(长度,宽度);// 一般画布</div><div class="line">$image = ImageCreateTrueColor(长度,宽度);// 高清</div><div class="line"></div><div class="line">// 2. 建立颜色板</div><div class="line">$bgcolor=ImageColorAllocate($image,0,255,0);// 默认背景颜色</div><div class="line"></div><div class="line">// 3. PHP绘图命令</div><div class="line">// 点  ImageSetPixel($image,x,y,$color)</div><div class="line">ImageSetPixel($image,90,40,$textcolor);</div><div class="line">// 线  ImageLine($image,x1,y1,x2,y2,$color)</div><div class="line">ImageLine($image,0,0,$bgcolor);</div><div class="line">// 弧  ImageArc($image,x,y,高,宽,开始角度,结束角度,$color)</div><div class="line">ImageArc($image,50,25,90,40,0,360,$textcolor1);</div><div class="line">// 巨型  ImageRectangle($image,x1,y1,x2,y2,$color)</div><div class="line">ImageRectangle($image,20,10,80,40,$textcolor);</div><div class="line">// 空心多边形  ImagePolygon($image,$点数组,点数,$color)</div><div class="line">ImagePolygon($image,$point,count($point)/2,$textcolor);</div><div class="line">// 实心多边形  ImageFilledPolygon($image,$点数组,点数,$color)</div><div class="line">ImageFilledPolygon($image,$point,count($point)/2,$textcolor);</div><div class="line">// 透明  ImageColorTransparent($image,$color)</div><div class="line">ImageColorTransparent($image,$textcolor);</div><div class="line">// 文字输出 ImageTTFtext($image,大小,角度,x,y,$color,字体绝对路径,string)</div><div class="line">ImageTTFtext($image,32,0,0,50,$textcolor,&quot;simhei.ttf&quot;,$string);</div><div class="line"></div><div class="line"></div><div class="line">// 4. 显示/导出  ImageXXX($image[,储存图形的位置和名称])</div><div class="line">Imagepng($image);</div><div class="line"></div><div class="line">// 5. 结束 释放空间</div><div class="line">ImageDestroy($image);</div></pre></td></tr></table></figure><h3 id="实例：二维码绘制"><a href="#实例：二维码绘制" class="headerlink" title="实例：二维码绘制"></a>实例：二维码绘制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line">&lt;?php </div><div class="line">    // 文件输出图片格式为png</div><div class="line">    header(&quot;Content-type:image/png&quot;);</div><div class="line">    // 建立一个画布</div><div class="line">    $image = ImageCreate(100,100);</div><div class="line">    // 设定画布的北京颜色</div><div class="line">    $bgcolor = ImageColorAllocate($image,255,255,255);</div><div class="line">    ImageFill($image,0,0,$bgcolor);</div><div class="line">    // 画笔的颜色</div><div class="line">    $black = ImageColorAllocate($image,0,0,0);    </div><div class="line">    $white = ImageColorAllocate($image,255,255,255);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,0,0,28,28,$black);</div><div class="line">    ImageFilledRectangle($image,4,4,24,24,$white);</div><div class="line">    ImageFilledRectangle($image,8,8,20,20,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,72,0,500,28,$black);</div><div class="line">    ImageFilledRectangle($image,76,4,96,24,$white);</div><div class="line">    ImageFilledRectangle($image,80,8,92,20,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,0,72,28,500,$black);</div><div class="line">    ImageFilledRectangle($image,4,76,24,96,$white);</div><div class="line">    ImageFilledRectangle($image,8,80,20,92,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,64,64,84,84,$black);</div><div class="line">    ImageFilledRectangle($image,68,68,80,80,$white);</div><div class="line">    ImageFilledRectangle($image,72,72,76,76,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,0,32,20,44,$black);</div><div class="line">    ImageFilledRectangle($image,4,36,8,40,$white);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,4,44,12,48,$black);</div><div class="line">    ImageFilledRectangle($image,0,48,4,68,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,8,52,12,56,$black);</div><div class="line">    ImageFilledRectangle($image,12,48,20,68,$black);</div><div class="line">    ImageFilledRectangle($image,16,52,20,64,$white);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,32,4,36,8,$black);</div><div class="line">    ImageFilledRectangle($image,40,0,44,8,$black);</div><div class="line">    ImageFilledRectangle($image,48,0,52,4,$black);</div><div class="line">    ImageFilledRectangle($image,52,4,56,8,$black);</div><div class="line">    ImageFilledRectangle($image,60,4,64,8,$black);</div><div class="line">    ImageFilledRectangle($image,64,0,68,4,$black);</div><div class="line">    ImageFilledRectangle($image,64,8,68,12,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,48,8,52,16,$black);</div><div class="line">    ImageFilledRectangle($image,52,12,56,20,$black);</div><div class="line">    ImageFilledRectangle($image,56,8,60,16,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,24,56,32,68,$black);</div><div class="line">    ImageFilledRectangle($image,24,60,28,64,$white);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,24,40,28,44,$black);</div><div class="line">    ImageFilledRectangle($image,24,48,28,52,$black);</div><div class="line">    ImageFilledRectangle($image,28,44,32,48,$black);</div><div class="line">    ImageFilledRectangle($image,32,40,36,44,$black);</div><div class="line">    ImageFilledRectangle($image,36,48,44,52,$black);</div><div class="line">    ImageFilledRectangle($image,32,12,44,16,$black);</div><div class="line">    ImageFilledRectangle($image,36,16,40,24,$black);</div><div class="line">    ImageFilledRectangle($image,32,20,36,28,$black);</div><div class="line">    ImageFilledRectangle($image,24,32,40,36,$black);</div><div class="line">    ImageFilledRectangle($image,36,28,48,32,$black);</div><div class="line">    ImageFilledRectangle($image,40,24,44,28,$black);</div><div class="line">    ImageFilledRectangle($image,44,20,68,24,$black);</div><div class="line">    ImageFilledRectangle($image,48,24,52,28,$black);</div><div class="line">    ImageFilledRectangle($image,56,24,60,28,$black);</div><div class="line">    ImageFilledRectangle($image,64,24,68,28,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,32,68,36,100,$black);</div><div class="line">    ImageFilledRectangle($image,32,76,36,80,$white); </div><div class="line"></div><div class="line">    ImageFilledRectangle($image,68,84,84,88,$black);</div><div class="line">    ImageFilledRectangle($image,88,88,92,92,$black);</div><div class="line">    ImageFilledRectangle($image,84,68,88,84,$black);</div><div class="line">    ImageFilledRectangle($image,88,64,92,88,$black);</div><div class="line">    ImageFilledRectangle($image,88,76,92,80,$white);</div><div class="line">    ImageFilledRectangle($image,92,72,96,88,$black);</div><div class="line">    ImageFilledRectangle($image,96,72,100,100,$black);</div><div class="line">    ImageFilledRectangle($image,76,96,96,100,$black);</div><div class="line">    ImageFilledRectangle($image,76,88,80,96,$black);</div><div class="line">    ImageFilledRectangle($image,80,92,88,96,$black);</div><div class="line">    ImageFilledRectangle($image,88,88,92,92,$black);</div><div class="line">    ImageFilledRectangle($image,68,96,72,100,$black);</div><div class="line">    ImageFilledRectangle($image,64,92,68,96,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,68,32,72,36,$black);</div><div class="line">    ImageFilledRectangle($image,76,32,80,44,$black);</div><div class="line">    ImageFilledRectangle($image,84,32,88,36,$black);</div><div class="line">    ImageFilledRectangle($image,92,32,96,44,$black);</div><div class="line">    ImageFilledRectangle($image,64,36,68,44,$black);</div><div class="line">    ImageFilledRectangle($image,68,40,72,44,$black);</div><div class="line">    ImageFilledRectangle($image,84,40,88,44,$black);</div><div class="line">    ImageFilledRectangle($image,96,36,100,48,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,64,48,76,56,$black);</div><div class="line">    ImageFilledRectangle($image,68,52,80,60,$black);</div><div class="line">    ImageFilledRectangle($image,68,52,76,56,$white);</div><div class="line">    </div><div class="line">    ImageFilledRectangle($image,80,48,84,52,$black);</div><div class="line">    ImageFilledRectangle($image,64,60,72,64,$black);</div><div class="line">    ImageFilledRectangle($image,80,60,88,64,$black);</div><div class="line">    ImageFilledRectangle($image,84,52,88,64,$black);</div><div class="line">    ImageFilledRectangle($image,88,48,100,52,$black);</div><div class="line">    ImageFilledRectangle($image,92,52,96,60,$black);</div><div class="line">    ImageFilledRectangle($image,96,56,100,64,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,44,32,48,36,$black);</div><div class="line">    ImageFilledRectangle($image,56,28,64,32,$black);</div><div class="line">    ImageFilledRectangle($image,52,32,60,36,$black);</div><div class="line">    ImageFilledRectangle($image,48,36,56,40,$black);</div><div class="line">    ImageFilledRectangle($image,40,36,44,44,$black);</div><div class="line">    ImageFilledRectangle($image,56,40,64,48,$black);</div><div class="line">    ImageFilledRectangle($image,48,44,52,52,$black);</div><div class="line">    ImageFilledRectangle($image,52,48,56,56,$black);</div><div class="line">    ImageFilledRectangle($image,44,56,64,60,$black);</div><div class="line">    ImageFilledRectangle($image,56,60,60,64,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,36,56,40,64,$black);</div><div class="line">    ImageFilledRectangle($image,40,64,44,72,$black);   </div><div class="line">    ImageFilledRectangle($image,44,60,48,68,$black);  </div><div class="line">    ImageFilledRectangle($image,48,68,56,72,$black);  </div><div class="line">    ImageFilledRectangle($image,52,72,56,80,$black);  </div><div class="line">    ImageFilledRectangle($image,56,72,60,76,$black);  </div><div class="line">    ImageFilledRectangle($image,48,76,52,84,$black);</div><div class="line"></div><div class="line">    ImageFilledRectangle($image,36,72,40,88,$black);</div><div class="line">    ImageFilledRectangle($image,40,76,44,84,$black);</div><div class="line">    ImageFilledRectangle($image,36,96,40,100,$black);</div><div class="line">    ImageFilledRectangle($image,44,88,48,100,$black);</div><div class="line">    ImageFilledRectangle($image,48,88,52,92,$black);</div><div class="line">    ImageFilledRectangle($image,60,68,64,72,$black);</div><div class="line">    ImageFilledRectangle($image,56,80,64,84,$black);</div><div class="line">    ImageFilledRectangle($image,56,92,60,96,$black);</div><div class="line">    </div><div class="line">    // 形成图像</div><div class="line">    Imagepng($image);</div><div class="line">    // 释放空间</div><div class="line">    ImageDestroy($image);</div><div class="line">?&gt;</div></pre></td></tr></table></figure><h5 id="结果（扫一扫啊，哈哈哈）"><a href="#结果（扫一扫啊，哈哈哈）" class="headerlink" title="结果（扫一扫啊，哈哈哈）"></a>结果（扫一扫啊，哈哈哈）</h5><p><img src="http://otn4ut2th.bkt.clouddn.com/bloggenerate.png" alt="二维码"></p><hr><h2 id="更新图"><a href="#更新图" class="headerlink" title="更新图"></a>更新图</h2><h4 id="图一"><a href="#图一" class="headerlink" title="图一"></a>图一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    // 一幅随机图</div><div class="line">    </div><div class="line">    // 文件输出图片格式为png</div><div class="line">    header(&quot;Content-type:image/png&quot;);</div><div class="line">    // 建立一个画布</div><div class="line">    $image = ImageCreate(500,550);</div><div class="line">    // 设定画布的北京颜色</div><div class="line">    $bgcolor = ImageColorAllocate($image,0,0,0);</div><div class="line">    ImageFill($image,0,0,$bgcolor);</div><div class="line">    // 画笔的颜色</div><div class="line">    $black = ImageColorAllocate($image,0,137,167);</div><div class="line"></div><div class="line">    // 绘画过程</div><div class="line"></div><div class="line">    $x2 = 0;</div><div class="line">    for($j = 0;$j &lt; 25; $j++)&#123;</div><div class="line">        // 随机生成圆半径</div><div class="line">        $radius1 = rand(7,12);</div><div class="line">        // 随机点生成一个实心圆</div><div class="line">        $x1 = rand(1,499);</div><div class="line">        $y1 = rand(1,499);</div><div class="line">        for($i = 1;$i &lt; $radius1;$i++)&#123;</div><div class="line">            </div><div class="line">            $w = $i;</div><div class="line">            $h = $i;</div><div class="line">            imagearc($image, $x1,  $y1,  $w,  $h,  0, 360, $black);</div><div class="line">        &#125;</div><div class="line">        if($x2 !== 0)&#123;</div><div class="line">            ImageLine($image,$x1,$y1,$x2,$y2,$black);</div><div class="line">        &#125;</div><div class="line">        // 随机生成圆半径</div><div class="line">        $radius2 = rand(7,12);</div><div class="line">        // 随机再生成一点连接上一点</div><div class="line">        $x2 = rand(1,499);</div><div class="line">        $y2 = rand(1,499);</div><div class="line">        for($i = 1;$i &lt; $radius2;$i++)&#123;</div><div class="line">            </div><div class="line">            $w = $i;</div><div class="line">            $h = $i;</div><div class="line">            imagearc($image, $x2,  $y2,  $w,  $h,  0, 360, $black);</div><div class="line">        &#125;</div><div class="line">        ImageLine($image,$x1,$y1,$x2,$y2,$black);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    // 打出名字</div><div class="line">    $string = &quot;x1067017 杨坤怡&quot;;</div><div class="line">    ImageTTFtext($image,12,0,360,530,$black,&quot;c:/windows/fonts/FZPXJW.TTF&quot;,$string);</div><div class="line"></div><div class="line">    // 形成图像</div><div class="line">    Imagepng($image);</div><div class="line">    // 释放空间</div><div class="line">    ImageDestroy($image);</div><div class="line">?&gt;</div></pre></td></tr></table></figure><h4 id="图二"><a href="#图二" class="headerlink" title="图二"></a>图二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    // 一幅随机图</div><div class="line">    </div><div class="line">    // 文件输出图片格式为png</div><div class="line">    header(&quot;Content-type:image/png&quot;);</div><div class="line">    // 建立一个画布</div><div class="line">    $image = ImageCreate(400,420);</div><div class="line">    // 设定画布的北京颜色</div><div class="line">    $bgcolor = ImageColorAllocate($image,55,60,56);</div><div class="line">    ImageFill($image,0,0,$bgcolor);</div><div class="line">    // 画笔的颜色</div><div class="line">    $black = ImageColorAllocate($image,0,137,108);</div><div class="line"></div><div class="line">    // 绘画过程</div><div class="line"></div><div class="line">    // 随机生成空心三角形</div><div class="line">    $point=array();</div><div class="line">    for($j = 1;$j &lt; 10;$j++)&#123;</div><div class="line">        for($i = 1;$i &lt; 4;$i++)&#123;</div><div class="line">            $x = rand(1,399);</div><div class="line">            $y = rand(1,399);</div><div class="line">            array_push($point,$x,$y);</div><div class="line">        &#125;</div><div class="line">        ImagePolygon($image,$point,count($point)/2,$black);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 打出名字</div><div class="line">    $string = &quot;x1067017 杨坤怡&quot;;</div><div class="line">    ImageTTFtext($image,12,0,250,410,$black,&quot;c:/windows/fonts/FZPXJW.TTF&quot;,$string);</div><div class="line"></div><div class="line">    // 形成图像</div><div class="line">    Imagepng($image);</div><div class="line">    // 释放空间</div><div class="line">    ImageDestroy($image);</div><div class="line">?&gt;</div></pre></td></tr></table></figure><h4 id="图三"><a href="#图三" class="headerlink" title="图三"></a>图三</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    // 绘画一个A字母</div><div class="line">    // 文件输出图片格式为png</div><div class="line">    header(&quot;Content-type:image/png&quot;);</div><div class="line">    // 建立一个画布</div><div class="line">    $image = ImageCreate(400,400);</div><div class="line">    // 设定画布的北京颜色</div><div class="line">    $bgcolor = ImageColorAllocate($image,0,0,0);</div><div class="line">    ImageFill($image,0,0,$bgcolor);</div><div class="line">    // 画笔的颜色</div><div class="line">    $black = ImageColorAllocate($image,241,124,103);</div><div class="line"></div><div class="line">    // 绘画过程</div><div class="line"></div><div class="line">    // for($i = 1;$i &lt; 6;$i++)&#123;</div><div class="line">    //     $w = $i * 15;</div><div class="line">    //     $h = $i * 15;</div><div class="line">    //     imagearc($image, 250,  250,  $w,  $h,  0, 360, $black);</div><div class="line">    // &#125;</div><div class="line"></div><div class="line">    $start = 0;</div><div class="line">    $stop = 120;</div><div class="line">    for($i = 1;$i &lt; 13;$i++)&#123;</div><div class="line">        $w = $i * 25;</div><div class="line">        $h = $i * 25;</div><div class="line">        imagearc($image, 200,  200,  $w,  $h,  $start, $stop, $black);</div><div class="line">        $start += 1*$i;</div><div class="line">        $stop -= 1*$i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $start = 120;</div><div class="line">    $stop = 240;</div><div class="line">    for($i = 1;$i &lt; 13;$i++)&#123;</div><div class="line">        $w = $i * 25;</div><div class="line">        $h = $i * 25;</div><div class="line">        imagearc($image, 200,  200,  $w,  $h,  $start, $stop, $black);</div><div class="line">        $start += 1*$i;</div><div class="line">        $stop -= 1*$i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $start = 240;</div><div class="line">    $stop = 360;</div><div class="line">    for($i = 1;$i &lt; 13;$i++)&#123;</div><div class="line">        $w = $i * 25;</div><div class="line">        $h = $i * 25;</div><div class="line">        imagearc($image, 200,  200,  $w,  $h,  $start, $stop, $black);</div><div class="line">        $start += 1*$i;</div><div class="line">        $stop -= 1*$i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 打出名字</div><div class="line">    $string = &quot;x1067017 杨坤怡&quot;;</div><div class="line">    ImageTTFtext($image,12,0,250,370,$black,&quot;c:/windows/fonts/FZPXJW.TTF&quot;,$string);</div><div class="line"></div><div class="line"></div><div class="line">    // 形成图像</div><div class="line">    Imagepng($image);</div><div class="line">    // 释放空间</div><div class="line">    ImageDestroy($image);</div><div class="line">?&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;web课程的笔记和一些实例代码。还有一份自定义图形作业，感觉还不错，简单做了一个二维码。（全是画矩形，确实有点无聊了，有空画点有趣的图）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yangkunyi.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="PHP" scheme="http://yangkunyi.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>WeeklyMind-5</title>
    <link href="http://yangkunyi.com/2017/12/24/WeeklyMind-5/"/>
    <id>http://yangkunyi.com/2017/12/24/WeeklyMind-5/</id>
    <published>2017-12-24T04:23:09.000Z</published>
    <updated>2017-12-24T04:24:03.666Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本周开始学习都开始进入最后的报告和复习阶段，不动产报告， 人际关系报告，以及接下来的行销报告和各种总结，然后是期末考试复习，所以这两个周不太有时间自学了。<br><a id="more"></a></p></blockquote><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul><li><p>不动产管理小组报告：可能因为对这边的一些名词不太熟悉，所以报告的时候自己有一点说不清楚，不知道该如何表达自己的想法；不过也是没有准备充分的表现。</p></li><li><p>人际关系小组报告：我们小组的主题是社交软件对大学生人际关系的影响，自己准备的ying<br>影响的好坏部分，这次就好很多了，自己有事先练习自己不熟悉的稿子，报告的时候就能很顺利的讲下来。</p></li><li><p>行销管理小组讨论：这样的小组讨论是很重要的我觉得，以后作为一个想要在互联网公司工作的人，这种小组讨论的能力是必须具备的，而自己在讨论中的表现还算行，队友们也很给力，最后分工也很快敲定下来，希望最后的小组报告也能一切顺利。</p></li><li><p>财务管理和西方哲学史也都剩下最后一节课了，所以要抓紧时间复习了啊！</p></li></ul><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul><li>本周的天气都不错，前两天很冷，后面都有着充足的阳光。</li><li>周四人际关系报告完回寝室的路上，在马路中间和它相遇了，它就好像在那里等我一样，我当时还在看手机，却不经意的一个转头，看见它就那样安静的躺在马路上，心里当时唯一的想法就是不要让来往的车辆压着它了，于是把它带了回来。<br><img src="http://otn4ut2th.bkt.clouddn.com/blogTIM%E5%9B%BE%E7%89%8720171224121759.jpg" alt="此处输入图片的描述"></li><li>今天是平安夜，明天是圣诞节，作为一个不怎么过圣诞节的我来说，吃一个苹果就足够了，还有就是今晚和室友约着去吃火（tang）锅，这可能是自己在这边的最后一顿火锅了吧！</li><li>周五去看了旁边的交大，只是去吃了有名的松饼，所以也没有来得及细看整个学校，唯一的感觉就是看到的建筑都很有设计感。</li></ul><h2 id="待更新事项"><a href="#待更新事项" class="headerlink" title="待更新事项"></a>待更新事项</h2><ul><li>不动产管理上节课的评价和学期总结</li><li>关于台湾的三千字</li><li>复习</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本周开始学习都开始进入最后的报告和复习阶段，不动产报告， 人际关系报告，以及接下来的行销报告和各种总结，然后是期末考试复习，所以这两个周不太有时间自学了。&lt;br&gt;
    
    </summary>
    
    
      <category term="-周记" scheme="http://yangkunyi.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>WeeklyMind-4</title>
    <link href="http://yangkunyi.com/2017/12/17/WeeklyMind-4/"/>
    <id>http://yangkunyi.com/2017/12/17/WeeklyMind-4/</id>
    <published>2017-12-17T04:52:37.000Z</published>
    <updated>2017-12-17T04:54:01.515Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这个周开始都开始准备各科的报告和总结了，所以不是在写报告就是在做ppt，周五下午有抽空学习node，看了N-blog项目的大概，但是困难出在MongoDB，虽然连上了，项目跑起来了，但是并没有懂其中的原理，之后会继续理解。</p></blockquote><a id="more"></a><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><ul><li>web学了PHP的绘画，还画了一个二维码。</li><li>不动产管理报告</li><li>人际关系报告</li><li>完成了毛概</li><li>不定期更新微信</li></ul><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><ul><li>进入自己想要的规律状态，但是每天运动量还是太少了，可能是气温太低了，自己也没有想出门。</li><li>今天晚上准备去买水果，维生素还是不能少</li><li>真的不是很喜欢这边的食物，吃的不是很开心，开始想奶奶做得菜了</li><li>昨晚和一个同龄的妹子聊到了父母的期望和自己想做的有偏差，自己将自己想做的都告诉了她，那是因为自己也想像自己所说的那么坚持，坚持做自己想做的事情，父母的期望并不想辜负，尽自己最大的努力去达到他们想看到的样子，但是这并不意味着我不能做自己，这并不是矛盾的关系，很多情况下自己的想法和父母的想法是可以共存的。父母希望自己把心思放在学习上，只不过想自己的成绩能够过得去，那自己在保证了成绩的前提下做的事情父母也会接受的，获许还更可能得到支持。所以我觉得不能把自己的想法和父母的想法完全对立起来吧，换一种看法，就像前面所说的，是可以共存的。</li></ul><h3 id="待更进事项"><a href="#待更进事项" class="headerlink" title="待更进事项"></a>待更进事项</h3><ul><li>西方哲学整理复习</li><li>财务管理复习（考课后题，我就把课后题全做一遍总可以了吧！死记硬背我都给你过了。。。）</li><li>行销管理报告，视频，ppt</li><li>继续学习英语</li></ul><blockquote><p>已经开始倒数着回去的日子了，是真的想家了吧！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这个周开始都开始准备各科的报告和总结了，所以不是在写报告就是在做ppt，周五下午有抽空学习node，看了N-blog项目的大概，但是困难出在MongoDB，虽然连上了，项目跑起来了，但是并没有懂其中的原理，之后会继续理解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="周记" scheme="http://yangkunyi.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>NeverLimitYourself</title>
    <link href="http://yangkunyi.com/2017/12/14/NeverLimitYourself/"/>
    <id>http://yangkunyi.com/2017/12/14/NeverLimitYourself/</id>
    <published>2017-12-14T13:01:57.000Z</published>
    <updated>2017-12-14T13:10:43.630Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看完C菌的视频有感而发，想说一些话！</p></blockquote><a id="more"></a><p>自己正是出于这样的原因选择来到台湾交流学习，我想看看那远离我的生活的地方有什么不一样，那里的生活是怎么样的？那里的人是怎么样的？那里的猫也是那么懒吗？…</p><p>于是九月四日踏上里人生的第一次飞机之旅，短短三个小时，来到了这个离家一千多千米的岛上。一切都是那么好奇，现在的我已经在这里快四个月了，学习生活也都很顺手了，该体验的自己也都体验到了，再也不会像刚来的前几周那样充满不安的焦虑，或许这就是成长吧。</p><p>在申请这个交换机会的时候，自己曾给自己找各种理由，但最后还是只能说：我就是想看看。</p><p>自己在最开始的时候焦虑一个是因为陌生环境的压力；另一个原因是自己看到了自己相看的东西之后，心里突然之间有一瞬间感觉空空的，不知道自己之后该做什么了，整个人好像在这里生活着没什么意思了，同时本校也开学了，看着同学们开学的动态，那种叫做孤独的东西一下子就从心里冒了出来。可是别人还在“羡慕”的“恭维”和祝贺自己来到这里，所以自己还要打起精神来应付，为了来这里之前说下的那句：“我想去看看！”没错，那个时候每天都很丧，过得很混沌。</p><p>那个时候只有父母算生活动力，想着他们为了让自己出来看看所做的努力，自己真的没理由就这样混沌的过，但同时这种压抑的感觉又让自己整个人感觉很紧绷，所以也是压力吧。自己没有自觉与他们联系的习惯，在本校的时候一个月也是要回家的时候才会联系一下，所以根本不知道平时有什么好跟他们说的。不过为了让他们不担心自己的生活和学习，自己还是学会了每隔两天报告一下平安，是真的只有一个“报”字的报平安。不过母上大人还是想自己的，偶尔会在晚上和自己视频一下，说一下家里的情况，自己也会简单的报告一下自己的近况，虽然自己初中以来就是住校，但这次毕竟隔得比较远，所以其实真的是有些想他们了。</p><p>然后终于那句：“意义这种事情只有在做过之后才知道，之前说的意义都是肤浅的认知罢了！”解决了让自己失眠一个周的问题，终于将急躁的心放到了肚子里，开始慢慢享受每一天的生活，早起，看书，上课，写作业，跑步…终于生活算是步入了正轨。</p><p>正式抱着这样的心态，中间出去短途旅行了三次，那才叫真的看到了自己看到的，由于马上要期末考试了，所以之后应该不会再出去了。不过这三次的记忆就足以抵上前三个月的努力了，接下来就好好准备课程相关报告和考试吧。</p><p>经过这四个月的生活后，那种不知名意义好像快要浮出水面的时候，看到了C菌的Nerver Limit Yourself，自己终于找到了可以表达自己心情的句子：</p><blockquote><p>Never limit yourself because of others’ limited imagination; never limit others because of your own limited imagination.<br>— MAE JEMISON</p></blockquote><p>ps:如果想了解本人在台湾的更多近况，可以扫描下面的公众号二维码。（可能这就是广告吧。）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;看完C菌的视频有感而发，想说一些话！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="日常" scheme="http://yangkunyi.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="随笔记" scheme="http://yangkunyi.com/tags/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
      <category term="观后感" scheme="http://yangkunyi.com/tags/%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>WeeklyMind-3</title>
    <link href="http://yangkunyi.com/2017/12/10/WeeklyMind-3/"/>
    <id>http://yangkunyi.com/2017/12/10/WeeklyMind-3/</id>
    <published>2017-12-10T09:30:09.000Z</published>
    <updated>2017-12-10T11:35:18.462Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本周很日常，只是感觉自己有点缺乏锻炼，所以显得不是特别的精神，可能也和天气有关系，开始凉了，自己也没带什么厚衣服，所以没课都不怎么出门的那种。</p></blockquote><a id="more"></a><h4 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h4><ul><li>各科课程进行正常</li><li>但并没有完成本校作业</li><li>完成了第一次不动产小组报告，虽然内容很尬，但是表现自己还算满意</li><li>关于人际关系的人际圈，自己在课堂上画出不同的圈也让自己十分的意外，但这也是自己本身的看法罢了，或许这才是最真实的自己</li><li>让自己丧了一天的财务管理期中成绩也是真的令自己心碎啊</li><li>了解了一些数据库的知识，应该叫复习了，毕竟之前还是多少学了一点</li><li>node要努力了，时间的零碎学起来也是很零碎</li></ul><h4 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h4><ul><li>这一周缺乏锻炼，怎么感觉又长胖了。。。</li><li>稍微一点混沌，可能躺太多</li><li>手臂在乒乓球课崴了，一直一点酸疼</li><li>吃饭特别不规律！！！这一点下个周一定得改了</li><li>对了，微信终于开始了，不过进度貌似不能保证每天，所以自己准备改一下，暂时上学期间频率保持一周两篇吧，如果空闲的周可以多做一点</li></ul><h4 id="待更进事项"><a href="#待更进事项" class="headerlink" title="待更进事项"></a>待更进事项</h4><ul><li>通信作业的问题回答</li><li>还是抽时间把毛概的论文写了吧，毕竟回去可能还真的可以考试呢</li><li>node</li><li>php继续学习</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本周很日常，只是感觉自己有点缺乏锻炼，所以显得不是特别的精神，可能也和天气有关系，开始凉了，自己也没带什么厚衣服，所以没课都不怎么出门的那种。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="周记" scheme="http://yangkunyi.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>用户验证与数据库</title>
    <link href="http://yangkunyi.com/2017/12/06/%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yangkunyi.com/2017/12/06/用户验证与数据库/</id>
    <published>2017-12-06T12:22:28.000Z</published>
    <updated>2017-12-06T12:25:46.194Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是今天web课程的笔记，亲自尝试了前面两种验证方式，第三种方式之前也有所接触，还都算比较好理解。后面还有一些数据库的简单解释。</p></blockquote><a id="more"></a><h2 id="验证用户方法"><a href="#验证用户方法" class="headerlink" title="验证用户方法"></a>验证用户方法</h2><h3 id="1-HTTP自带的验证"><a href="#1-HTTP自带的验证" class="headerlink" title="1. HTTP自带的验证"></a>1. HTTP自带的验证</h3><blockquote><p>这种方式是利用HTTP所提供的验证头信息来对用户进行身份验证。由于这种凡是对大量的使用者缺乏有效的管理，在用户太多时并没有太大用处，因此少量用户时使用。例如开发人员。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;?php </div><div class="line">    // 如果 $PHP_AUTH_USER 不等于 &quot;tea&quot;，就进不去网站。 </div><div class="line">    if($_SERVER[&apos;PHP_AUTH_USER&apos;] !=&apos;tea&apos; || $_SERVER[&apos;PHP_AUTH_PW&apos;] !=&apos;ok&apos;)&#123; </div><div class="line">    //通过头部信息告知浏览器验证</div><div class="line">    header(&apos;WWW-Authenticate: Basic realm=&quot;「需验证」---请输入账户/密码&quot;&apos;); </div><div class="line">    header(&apos;HTTP/1.0 401 Unauthorized&apos;); </div><div class="line">    echo &quot;账号或密码错误。请刷新重新输入。&quot;; </div><div class="line">    </div><div class="line">    //记得要加上 exit() 离开，不然就跟没有验证一样了！ </div><div class="line">    exit(); </div><div class="line">    &#125; </div><div class="line">    /* </div><div class="line">    如果用户输入正确的账户和密码，下面的 HTML 就会显示 </div><div class="line">    */ </div><div class="line">    ?&gt; </div><div class="line">&lt;HTML&gt; </div><div class="line">    &lt;HEAD&gt; </div><div class="line">        &lt;TITLE&gt;&lt;/TlTLE&gt; </div><div class="line">    &lt;/HEAD&gt; </div><div class="line"></div><div class="line">    &lt;BODY&gt; </div><div class="line">        &lt;P&gt;Hello World！&lt;/P&gt; </div><div class="line">    &lt;/BODY&gt; </div><div class="line">&lt;/HTML&gt;</div></pre></td></tr></table></figure><h3 id="2-htaccess方式的验证"><a href="#2-htaccess方式的验证" class="headerlink" title="2. htaccess方式的验证"></a>2. <code>htaccess</code>方式的验证</h3><blockquote><p>这种凡是其实时Apche所提供的加强版HTTP验证方式，利用Apche所提供的<code>htpasswd</code>来设定使用者账号和密码。但是任然不适用过多用户。</p></blockquote><h4 id="首先建立用户数据（授权的动作）"><a href="#首先建立用户数据（授权的动作）" class="headerlink" title="首先建立用户数据（授权的动作）"></a>首先建立用户数据（授权的动作）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 第一次 -c，第二次添加就不需要了</div><div class="line">c:\appserv\apache\bin&gt; htpasswd -c htusers Tom </div><div class="line">New password: ←输入用户密码 </div><div class="line">Re-type new password: ←再次输入 </div><div class="line">Adding password for user Tom</div><div class="line"></div><div class="line">c:\appserv\apache\bin&gt; htpasswd htusers Jack </div><div class="line">New password: </div><div class="line">Re-type new password: </div><div class="line">Adding password for user Jack</div><div class="line"></div><div class="line">// 可以将不同的人进行分组，group是群组名称</div><div class="line">group:Tom Jack</div></pre></td></tr></table></figure><h4 id="然后在需要权限才可以进入的路径中建-htaccess文档（将已授权和访问地址联系到一起）"><a href="#然后在需要权限才可以进入的路径中建-htaccess文档（将已授权和访问地址联系到一起）" class="headerlink" title="然后在需要权限才可以进入的路径中建.htaccess文档（将已授权和访问地址联系到一起）"></a>然后在需要权限才可以进入的路径中建<code>.htaccess</code>文档（将已授权和访问地址联系到一起）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 显示给用户看的提示</div><div class="line">AuthName &quot;登陆时需要输入账号和密码「账号」与「密码」&quot; </div><div class="line">// 验证时不编码</div><div class="line">AuthType Basic </div><div class="line">// 之前建立的用户数据</div><div class="line">AuthUserFile c:\appserv\apache\bin\htusers </div><div class="line">#AuthGroupFile c:\appserv\apache\bin\htgroup </div><div class="line">// 所有访问的都需要验证</div><div class="line">require valid-user </div><div class="line">#require user jollen </div><div class="line">#require group ieem316 </div><div class="line">// 定义说拒绝所有，允许个别</div><div class="line">order deny,allow </div><div class="line">deny from all </div><div class="line">#allow from .nthu.edu.tw </div><div class="line">allow from 140.114.70.31</div></pre></td></tr></table></figure><h3 id="3-数据库存储用户数据"><a href="#3-数据库存储用户数据" class="headerlink" title="3. 数据库存储用户数据"></a>3. 数据库存储用户数据</h3><blockquote><p>最有效，最普遍的做法，将用户的账户和密码存在数据库中，每次登陆到数据库中查找数据，最后返回有无和正确性。</p></blockquote><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol><li>登陆的表单</li><li>登陆的程序</li><li>建好用户的资料库，至少要包括账号和密码</li></ol><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>通过表单获取用户账号与密码</li><li>到数据库中查找对应的账号和密码</li><li>失败就返回重新获取信息，直到成功为止</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 本程序通过头信息获取的用户的账户和密码</div><div class="line">&lt;?php </div><div class="line">    // 如果用户沒有输入账户，要求用户重新验证。 </div><div class="line">    IF(!isset($PHP_AUTH_USER))&#123; </div><div class="line">        header(&apos;WWW-Authenticate: Basic realm=&quot;请输入账号和密码&quot;&apos;); </div><div class="line">        header(&apos;HTTP/1.0 401 Unauthorized&apos;); </div><div class="line">        echo &quot;刷新后重新登陆&quot;; </div><div class="line">        exit(); </div><div class="line">    &#125;</div><div class="line">    else&#123; </div><div class="line">        mysql_connect(&quot;localhost&quot;,&quot;admin&quot;,&quot;asdee4&quot;) or die (&quot;无法连接 MySQL&quot;); </div><div class="line">        rnysql_select_db(&quot;members&quot;) or die(&quot;无法连接数据库&quot;); </div><div class="line">        $query=&quot;select id from users where username=&apos;$PHP_AUTH_USER&apos; and </div><div class="line">        password=&apos;$PHP_AUTH_PW&apos;&quot;; </div><div class="line">        $result=mysql_query($query); </div><div class="line">        $n_rows=mysql_num_rows($result); </div><div class="line">        mysql_close(); </div><div class="line">        // 当row&lt;1时，用户账号与密码有错，重新登陆</div><div class="line">        if($n_rows &lt; 1)&#123; </div><div class="line">            header(&apos;WWW_Authenticate: Basic realm=&quot;请输入账号和密码&quot;&apos;); </div><div class="line">            header(&apos;HTTP/1.0 401 Unauthorized&apos;); </div><div class="line">            echo &quot;刷新重新登陆&quot;; </div><div class="line">            exit(); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">?&gt;</div></pre></td></tr></table></figure><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="数据库系统-数据库管理系统-数据库"><a href="#数据库系统-数据库管理系统-数据库" class="headerlink" title="数据库系统 = 数据库管理系统 + 数据库"></a>数据库系统 = 数据库管理系统 + 数据库</h3><h4 id="DBMS（数据库管理系统）：database-management-system"><a href="#DBMS（数据库管理系统）：database-management-system" class="headerlink" title="DBMS（数据库管理系统）：database management system"></a>DBMS（数据库管理系统）：database management system</h4><ul><li>只是一个软件</li><li>作用：资料的管理和维护</li></ul><h4 id="DB（数据库）：database"><a href="#DB（数据库）：database" class="headerlink" title="DB（数据库）：database"></a>DB（数据库）：database</h4><h3 id="SQL（structure-query-language）：结构化查询语句"><a href="#SQL（structure-query-language）：结构化查询语句" class="headerlink" title="SQL（structure query language）：结构化查询语句"></a>SQL（structure query language）：结构化查询语句</h3><ul><li>第一代：89</li><li>第二代：92（绝大部分数据库所遵循的规则）</li><li>第三代：99（没有成立）</li></ul><h4 id="DDL（data-definition-language）：数据库和数据表定义语言"><a href="#DDL（data-definition-language）：数据库和数据表定义语言" class="headerlink" title="DDL（data definition language）：数据库和数据表定义语言"></a>DDL（data definition language）：数据库和数据表定义语言</h4><ul><li>create<ul><li>database</li><li>table</li></ul></li><li>drop<ul><li>database</li><li>table</li></ul></li><li>alter（改变数据库的结构）<ul><li>table</li></ul></li></ul><h4 id="DML（data-manipulation-language）：数据处理语言"><a href="#DML（data-manipulation-language）：数据处理语言" class="headerlink" title="DML（data manipulation language）：数据处理语言"></a>DML（data manipulation language）：数据处理语言</h4><ul><li>select（查询）</li><li>insert [into]（添加）</li><li>delete（删除）</li><li>updata（单个属性的改变）</li></ul><h4 id="DCL（data-control-language）：数据库控制语言"><a href="#DCL（data-control-language）：数据库控制语言" class="headerlink" title="DCL（data control language）：数据库控制语言"></a>DCL（data control language）：数据库控制语言</h4><ul><li>grant（授权）</li><li>revoke（取消授权）</li></ul><h3 id="使用者"><a href="#使用者" class="headerlink" title="使用者"></a>使用者</h3><ul><li>DBO（database operater）</li><li>DBA（database administrator）：root/password</li></ul><h3 id="简单的结构"><a href="#简单的结构" class="headerlink" title="简单的结构"></a>简单的结构</h3><pre><code>DB Server（数据库服务器） DB（数据库）  table（数据表）   record（）    field     charset</code></pre><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol><li>链接数据库</li><li>use/create：database</li><li>create：table/改变资料表里面的数据</li></ol><h3 id="数据库操作方法"><a href="#数据库操作方法" class="headerlink" title="数据库操作方法"></a>数据库操作方法</h3><ul><li>通过程式（php）</li><li>通过命令行<ul><li>-u：使用者</li><li>-h：主机</li><li>-p：密码</li></ul></li><li>通过图形界面（软件）</li></ul><h3 id="PHP-amp-数据库"><a href="#PHP-amp-数据库" class="headerlink" title="PHP &amp; 数据库"></a>PHP &amp; 数据库</h3><h4 id="1-连接数据库"><a href="#1-连接数据库" class="headerlink" title="1. 连接数据库"></a>1. 连接数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$db = mysql_connect（数据库主机名称或ip,数据库账号,数据库密码）;</div><div class="line">      or die(&quot;无法连接数据库服务器&quot;);</div></pre></td></tr></table></figure><h4 id="2-使用数据库"><a href="#2-使用数据库" class="headerlink" title="2. 使用数据库"></a>2. 使用数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql_ select_db(名称,$db);</div><div class="line">    or die(&quot;无法连接数据库&quot;);</div></pre></td></tr></table></figure><h4 id="3-对数据进行操作"><a href="#3-对数据进行操作" class="headerlink" title="3. 对数据进行操作"></a>3. 对数据进行操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sql = &quot;(此处就是SQL指令)&quot;;</div></pre></td></tr></table></figure><h4 id="4-用变量对数据进行存取"><a href="#4-用变量对数据进行存取" class="headerlink" title="4. 用变量对数据进行存取"></a>4. 用变量对数据进行存取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$result = mysql_query($sql,$db);</div></pre></td></tr></table></figure><h4 id="5-最后关闭数据库"><a href="#5-最后关闭数据库" class="headerlink" title="5. 最后关闭数据库"></a>5. 最后关闭数据库</h4><blockquote><p>当取到数据的时候就可以关掉了，这样可以降低数据库风险。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql_close($db);</div></pre></td></tr></table></figure><h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><ul><li>sql指令可以大小写，但各种数据库名称和数据表名称要区别大小写。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是今天web课程的笔记，亲自尝试了前面两种验证方式，第三种方式之前也有所接触，还都算比较好理解。后面还有一些数据库的简单解释。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yangkunyi.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="PHP" scheme="http://yangkunyi.com/tags/PHP/"/>
    
      <category term="验证" scheme="http://yangkunyi.com/tags/%E9%AA%8C%E8%AF%81/"/>
    
      <category term="数据库" scheme="http://yangkunyi.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>坎帕斯学院讨论日常-2</title>
    <link href="http://yangkunyi.com/2017/12/03/%E5%9D%8E%E5%B8%95%E6%96%AF%E5%AD%A6%E9%99%A2%E6%97%A5%E5%B8%B8%E8%AE%A8%E8%AE%BA-2/"/>
    <id>http://yangkunyi.com/2017/12/03/坎帕斯学院日常讨论-2/</id>
    <published>2017-12-03T13:23:28.000Z</published>
    <updated>2017-12-03T13:25:19.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是第二次整理讨论的内容，本次内容有点深奥，值得细嚼慢咽。<br><a id="more"></a></p></blockquote><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul><li>高并发(High Concurrency)<ul><li>指通过设计保证系统能够同时并行处理很多请求。</li><li>是互联网分布式系统架构设计中必须考虑的因素之一。</li></ul></li><li>高性能(High performance)<ul><li>目前理解就是提高浏览网页的速度。</li></ul></li><li>高可用(High Availability)<ul><li>通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。</li></ul></li><li>高扩展性(High Extensibility)<ul><li>通常和可伸缩性混为一谈.在软件范畴上，是软件系统本身的属性，或者进一步说是设计的属性，代码的属性。 </li></ul></li><li>高可维护性(High Maintainability)<ul><li>是衡量一个系统的可修复(恢复)性和可改进性的难易程度。</li></ul></li></ul><h3 id="接口的高可用性"><a href="#接口的高可用性" class="headerlink" title="接口的高可用性"></a>接口的高可用性</h3><blockquote><p>保证这个接口在任何情况下都可以正确的取到数据。</p></blockquote><ul><li>方案一：每次访问的时候将a接口的数据存在本地，第二次访问的时候接口如果gg了，可以直接在本地获取数据，然后渲染出来；（前提是访问过a接口）</li><li>方案二：推oss或者cdn；每次访问了一个接口，然后服务器把返回的数据生成文件推送到一个静态资源服务器上去；<ul><li>好处：比如某人访问了接口，静态资源服务器就会缓存a里面的数据，这时候gg了，其他人依然可以请求到oss上的数据；（逻辑是前端做到的，但是数据推到oss上是从后台推上去的）</li><li>oss几乎不可能gg，原因是它只是一个静态资源存储的地方；</li></ul></li><li>默认数据：（假数据）当接口不可用的时候，用这个自己做的数据；</li></ul><blockquote><p>目前企业的解决方案是：先走服务器接口，若是gg了；再访问本地缓存；若没有，则访问oss。</p></blockquote><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><ul><li>优点：<ul><li>如果第一次没有访问对应的接口就没有本地缓存；</li><li>数据的时效性不够；</li></ul></li><li>缺点：<ul><li>快，不用通过网络请求；</li></ul></li></ul><h4 id="缓存地点"><a href="#缓存地点" class="headerlink" title="缓存地点"></a>缓存地点</h4><ul><li>缓存类型：<ul><li><code>sessionStorage</code>：只在当次回话有效，不会带到每一个请求里面去；</li><li><code>indexDB</code>：浏览器支持度很低，也就是说兼容问题很大；</li><li><code>cookie</code>：过期时间可以设置，默认是浏览器当期回话结束失效；cookie很小；每次对应域名是会在每个请求头带过去，浪费资源，所以限制了大小，如果不限制，就会跟上传文件没有区别了，会导致特别慢；对于数据接口，我们不能保证内容有多大，而且每个接口数据都要缓存，所以不能用cookie。</li><li><code>localstorage</code>：没有大小限制；</li></ul></li></ul><blockquote><p>以上都属于这两种类型：</p><ol><li>（私有）浏览器缓存：单个用户，你浏览过的页面浏览器缓存起来。</li><li>（共享）代理缓存：多个用户，所在公司自己架构的，减少网络拥堵与延迟。</li></ol></blockquote><h3 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h3><h4 id="浏览器请求一个资源，是怎么判断取缓存还是找服务器下载？"><a href="#浏览器请求一个资源，是怎么判断取缓存还是找服务器下载？" class="headerlink" title="浏览器请求一个资源，是怎么判断取缓存还是找服务器下载？"></a>浏览器请求一个资源，是怎么判断取缓存还是找服务器下载？</h4><p><img src="http://otn4ut2th.bkt.clouddn.com/blog201211281402438011.png" alt="浏览器缓存"></p><h4 id="状态码304是怎么产生的？"><a href="#状态码304是怎么产生的？" class="headerlink" title="状态码304是怎么产生的？"></a>状态码304是怎么产生的？</h4><ul><li>是因为本地文件设置的信息头部过期了，去服务器拉取，然后服务器告诉我，其实你的文件还尚未过期，让你回自己本地取资源；</li></ul><h4 id="状态码200（from-cache）是怎么产生的？"><a href="#状态码200（from-cache）是怎么产生的？" class="headerlink" title="状态码200（from cache）是怎么产生的？"></a>状态码200（from cache）是怎么产生的？</h4><ul><li>一定是通过了请求并且成功然后返回的状态码，方式<code>get</code>或者<code>post</code>。</li></ul><blockquote><p>以上的问题只是有所了解了，但是关于浏览器的缓存机制还没有系统的了解，自己在看官方文档的时候，感觉有点困惑，所以先在这里埋个种子。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是第二次整理讨论的内容，本次内容有点深奥，值得细嚼慢咽。&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yangkunyi.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="问题" scheme="http://yangkunyi.com/tags/%E9%97%AE%E9%A2%98/"/>
    
      <category term="讨论" scheme="http://yangkunyi.com/tags/%E8%AE%A8%E8%AE%BA/"/>
    
      <category term="浏览器缓存" scheme="http://yangkunyi.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    
      <category term="状态码" scheme="http://yangkunyi.com/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>WeeklyMind-2</title>
    <link href="http://yangkunyi.com/2017/12/02/WeeklyMind-2/"/>
    <id>http://yangkunyi.com/2017/12/02/WeeklyMind-2/</id>
    <published>2017-12-02T04:29:09.000Z</published>
    <updated>2017-12-02T06:43:47.499Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>忙碌的一周，这都是浪三天的后遗症。上周的周记都在浪中忘记了，但是心情还是很开心的。</p></blockquote><a id="more"></a><h3 id="总结上两周"><a href="#总结上两周" class="headerlink" title="总结上两周"></a>总结上两周</h3><h5 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h5><blockquote><p>期中考试和报告全部完成，成绩一般，接下来又要开始准备期末考试了，来台湾三个月了，自己也在想这一趟来的值不值。</p></blockquote><ul><li><p>课程：</p><ul><li>突然对不动产的作业很是上心，希望在同学和老师们面前不丢咱大陆学生的脸</li><li>为了行销管理的期中报告，自己也算是呕心沥血了，希望不要太差</li><li>西方哲学到康德部分，开始有点抽象到不懂了，还是知识面太狭窄了</li><li>财务管理课程让自己彻底对经融课程失望了，自己是真的不适合学习，修这门课都当作了解吧</li><li>突然觉得人际交往是一门很重要的课程，既认识了自己，也认识了别人</li><li>这两个周因为中间的各种考试和报告，时间有点混乱，所以接下来应该好好计划</li></ul></li><li><p>其它</p><ul><li>http缓存机制的了解，周末希望能理解完</li><li>继续学习了php</li><li>了解php架构包中如何建wordpress以及评论板块（但是发现自己对数据库的认识还不够，导致在尝试过程中老是出现问题）</li></ul></li></ul><h5 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h5><blockquote><p>上个周末算是很精彩了，一趟三天两夜的旅行回来，也导致了博客的的各种托更。</p></blockquote><ul><li><p>台南：</p><ul><li>赤崁楼</li><li>安平古堡</li><li>安平树屋</li><li>安平老街</li></ul></li><li><p>高雄</p><ul><li>夜市</li><li>爱河</li><li>真爱码头</li><li>西子湾</li><li>中山大学</li></ul></li></ul><p>也算是见过真正的浪了！</p><h5 id="待更进事项"><a href="#待更进事项" class="headerlink" title="待更进事项"></a>待更进事项</h5><ul><li>12月计划</li><li>微信订阅号</li><li>各种作业</li><li>前端书籍（每天给点时间来做，积累最重要）</li></ul><blockquote><p>今年的最后一个月，完成你年初的计划可好，少年！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;忙碌的一周，这都是浪三天的后遗症。上周的周记都在浪中忘记了，但是心情还是很开心的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="周记" scheme="http://yangkunyi.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>WeeklyMind-1</title>
    <link href="http://yangkunyi.com/2017/11/19/WeeklyMind-1/"/>
    <id>http://yangkunyi.com/2017/11/19/WeeklyMind-1/</id>
    <published>2017-11-19T06:11:30.000Z</published>
    <updated>2017-12-02T06:43:35.669Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>寻常的一周，不过做了许多的决定，之后每一周也希望自己能坚持做一下简单的总结。</p></blockquote><a id="more"></a><h3 id="总结上周"><a href="#总结上周" class="headerlink" title="总结上周"></a>总结上周</h3><h4 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h4><ul><li>新买的T恤很喜欢</li><li>吃得很随便，但不失营养，老年人一样的生活，哈哈哈</li><li>住的寝室，还是比较宅，之后希望有时间，还是多出去走走看看</li><li>这周没怎么出门，最近在准备各种考试和期中报告</li></ul><h4 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h4><ul><li><p>课程：</p><ul><li>人际考试</li><li>周三运动会放假</li><li>复习财管</li><li>其它课程一切照常进行</li><li>完成日常作业</li></ul></li><li><p>其它</p><ul><li>申请和绑定了域名</li><li>博客主题修改</li><li>了解nodeppt</li><li>简单的看了一下网易云api（有准备做一个音乐播放器）</li></ul></li></ul><h2 id="待更进事项"><a href="#待更进事项" class="headerlink" title="待更进事项"></a>待更进事项</h2><ul><li>复习财管（周三考试）</li><li>电商案例分析</li><li>人际期中报告</li><li>不动产课堂报告</li><li>课程小节论文</li><li>通信英语ppt</li><li>继续学习php</li><li>更新博客</li><li>日常作业</li></ul><blockquote><p>最后还有锻炼，这个事情还是比较重要的。按照自己的计划腾出锻炼的时间，保持健康，毕竟在这个遥远的地方没有买保险。。。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;寻常的一周，不过做了许多的决定，之后每一周也希望自己能坚持做一下简单的总结。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="周记" scheme="http://yangkunyi.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>PHP学习笔记</title>
    <link href="http://yangkunyi.com/2017/11/17/PHP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yangkunyi.com/2017/11/17/PHP学习笔记/</id>
    <published>2017-11-17T09:55:52.000Z</published>
    <updated>2017-12-02T06:42:30.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是一些PHP的基础知识，自己看书的时候做的一些笔记。</p></blockquote><a id="more"></a><h2 id="PHP变量"><a href="#PHP变量" class="headerlink" title="PHP变量"></a>PHP变量</h2><ul><li>PHP 语句和 PHP 变量都是区分大小写的。</li><li>PHP 没有声明变量的命令。</li></ul><h3 id="PHP-是一门弱类型语言"><a href="#PHP-是一门弱类型语言" class="headerlink" title="PHP 是一门弱类型语言"></a>PHP 是一门弱类型语言</h3><ul><li>不必向 PHP 声明该变量的数据类型。</li><li>PHP会根据变量的值，自动把变量转换为正确的数据类型。</li><li>在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称。</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h4><ul><li><code>global</code>可以将局部变量提升为全局变量。</li><li>PHP将所有全局变量存储在一个名为<code>$GLOBALS[index]</code>的数组中。index保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。</li><li><code>Static</code>作用域<ul><li>当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除。要做到这一点，请在您第一次声明变量时使用 static 关键字。</li></ul></li><li>参数作用域：属于函数的局部变量。</li></ul><h2 id="php中常见的输出语句"><a href="#php中常见的输出语句" class="headerlink" title="php中常见的输出语句"></a>php中常见的输出语句</h2><ul><li><code>echo()</code>: 可以一次输出多个值，多个值之间用逗号分隔。<code>echo</code>是语言结构(language construct)，而并不是真正的函数，因此不能作为表达式的一部分使用。</li><li><code>print()</code>: 函数<code>print()</code>打印一个值（它的参数），如果字符串成功显示则返回<code>true</code>，否则返回<code>false</code>。</li><li><code>print_r()</code>: 可以把字符串和数字简单地打印出来，而数组则以括起来的键和值得列表形式显示，并以<code>Array</code>开头。但<code>print_r()</code>输出布尔值和NULL的结果没有意义，因为都是打印”\n”。因此用<code>var_dump()</code>函数更适合调试。</li><li><code>var_dump()</code>: 判断一个变量的类型与长度,并输出变量的数值,如果变量有值输的是变量的值并回返数据类型。此函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h3><ul><li>双引号串中的内容可以被解释而且替换，而单引号串中的内容总被认为是普通字符。 在单引号串中甚至反斜杠也失去了他的扩展含义（除了插入反斜杠\和插入单引号\’）。 所以，当你想在字串中进行变量代换和包含\n（换行符）等转义序列时，你应该使用双引号。单引号串可以用在其他任何地方，脚本中使用单引号串处理速度会更快些。</li></ul><h3 id="整型（Integer）"><a href="#整型（Integer）" class="headerlink" title="整型（Integer）"></a>整型（Integer）</h3><ul><li>整数是一个没有小数的数字。</li></ul><h3 id="浮点型（Float）"><a href="#浮点型（Float）" class="headerlink" title="浮点型（Float）"></a>浮点型（Float）</h3><p>-浮点数是带小数部分的数字，或是指数形式。</p><h3 id="布尔型（Boolean）"><a href="#布尔型（Boolean）" class="headerlink" title="布尔型（Boolean）"></a>布尔型（Boolean）</h3><h3 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h3><h3 id="对象（Object）"><a href="#对象（Object）" class="headerlink" title="对象（Object）"></a>对象（Object）</h3><ul><li>类似于java的类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    class Car</div><div class="line">    &#123;</div><div class="line">        var $color;</div><div class="line">        function Car($color=&quot;green&quot;) &#123;</div><div class="line">            $this-&gt;color = $color;</div><div class="line">        &#125;</div><div class="line">        function what_color() &#123;</div><div class="line">            return $this-&gt;color;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure><h3 id="NULL值"><a href="#NULL值" class="headerlink" title="NULL值"></a>NULL值</h3><ul><li>NULL值表示变量没有值。NULL是数据类型为NULL的值。</li><li>NULL值指明一个变量是否为空值。同样可用于数据空值和NULL值的区别。</li><li><p>可以通过设置变量值为 NULL 来清空变量数据</p><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><ul><li><code>strlen(string)</code>函数：返回字符串长度</li><li><code>strpos(seacher,char)</code>函数：查找一个字符串在另一个字符串中第一次出现的位置</li></ul></li></ul><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><ul><li><code>sort()</code> - 对数组进行升序排列</li><li><code>rsort()</code> - 对数组进行降序排列</li><li><code>asort()</code> - 根据关联数组的值，对数组进行升序排列</li><li><code>ksort()</code> - 根据关联数组的键，对数组进行升序排列</li><li><code>arsort()</code> - 根据关联数组的值，对数组进行降序排列</li><li><code>krsort()</code> - 根据关联数组的键，对数组进行降序排列</li></ul><h2 id="PHP-超级全局变量"><a href="#PHP-超级全局变量" class="headerlink" title="PHP 超级全局变量"></a>PHP 超级全局变量</h2><ul><li><code>$GLOBALS</code>：是一个包含了全部变量的全局组合数组。变量的名字就是数组的键。</li><li><code>$_SERVER</code>：是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。</li><li><code>$_REQUEST</code>：用于收集HTML表单提交的数据。</li><li><code>$_POST</code>：被广泛应用于收集表单数据，在HTMLform标签的指定该属性：<code>&quot;method=&quot;post&quot;</code>。<ul><li>从带有 POST 方法的表单发送的信息，对任何人都是不可见的（不会显示在浏览器的地址栏）</li><li>并且对发送信息的量也没有限制。</li></ul></li><li><code>$_GET</code>：同样被广泛应用于收集表单数据，在HTMLform标签的指定该属性：<code>&quot;method=&quot;get&quot;</code>。<code>$_GET</code>也可以收集URL中发送的数据。<ul><li>从带有 GET 方法的表单发送的信息，对任何人都是可见的（会显示在浏览器的地址栏）</li><li>并且对发送信息的量也有限制。</li></ul></li><li><code>$_FILES</code></li><li><code>$_ENV</code></li><li><code>$_COOKIE</code></li><li><code>$_SESSION</code></li></ul><h2 id="PHP魔术变量"><a href="#PHP魔术变量" class="headerlink" title="PHP魔术变量"></a>PHP魔术变量</h2><ul><li><code>__LINE__</code>：文件中的当前行号。</li><li><code>__FILE__</code>：文件的完整路径和文件名。</li><li><code>__DIR__</code>：文件所在的目录。</li><li><code>__FUNCTION__</code>：函数名称。</li><li><code>__CLASS__</code>：类的名称。</li><li><code>__TRAIT__</code>：trait的名称。</li><li><code>__METHOD__</code>：类方法的名称。</li><li><code>__NAMESPACE__</code>：命名空间的名称。</li></ul><h2 id="XSS又叫-CSS-Cross-Site-Script"><a href="#XSS又叫-CSS-Cross-Site-Script" class="headerlink" title="XSS又叫 CSS (Cross-Site Script)"></a>XSS又叫 CSS (Cross-Site Script)</h2><blockquote><p>跨站脚本攻击。恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。</p></blockquote><h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><ul><li>邮箱：<code>/([\w\-]+\@[\w\-]+\.[\w\-]+)/</code></li><li>URL：<code>/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&amp;@#\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\/%=~_|]/i</code></li><li>只有字母和空格：<code>/^[a-zA-Z ]*$/</code></li></ul><h2 id="Get-与-Post"><a href="#Get-与-Post" class="headerlink" title="Get 与 Post"></a>Get 与 Post</h2><h3 id="何时用method-”get”？"><a href="#何时用method-”get”？" class="headerlink" title="何时用method=”get”？"></a>何时用method=”get”？</h3><ul><li>在 HTML 表单中使用 method=”get” 时，所有的变量名和值都会显示在 URL 中。<ul><li>注释：所以在发送密码或其他敏感信息时，不应该使用这个方法！</li></ul></li><li>然而，正因为变量显示在URL中，因此可以在收藏夹中收藏该页面。在某些情况下，这是很有用的。<ul><li>注释：HTTP GET 方法不适合大型的变量值。它的值是不能超过 2000 个字符的。</li></ul></li></ul><h3 id="何时用method-”post”？"><a href="#何时用method-”post”？" class="headerlink" title="何时用method=”post”？"></a>何时用method=”post”？</h3><ul><li>从带有 POST 方法的表单发送的信息，对任何人都是不可见的，并且对发送信息的量也没有限制。</li><li>然而，由于变量不显示在 URL 中，所以无法把页面加入书签。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是一些PHP的基础知识，自己看书的时候做的一些笔记。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yangkunyi.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="PHP" scheme="http://yangkunyi.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript调试</title>
    <link href="http://yangkunyi.com/2017/11/16/JavaScript%E8%B0%83%E8%AF%95/"/>
    <id>http://yangkunyi.com/2017/11/16/JavaScript调试/</id>
    <published>2017-11-16T10:38:42.000Z</published>
    <updated>2017-12-02T06:42:03.794Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文就想总结一些调试的方法，其实调试是提高效率的重要方法之一，会用正确高效的调试方法，可以事半功倍。</p></blockquote><a id="more"></a><h3 id="1、最常用console-log（简单数据输出）"><a href="#1、最常用console-log（简单数据输出）" class="headerlink" title="1、最常用console.log（简单数据输出）"></a>1、最常用<code>console.log</code>（简单数据输出）</h3><ul><li>这就没有什么好解释的，不过输出也是有技巧的，那就是要格式化，简单说就是要有标志性，只有数据或许会让人不理解，最好是加上前缀</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// example</div><div class="line">console.log(&quot;fun&apos;s result---&quot; + fun(2));</div><div class="line">console.log(&quot;value of a---&quot; + a);</div></pre></td></tr></table></figure><ul><li>当然可以改变颜色和字体等</li></ul><h3 id="2、debugger：断点"><a href="#2、debugger：断点" class="headerlink" title="2、debugger：断点"></a>2、debugger：断点</h3><ul><li>与<code>console.log</code>相比，debugger会在执行的过程中停在你想的地方，能够更加直接的看到执行过程。</li></ul><h3 id="3、将对象以表格的形式展示console-table"><a href="#3、将对象以表格的形式展示console-table" class="headerlink" title="3、将对象以表格的形式展示console.table()"></a>3、将对象以表格的形式展示<code>console.table()</code></h3><ul><li>将对象强制用表格打出来，这样展开的对象键值对应更加清晰</li><li>注意firefox有限制，最多显示1000行</li></ul><h3 id="4、尝试适配各种机型屏幕大小"><a href="#4、尝试适配各种机型屏幕大小" class="headerlink" title="4、尝试适配各种机型屏幕大小"></a>4、尝试适配各种机型屏幕大小</h3><ul><li>这个对开发手机页面很有帮助</li><li>其次是可以检查布局问题</li></ul><h3 id="5、如何快速找到对应的DOM元素"><a href="#5、如何快速找到对应的DOM元素" class="headerlink" title="5、如何快速找到对应的DOM元素"></a>5、如何快速找到对应的DOM元素</h3><ul><li>方法1浏览器的快速选择工具</li><li>方法2是通过参数访问，浏览器有将DOM元素进行编号，可以通过$x的方式去访问。（具体后续补充）</li></ul><h3 id="6、使用console-time-和console-timeEnd-来记录时间"><a href="#6、使用console-time-和console-timeEnd-来记录时间" class="headerlink" title="6、使用console.time()和console.timeEnd()来记录时间"></a>6、使用<code>console.time()</code>和<code>console.timeEnd()</code>来记录时间</h3><ul><li>关注函数运行的时间是提高效率的方法之一</li></ul><h3 id="获取某个函数的Stacktrace"><a href="#获取某个函数的Stacktrace" class="headerlink" title="获取某个函数的Stacktrace"></a>获取某个函数的Stacktrace</h3><ul><li>console.trace()</li><li>向Web控制台输出一个堆栈跟踪</li></ul><h3 id="将minify的代码还原"><a href="#将minify的代码还原" class="headerlink" title="将minify的代码还原"></a>将minify的代码还原</h3><ul><li>{}</li></ul><h3 id="快速定位需要debug的函数"><a href="#快速定位需要debug的函数" class="headerlink" title="快速定位需要debug的函数"></a>快速定位需要debug的函数</h3><ul><li>debug(funName)</li><li>会在执行函数的地方停下来</li></ul><h3 id="屏蔽不相关的脚本"><a href="#屏蔽不相关的脚本" class="headerlink" title="屏蔽不相关的脚本"></a>屏蔽不相关的脚本</h3><ul><li>注释掉</li></ul><h3 id="查看某个函数调用和其参数"><a href="#查看某个函数调用和其参数" class="headerlink" title="查看某个函数调用和其参数"></a>查看某个函数调用和其参数</h3><ul><li>monitor(funName)</li></ul><h3 id="Postman很好用，不过传说Firefox更快"><a href="#Postman很好用，不过传说Firefox更快" class="headerlink" title="Postman很好用，不过传说Firefox更快"></a>Postman很好用，不过传说Firefox更快</h3><ul><li>但由于本人喜欢用chrome，所以没有用尝试firefox</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文就想总结一些调试的方法，其实调试是提高效率的重要方法之一，会用正确高效的调试方法，可以事半功倍。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yangkunyi.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>域名的购买和绑定</title>
    <link href="http://yangkunyi.com/2017/11/15/%E5%9F%9F%E5%90%8D%E7%9A%84%E8%B4%AD%E4%B9%B0%E5%92%8C%E7%BB%91%E5%AE%9A/"/>
    <id>http://yangkunyi.com/2017/11/15/域名的购买和绑定/</id>
    <published>2017-11-15T09:42:30.000Z</published>
    <updated>2017-12-02T06:46:26.217Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>终于下定决心，自己在阿里云上购买了域名，开始将自己的博客放到一个更大的“池塘”里面了，之后的学习，希望自己能继续坚持。</p></blockquote><a id="more"></a><h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><ul><li><p>前期翻看了很多关于在哪里购买域名的博文，最后还是决定就在阿里云买了，原因如下：（其实很早就想买了，但是之前还是觉得自己技术不成熟吧，买了也是浪费，不过现在觉得，买了就有更大的动力学习了）</p><ul><li><strong>为了让自己的博客更有识别度</strong></li><li>作为一个新手，阿里云的性能已经很够用了</li><li>价格一般，作为大学生，还是能负担</li><li>阿里云在国内也算有名了吧</li></ul></li><li><p>购买方法很简单啊，只要去官网就好了<strong><a href="https://cn.aliyun.com/" target="_blank" rel="external">阿里云</a></strong></p></li></ul><h3 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h3><blockquote><p>之前自己的博客是挂在github上面直接用的免费的github pages，为了更有识别度，便买了域名，因为还没有购买服务器，（准备在接下来一年内完成这任务）所以之后项目还是会放在github上。</p></blockquote><p>因此这样的话，绑定域名就很简单了。</p><ul><li>域名的解析，在阿里云的后台管理进行如下设置</li></ul><p><img src="http://otn4ut2th.bkt.clouddn.com/blogdns.PNG" alt="dnsSetting"></p><ul><li>然后是github项目的重定向<ul><li>用过github pages的都知道，github赠送的域名是<code>yourgithubname.github.io</code>，而我们现在要做的就是将这个页面重定向到我们申请的域名上去</li></ul></li></ul><h4 id="方法如下："><a href="#方法如下：" class="headerlink" title="方法如下："></a>方法如下：</h4><ul><li>方法1. 直接更改项目设置中的pages设置，如图：</li></ul><p><img src="http://otn4ut2th.bkt.clouddn.com/bloggithubpage.PNG" alt="githubpages"></p><ul><li>方法2.在项目的根目录中新建一个<code>CNAME</code>文件，文件的内容就是我们申请的域名：</li></ul><p><img src="http://otn4ut2th.bkt.clouddn.com/blogcname.PNG" alt="cname"></p><p>最后就是等待了（时间长短不定，本人感觉并没有等很久），就可以通过我们自己申请的域名访问项目页面了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;终于下定决心，自己在阿里云上购买了域名，开始将自己的博客放到一个更大的“池塘”里面了，之后的学习，希望自己能继续坚持。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="域名" scheme="http://yangkunyi.com/tags/%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>学习PHP之环境搭建</title>
    <link href="http://yangkunyi.com/2017/09/30/%E5%AD%A6%E4%B9%A0PHP%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yangkunyi.com/2017/09/30/学习PHP之环境搭建/</id>
    <published>2017-09-30T04:02:08.000Z</published>
    <updated>2017-12-02T06:46:21.999Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：因为搭建的是本地的服务器，所以只有自己的电脑开着的时候，才能访问到。</p></blockquote><a id="more"></a><h3 id="一、注册域名"><a href="#一、注册域名" class="headerlink" title="一、注册域名"></a>一、注册域名</h3><ol><li>这是一个免费域名的注册地址<a href="https://www.noip.com/" target="_blank" rel="external">www.noip.com</a>，这种网站有很多，只是本人用的这一个，可自由选择。<br><img src="http://otn4ut2th.bkt.clouddn.com/blogwebsite.PNG" alt="此处输入图片的描述"></li><li>注册登录即可。（一个简单的域名注册申请，就不再赘述了）</li><li>根据自己的ip注册后的结果是这样（要特别注意的是ip地址的填写，不知道自己此刻的ip地址可以用命令行查询；<strong><em>此处的ip地址会根据你使用的网络而改变</em></strong>）：<br><img src="http://otn4ut2th.bkt.clouddn.com/blogresult.PNG" alt="此处输入图片的描述"></li></ol><h3 id="二、架构包的安装"><a href="#二、架构包的安装" class="headerlink" title="二、架构包的安装"></a>二、架构包的安装</h3><ol><li>下载架构包（架构包当然也有很多种，本人使用的是链接中的这个）<a href="https://www.appservnetwork.com/en/" target="_blank" rel="external">AppSever8.6.0</a></li><li>安装架构包（跟着流程走就好了，规则就是两个键按左边，三个键按中间，一个键就只能按它咯~）<strong><em>注意安装目录的选择！</em></strong>安装完之后，会有一个这样的目录：<br><img src="http://otn4ut2th.bkt.clouddn.com/blogfile.PNG" alt="此处输入图片的描述"></li><li>测试：在浏览器地址栏中输入你之前申请的并且与ip地址对应的域名，当看到以下结果，说明你ok了，否则请从头开始=_=（嘿嘿，有问题肯定是某个步骤出了问题，仔细检查）：<br><img src="http://otn4ut2th.bkt.clouddn.com/blogifo.png" alt="此处输入图片的描述"></li><li>此处显示的是，文件夹<code>www</code>中的index.php文件<blockquote><p>当然我们希望这些关于服务器的各种信息只有我们自己能看到，而别人看不到，很简单，将文档的名字改成只有你自己知道就好了:<br><img src="http://otn4ut2th.bkt.clouddn.com/blogfilename.png" alt="此处输入图片的描述"></p></blockquote></li><li>既然index文件已经被我们改掉了，因此可以开始写第一个index文件了，此刻网页会自动显示该文件（之后就可以开始写自己的网页了）：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// index.html</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">&lt;title&gt;index&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;p style=&quot;font-size: 50px;color: #66ccff;&quot;&gt;啦啦啦&lt;/p&gt;</div><div class="line">&lt;p style=&quot;font-size: 40px;color: red&quot;&gt;完了&lt;/p&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p><img src="http://otn4ut2th.bkt.clouddn.com/blogover.png" alt="此处输入图片的描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：因为搭建的是本地的服务器，所以只有自己的电脑开着的时候，才能访问到。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://yangkunyi.com/tags/PHP/"/>
    
      <category term="学习" scheme="http://yangkunyi.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>画地为牢</title>
    <link href="http://yangkunyi.com/2017/08/04/%E7%94%BB%E5%9C%B0%E4%B8%BA%E7%89%A2/"/>
    <id>http://yangkunyi.com/2017/08/04/画地为牢/</id>
    <published>2017-08-04T01:16:39.000Z</published>
    <updated>2017-12-02T06:45:38.969Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>它是一套规则，这套规则用来管理引擎如何在当前作用域及嵌套的子作用域中根据标识符名称进行变量的查找。</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if(true) &#123;</div><div class="line">    var num = 10;</div><div class="line">&#125;</div><div class="line">console.log(num);</div></pre></td></tr></table></figure><blockquote><p>思考：JavaScirpt怎样才会形成作用域？</p></blockquote><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><blockquote><p>就是说，在JavaScript中，在函数里面定义的变量，可以在函数里面被访问，但是在函数外无法访问。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var func = function() &#123;</div><div class="line">    var num = 10;</div><div class="line">&#125;;</div><div class="line">console.log(num);</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var func = function() &#123;</div><div class="line">    var num = 10;</div><div class="line">    console.log(num);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><blockquote><p>前面说了，函数可以限定变量的作用域，那么在函数中的函数就成为该作用域的子域。在子域中的代码可以访问到父域中的变量。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var func = function() &#123;</div><div class="line">    var num = 10;</div><div class="line">    var sub_func = function() &#123;</div><div class="line">        console.log(num);</div><div class="line">    &#125;;</div><div class="line">    sub_func();</div><div class="line">&#125;;</div><div class="line">func();</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var func = function() &#123;</div><div class="line">    var num = 10;</div><div class="line">    var sub_func = function() &#123;</div><div class="line">        var num = 20;</div><div class="line">        console.log(num);</div><div class="line">    &#125;;</div><div class="line">    sub_func();</div><div class="line">&#125;;</div><div class="line">func();</div></pre></td></tr></table></figure><blockquote><p>由此可见访问有一定规则可言。在JavaScript中使用变量，JavaScript解释器首先在当前作用域中搜索是否有该变量的定义，如果有，就是用这个变量；如果没有就到父域中寻找该变量。以此类推，直到最顶级作用域，仍然没有找到就抛出异常”变量未定义”。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">    var num = 10;</div><div class="line">    (function() &#123;</div><div class="line">        var num = 20;</div><div class="line">        (function()&#123;</div><div class="line">            console.log(num);</div><div class="line">        &#125;)()</div><div class="line">    &#125;)();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><blockquote><p>思考：什么叫块级作用域？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function outputNumbers(count)&#123;</div><div class="line">    for (var i=0;i&lt;count;i++)&#123;</div><div class="line">        console.log(i);</div><div class="line">    &#125;</div><div class="line">    console.log(i)</div><div class="line">    var i;</div><div class="line">    console.log(i);</div><div class="line">&#125;</div><div class="line">outputNumbers(3);</div></pre></td></tr></table></figure><blockquote><p>很遗憾，在es6之前，javascript是没有块级作用域的。所以也会因此造成对一些变量值的忽视，从而引起程序运行结果不对。那前辈们遇到这个问题是怎么做的呢？让我们来考考古。</p></blockquote><h4 id="利用函数来实现块级作用域"><a href="#利用函数来实现块级作用域" class="headerlink" title="利用函数来实现块级作用域"></a>利用函数来实现块级作用域</h4><ul><li>因为函数是js里唯一具有块级作用域特点的。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function outputNumbers(count)&#123;</div><div class="line">    (function()&#123;</div><div class="line">        for (var i=0;i&lt;count;i++)&#123;</div><div class="line">            console.log(i);</div><div class="line">        &#125;</div><div class="line">    &#125;)();</div><div class="line">    console.log(i);</div><div class="line">&#125;</div><div class="line">outputNumbers(3);</div></pre></td></tr></table></figure><blockquote><p>思考：这是不是一个闭包？</p></blockquote><h4 id="方法类（不建议使用）"><a href="#方法类（不建议使用）" class="headerlink" title="方法类（不建议使用）"></a>方法类（不建议使用）</h4><h5 id="with"><a href="#with" class="headerlink" title="with"></a>with</h5><ul><li>用with从对象创建出的作用域仅在with声明中而非外部作用域中有效。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function foo(obj) &#123;</div><div class="line">    with (obj) &#123;</div><div class="line">        var a = 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var o1 = &#123;</div><div class="line">    a: 3</div><div class="line">&#125;;</div><div class="line">var o2 = &#123;</div><div class="line">    b: 3</div><div class="line">&#125;;</div><div class="line">foo( o1 );</div><div class="line">console.log( o1.a );</div><div class="line"></div><div class="line">foo( o2 );</div><div class="line">console.log( o2.a );</div><div class="line">console.log( a );</div></pre></td></tr></table></figure></li></ul><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a>try/catch</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line">undefined();//执行一个非法操作来强制制造一个异常</div><div class="line">&#125;</div><div class="line">catch(err)&#123;</div><div class="line">console.log(err)//能够正常执行</div><div class="line">&#125;</div><div class="line">console.log(err);</div></pre></td></tr></table></figure><h4 id="ES6中的块级作用域"><a href="#ES6中的块级作用域" class="headerlink" title="ES6中的块级作用域"></a>ES6中的块级作用域</h4><blockquote><p>将代码在函数中隐藏的信息扩展为在块中隐藏起来。</p></blockquote><h5 id="let-不能重复声明"><a href="#let-不能重复声明" class="headerlink" title="let(不能重复声明)"></a>let(不能重复声明)</h5><blockquote><p>let关键字可以将变量绑定到所在的任意作用域中。</p></blockquote><ul><li><p>垃圾回收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function process(data)&#123;</div><div class="line">  //在这里做点有趣的事情</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;//在这个块中定义的内容完事可以销毁</div><div class="line">  let someReallyBigData=&#123;...&#125;;</div><div class="line">  process(someReallyBigData);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>let循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(let i=0;i&lt;10;i++)&#123;</div><div class="line">   console.log(i);</div><div class="line">&#125;</div><div class="line">console.log(i);</div></pre></td></tr></table></figure></li></ul><h5 id="const（不能重复声明）"><a href="#const（不能重复声明）" class="headerlink" title="const（不能重复声明）"></a>const（不能重复声明）</h5><ul><li>定义一个该块的常量，不能修改值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var foo = true;</div><div class="line"></div><div class="line">if (foo) &#123;</div><div class="line">    var a = 2;</div><div class="line">    const b = 3;</div><div class="line">    a = 3;</div><div class="line">    b = 4;</div><div class="line">&#125;</div><div class="line">console.log(a);</div><div class="line">console.log(b);</div></pre></td></tr></table></figure><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><blockquote><p>因为作用域是一套用于确定在何处以及如何查找变量的规则，我对作用域链的理解就是查找变量所走的路。</p></blockquote><h3 id="建筑"><a href="#建筑" class="headerlink" title="建筑"></a>建筑</h3><p><img src="http://i1.piimg.com/567571/5d27ab14bdca83a3.png" alt="作用域链建筑型"></p><blockquote><p>根据这个图来理解，就是查找变量所爬的楼。</p></blockquote><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><blockquote><p>爬楼太累了，我们再看看用画树的方法再来看看。</p></blockquote><ul><li>绘制规则<ul><li>作用域链就是对象的数组</li><li>全局作用域是0级链，每个对象占一个位置</li><li>凡是看到函数延伸一个链出来，一级级展开</li><li>访问首先看当前函数，如果没有定义往上一级链检查</li><li>如此往复，直到0级链</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">var func1 = function() &#123;</div><div class="line">    var num = 20;</div><div class="line">    var func2 = function() &#123;</div><div class="line">        var num = 30;</div><div class="line">        console.log(num);</div><div class="line">    &#125;;</div><div class="line">    func2();</div><div class="line">&#125;;</div><div class="line">var func2 = function() &#123;</div><div class="line">    var num = 20;</div><div class="line">    var func3 = function() &#123;</div><div class="line">        console.log(num);</div><div class="line">    &#125;;</div><div class="line">    func3();</div><div class="line">&#125;;</div><div class="line">func1();</div><div class="line">func2();</div></pre></td></tr></table></figure><blockquote><p>现场绘制一波</p></blockquote><h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><blockquote><p>形成变量提升现象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">var func = function() &#123;</div><div class="line">    console.log(num);</div><div class="line">    var num = 20;</div><div class="line">    console.log(num);</div><div class="line">&#125;;</div><div class="line">func();</div></pre></td></tr></table></figure></p><p>函数提升<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var func = function() &#123;</div><div class="line"> console.log(&quot;调用外面的函数&quot;);</div><div class="line">&#125;;</div><div class="line">var foo = function() &#123;</div><div class="line">    func();</div><div class="line">    var func = function() &#123;</div><div class="line">        console.log(&quot;调用内部的函数&quot;);</div><div class="line">    &#125;;</div><div class="line">    func();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>预解析：在当前作用域下,js运行之前，会把带有var和function关键字的事先声明，并在内存中安排好，然后再从上到下执行js语句。预解析只会发生在通过var定义的变量和function上。</p></blockquote><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><ul><li>只要是通过var定义的，不管是变量，还是函数，都是先赋值undefined，如果是变量，也不管变量有没有赋值，在预解析阶段，都是会被赋值为undefined。</li></ul><h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><ul><li>function进行预解析的时候，不仅是声明而且还定义了，但是它存储的数据的那个空间里面存储的是代码是字符串，没有任何意义。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function fun() &#123;</div><div class="line">    //代码区</div><div class="line">&#125;();</div></pre></td></tr></table></figure><ul><li><p>定义一个函数想要立即执行，写成上面的形式是不可行的，在预解释的时候，它把它分解成两部分来对待，第一部分是fun函数，而第二部分是(),一个匿名函数，执行时会报错。如果小括号带参数，如(2)，虽然不会报错，会打印出来2，但并不能把fn执行，也不能当成参数传递给fn函数。</p></li><li><p>如果你想实现立即执行的函数，可以把要执行的函数放到一对括号里面，对于JavaScript 来说，括弧()里面不能包含语句，所以在这一点上，解析器在解析function关键字的时候，会将相应的代码解析成function表达式，而不是function声明所以，只要将大括号将代码(包括函数部分和在后面加上一对大括号)全部括起来就可以了。 如下：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function fun() &#123;</div><div class="line">    //代码区</div><div class="line">&#125;());</div></pre></td></tr></table></figure><ul><li>预解析是发生在当前作用域下的，刚开始的时候，我们预解析的是全局作用域，在js中我们的global就是我们的window。</li><li>我们运行函数的时候会生成一个新的私有作用域（每次执行都是新的，执行完成就销毁）这个作用域下我们可以理解为开辟了一个新的内存空间。在这个内存中我们也要执行预解析。当我们的函数执行完成后，这个内存或者作用域就会销毁。</li><li>如果在当前作用域下的一个变量没有预解析，就会向它的上一级去找，直到找到window，如果window下也没有定义，就会报错。所以，在函数内通过var定义的变量是局部变量，没有通过var定义的变量是全局变量。</li><li>预解析不会在同一个变量上重复的发生，也就是一个变量如果已经在当前作用域下预解析了，不会再重复解析。</li><li>等号右边的function不会进行预解析。</li><li>预解释是不受其它if或者其它判断条件影响的，也就是说，即使条件不成立，我们里面只要有var或者function也会被预解释。</li><li>后面定义的会覆盖前面定义的。</li></ul><h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">// 例子一</div><div class="line">if(!(&quot;a&quot; in window))&#123;</div><div class="line">    var a = &quot;李玉华&quot;；</div><div class="line">&#125;</div><div class="line">console.log(a);</div><div class="line"></div><div class="line">// 例子二</div><div class="line">function fn()&#123;</div><div class="line">    console.log(&quot;我们是全局的fn&quot;);</div><div class="line">&#125;</div><div class="line">function fn2()&#123;</div><div class="line">    console.log(fn);</div><div class="line">    fn = 3;</div><div class="line">    return ;</div><div class="line">    function fn()&#123;</div><div class="line">    console.log(&quot;我是fn2里面的&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">fn2();</div><div class="line"></div><div class="line">// 例子三</div><div class="line">var n = 0;</div><div class="line">function a()&#123;</div><div class="line">    var n = 10;</div><div class="line">    function b()&#123;</div><div class="line">        n++;</div><div class="line">        console.log(n);</div><div class="line">    &#125;</div><div class="line">    b();</div><div class="line">    return b;</div><div class="line">&#125;</div><div class="line">var c = a(); </div><div class="line">c(); </div><div class="line">console.log(n); </div><div class="line"></div><div class="line">// 例子四</div><div class="line">var n = 99;</div><div class="line">function outer()&#123;</div><div class="line">    var n = 0;</div><div class="line">    return function inner()&#123;</div><div class="line">    return n++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var c = outer(); </div><div class="line">var num1 = c();</div><div class="line">var num2 = c();</div><div class="line">var d = outer();</div><div class="line">var num3 = d();</div><div class="line">console.log(c);</div><div class="line">console.log(num1);</div><div class="line">console.log(num2);</div><div class="line">console.log(d);</div><div class="line">console.log(num3);</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>作用域就是根据标识符查找变量的一套规则。（路标）</strong></li><li><strong>作用域链就是找变量所走的路径。</strong></li><li><strong>预解析就是万恶的“VIP”。</strong></li></ul><h2 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h2><ul><li>ReferenceError作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。</li><li>参考链接<ul><li><a href="http://www.jb51.net/article/55435.htm" target="_blank" rel="external">作用域和作用域链</a></li><li><a href="http://www.jianshu.com/p/2d548a45685c" target="_blank" rel="external">块级作用域</a></li><li><a href="https://frannieyi.github.io/2017/08/02/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8E%9F%E5%9E%8B/" target="_blank" rel="external">作用域和原型</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;它是一套规则，这套规则用来管理引擎如何在当前作用域及嵌套的子作用域中根据标识符名称进行变量的查找。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="分享" scheme="http://yangkunyi.com/tags/%E5%88%86%E4%BA%AB/"/>
    
      <category term="作用域" scheme="http://yangkunyi.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="作用域链" scheme="http://yangkunyi.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    
      <category term="预解析" scheme="http://yangkunyi.com/tags/%E9%A2%84%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>作用域和原型</title>
    <link href="http://yangkunyi.com/2017/08/02/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8E%9F%E5%9E%8B/"/>
    <id>http://yangkunyi.com/2017/08/02/作用域和原型/</id>
    <published>2017-08-02T11:29:16.000Z</published>
    <updated>2017-12-02T06:47:04.776Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是作用域？"><a href="#什么是作用域？" class="headerlink" title="什么是作用域？"></a>什么是作用域？</h3><a id="more"></a><blockquote><p>它是一套规则，这套规则用来管理引擎如何在当前作用域及嵌套的子作用域中根据标识符名称进行变量的查找。</p></blockquote><h4 id="先介绍一下RHS和LHS"><a href="#先介绍一下RHS和LHS" class="headerlink" title="先介绍一下RHS和LHS"></a>先介绍一下RHS和LHS</h4><ul><li>这是引擎的两种查找类型</li><li>“R”和“L”分别代表赋值操作的右侧和左侧</li><li><strong>案例</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo(a)&#123;//对a进行LHS引用2</div><div class="line">    console.log(a);</div><div class="line">    //对console进行RHS引用3</div><div class="line">    //对a进行RHS引用4</div><div class="line">&#125;</div><div class="line">foo(2);//对foo进行RHS引用1</div></pre></td></tr></table></figure><ul><li>当变量还没有声明的时候（在任何作用域都找不到该变量），这两种查询的行为是不一样的：LHS查询会在全局作用域中自己创建一个变量。RHS查询会抛出一个ReferenceError错误。</li></ul><h4 id="作用域的嵌套"><a href="#作用域的嵌套" class="headerlink" title="作用域的嵌套"></a>作用域的嵌套</h4><blockquote><p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。这一就形成了一条作用域链。</p></blockquote><ul><li><p><strong>案例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo(a)&#123;</div><div class="line">    console.log(a+b);</div><div class="line">&#125;</div><div class="line">var b=2;</div><div class="line">foo(2);//4</div></pre></td></tr></table></figure></li><li><p><strong>将作用域链比喻成一个建筑</strong></p></li></ul><p><img src="http://i1.piimg.com/567571/5d27ab14bdca83a3.png" alt="作用域链"></p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><ul><li>词法作用域是由你写代码时将变量和块作用域写在哪里来决定的。</li><li><strong>案例</strong><br><img src="http://i1.piimg.com/567571/abb987dd184464f7.jpg" alt="三级逐步嵌套的作用域"></li></ul><h4 id="JavaScript中有两个机制可以“欺骗”词法作用域"><a href="#JavaScript中有两个机制可以“欺骗”词法作用域" class="headerlink" title="JavaScript中有两个机制可以“欺骗”词法作用域"></a>JavaScript中有两个机制可以“欺骗”词法作用域</h4><ul><li><p>eval() 例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function foo(str, a) &#123;</div><div class="line">    eval( str ); // 欺骗！</div><div class="line">    console.log( a, b );</div><div class="line">&#125;</div><div class="line">var b = 2;</div><div class="line">foo( &quot;var b = 3;&quot;, 1 );</div><div class="line"></div><div class="line">//严格模式</div><div class="line">// function foo(str) &#123;</div><div class="line">//    &quot;use strict&quot;;</div><div class="line">//    eval( str );</div><div class="line">//    console.log( a ); // ReferenceError: a is not defined</div><div class="line">// &#125;</div><div class="line"></div><div class="line">foo( &quot;var a = 2&quot;);</div></pre></td></tr></table></figure></li><li><p>with() 例子：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function foo(obj) &#123;</div><div class="line">    with (obj) &#123;</div><div class="line">        var a = 2;</div><div class="line">    &#125;</div><div class="line">    // a = 2;</div><div class="line">&#125;</div><div class="line">var o1 = &#123;</div><div class="line">    a: 3</div><div class="line">&#125;;</div><div class="line">var o2 = &#123;</div><div class="line">    b: 3</div><div class="line">&#125;;</div><div class="line">foo( o1 );</div><div class="line">console.log( o1.a );</div><div class="line"></div><div class="line">foo( o2 );</div><div class="line">console.log( o2.a );</div><div class="line">console.log( a );</div></pre></td></tr></table></figure><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><ul><li>在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。</li><li><strong>案例</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a=2;</div><div class="line">function foo()&#123;</div><div class="line">    var a=3;</div><div class="line">    console.log(a);//3</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line">console.log(a);//2</div></pre></td></tr></table></figure><ul><li>不足之处：<ul><li>必须声明一个foo函数，这个foo“污染”了所在作用域。</li><li>必须显示调用才能运行其中的代码</li></ul></li><li><strong>改进</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a=2;</div><div class="line">(function foo()&#123;</div><div class="line">    var a=3;</div><div class="line">    console.log(a);//3</div><div class="line">&#125;)();</div><div class="line">console.log(a);//2</div><div class="line">//函数会被当作函数表达式而不是一个标准的函数声明来处理。</div></pre></td></tr></table></figure><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><ul><li>优点：<ul><li>书写起来简单快捷</li></ul></li><li>缺点：<ul><li>匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。</li><li>如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用。（callee是arguments对象的一个属性。它可以用于引用该函数的函数体内当前正在执行的函数。）</li><li>匿名函数省略了对于代码可读性/可理解性很重要的函数名。</li></ul></li></ul><h4 id="立即执行函数表达式"><a href="#立即执行函数表达式" class="headerlink" title="立即执行函数表达式"></a>立即执行函数表达式</h4><ul><li>IIFE(Immediately Invoked Function Expression)：<code>(function foo(){...})()</code></li><li>函数名对IIFE来说不是必须的：<code>(function(){...}())</code></li><li>进阶用法：当作函数调用并传参数进去。</li><li>例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></li></ul><h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><blockquote><p>块作用域将代码在函数中隐藏的信息扩展为在块中隐藏起来。</p></blockquote><ul><li><strong>思考</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for(var i=0;i&lt;10;i++)&#123;</div><div class="line">    console.log(i);</div><div class="line">&#125;</div><div class="line">console.log(i);</div><div class="line">//为什么要把一个只在for循环内部使用（至少是应该只在内部使用）的变量i“污染”到整个作用域（不管是函数还是全局）中？</div></pre></td></tr></table></figure><ul><li>with：用with从对象创建出的作用域仅在with声明中而非外部作用域中有效。</li><li>try/catch：例子：try.html</li><li>let：let关键字可以将变量绑定到所在的任意作用域中。<ul><li>垃圾回收</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function process(data)&#123;</div><div class="line">  //在这里做点有趣的事情</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;//在这个块中定义的内容完事可以销毁</div><div class="line">  let someReallyBigData=&#123;...&#125;;</div><div class="line">  process(someReallyBigData);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>let循环</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(let i=0;i&lt;10;i++)&#123;</div><div class="line">   console.log(i);</div><div class="line">&#125;</div><div class="line">console.log(i);ReferenceError</div></pre></td></tr></table></figure><ul><li>const：定义一个该块的常量，不能修改值。例子：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var person = function(name)&#123;</div><div class="line">    this.name = name</div><div class="line">&#125;;</div><div class="line">person.prototype.getName = function()&#123;</div><div class="line">    console.log(this.name);</div><div class="line">&#125;</div><div class="line">var zjh = new person(&apos;zhangjiahao&apos;);</div><div class="line">zjh.getName(); //zhangjiahao</div></pre></td></tr></table></figure><h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型[prototype]"></a>原型[prototype]</h2><h3 id="普通对象和函数对象"><a href="#普通对象和函数对象" class="headerlink" title="普通对象和函数对象"></a>普通对象和函数对象</h3><ul><li>JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var o1 = &#123;&#125;; </div><div class="line">var o2 =new Object();</div><div class="line">var o3 = new f1();</div><div class="line"></div><div class="line">function f1()&#123;&#125;; </div><div class="line">var f2 = function()&#123;&#125;;</div><div class="line">var f3 = new Function(&apos;str&apos;,&apos;console.log(str)&apos;);</div><div class="line"></div><div class="line">console.log(typeof Object); //function </div><div class="line">console.log(typeof Function); //function  </div><div class="line"></div><div class="line">console.log(typeof f1); //function </div><div class="line">console.log(typeof f2); //function </div><div class="line">console.log(typeof f3); //function   </div><div class="line"></div><div class="line">console.log(typeof o1); //object </div><div class="line">console.log(typeof o2); //object </div><div class="line">console.log(typeof o3); //object</div></pre></td></tr></table></figure><ul><li>怎么区分，其实很简单，<strong>凡是通过new&nbsp;Function()创建的对象都是函数对象，其他的都是普通对象。f1,f2,归根结底都是通过new&nbsp;Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的。</strong></li></ul><h3 id="什么是prototype？"><a href="#什么是prototype？" class="headerlink" title="什么是prototype？"></a>什么是<code>prototype</code>？</h3><blockquote><p>在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个<code>prototype</code>属性，这个属性指向函数的原型对象。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;</div><div class="line">    Person.prototype.name = &apos;Zaxlct&apos;;</div><div class="line">    Person.prototype.age  = 28;</div><div class="line">    Person.protetype.job  = &apos;Software Engineer&apos;;</div><div class="line">    Person.prototype.sayName = function() &#123;</div><div class="line">      alert(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">person1.sayName(); // &apos;Zaxlct&apos;</div><div class="line"></div><div class="line">var person2 = new Person();</div><div class="line">person2.sayName(); // &apos;Zaxlct&apos;</div><div class="line"></div><div class="line">console.log(person1.sayname == person2.sayname); //true</div></pre></td></tr></table></figure><ul><li>只有函数对象才有 <code>prototype</code> 属性</li></ul><h3 id="什么是原型对象？"><a href="#什么是原型对象？" class="headerlink" title="什么是原型对象？"></a>什么是原型对象？</h3><blockquote><p>原型对象，顾名思义，它就是一个普通对象。从现在开始你要牢牢记住原型对象就是 <code>Person.prototype</code>，如果你还是记不住，那就把它想想成一个字母 A： <code>var A = Person.prototype;</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Person.prototype = &#123;</div><div class="line">   name:  &apos;Zaxlct&apos;,</div><div class="line">   age: 28,</div><div class="line">   job: &apos;Software Engineer&apos;,</div><div class="line">   sayName: function() &#123;</div><div class="line">     alert(this.name);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>在默认情况下，所有的原型对象都会自动获得一个<code>constructor</code>（构造函数）属性，这个属性（是一个指针）指向 <code>prototype</code> 属性所在的函数（Person）</p></blockquote><ul><li><p><strong>原型对象（Person.prototype）是 构造函数（Person）的一个实例。</strong></p></li><li><p>那原型对象是用来做什么的呢？举个例子：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var person = function(name)&#123;</div><div class="line">    this.name = name</div><div class="line">&#125;;</div><div class="line">person.prototype.getName = function()&#123;</div><div class="line">    return this.name;</div><div class="line">&#125;</div><div class="line">var zjh = new person(‘zhangjiahao’);</div><div class="line">zjh.getName(); //zhangjiahao</div></pre></td></tr></table></figure><ul><li>从这个例子可以看出，通过给<code>person.prototype</code>设置了一个函数对象的属性，那由<code>person</code>实例（例中：zjh）出来的普通对象就继承了这个属性。<strong>所以原型对象的主要作用就是用于继承。</strong></li><li>具体是怎么实现的继承，就要讲到下面的原型链了。</li></ul><h3 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h3><ul><li>JS在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做__proto__的内置属性，用于指向创建它的函数对象的原型对象prototype。例如：<ul><li><code>console.log(zjh.__proto__ === person.prototype) //true</code></li></ul></li><li>同样，person.prototype对象也有__proto__属性，它指向创建它的函数对象（Object）的prototype<ul><li><code>console.log(person.prototype.__proto__ === Object.prototype) //true</code></li></ul></li><li>继续，Object.prototype对象也有__proto__属性，但它比较特殊，为null<ul><li><code>console.log(Object.prototype.__proto__) //null</code> </li></ul></li><li><strong>我们把这个有<strong>proto</strong>串起来的直到Object.prototype.<strong>proto</strong>为null的链叫做原型链。</strong><br><img src="http://i2.muimg.com/567571/055ff751adbbf734.jpg" alt="原型链"></li></ul><h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><ul><li>ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。</li><li>区分函数声明和表达式最简单的方法是看function关键字出现在声明这哦那个的位置（不仅仅是一行代码，而是整个声明中的位置）。如果function是在声明的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</li><li>作用域理解基于《你不知道的Javascript 上卷》</li><li>原型理解基于文章<a href="http://www.jianshu.com/p/dee9f8b14771" target="_blank" rel="external">原型与原型链</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是作用域？&quot;&gt;&lt;a href=&quot;#什么是作用域？&quot; class=&quot;headerlink&quot; title=&quot;什么是作用域？&quot;&gt;&lt;/a&gt;什么是作用域？&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yangkunyi.com/tags/Javascript/"/>
    
      <category term="分享" scheme="http://yangkunyi.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>JavaSccript语言精粹</title>
    <link href="http://yangkunyi.com/2017/07/20/JavaSccript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9/"/>
    <id>http://yangkunyi.com/2017/07/20/JavaSccript语言精粹/</id>
    <published>2017-07-20T07:01:07.000Z</published>
    <updated>2017-12-02T06:41:53.610Z</updated>
    
    <content type="html"><![CDATA[<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><a id="more"></a><ul><li>字符串是不可变的。一旦被创建就永远无法改变。</li><li>typeof运算符产生的值有‘number’ ‘string’ ‘boolean’ ‘undefined’ ‘function’ ‘object’。</li><li>一个属性存取表达式用于指定一个对象或数值的属性或元素。</li><li>原型连接只有在检索值的时候才被用到。如果我们尝试弃获取对象的某个属性值，但该对象没有此属性名，那么JavaScript会试着从原型对象中获取属性值。如果那个原型对象也没有该属性，那么再从它的原型中寻找，依次类推，只到该过程最后到达终点Object.prototype。如果想要的属性完全不存在于原型练中，那么结果就是undefined值。这个过程为<strong>委托</strong>。</li><li>用for in的方法来遍历一个对象中的所有属性名，属性名出现的顺序是不确定的，因此要对任何可能出现的顺序有所准备。若想自定义顺序最好的方式是避免使用for in，而是通过建立数组的形式将属性存入，然后用for循环从数组中依次获取属性。这样也不用担心可能发掘出原型链中的属性，并且我们按正常的顺序取得了它的值。</li><li>最小化使用全局变量的方法之一是为你的应用只创建一个唯一的全局变量。资源都纳入一个名称空间之下，你的程序与其他应用程序、组件或类库之间发生冲突的可能性就会显著降低。</li><li>函数对参数值不会进行类型检查：任何类型的值都可以被传递给任何参数。</li><li>apply方法让我们构建一个参数数组传递给调用函数。</li><li>因为语言的一个设计错误，arguments并不是一个真正的数组。它只是一个“类似数组（array-like）”的对象。arguments拥有一个length属性，但它没有任何数组的方法。</li><li><strong>尾递归</strong>是一种在函数的最后执行递归调用语句的特殊形式的递归。</li><li>作用域的好处是内部函数可以访问定义它们外部函数的参数和变量（除了this和arguments）。</li><li><strong>继承</strong>的两种服务：<ul><li>是代码重用的一种形式。（如果一个新的类与一个已经存在的类大部分相似，那么你只需要具体说明其不同点即可。代码重用的模式极为重要，因为它们可以显著的减少软件开发的成本。）</li><li>另一个好处是引入了一套类型系统的规范。（由于程序员无需编写显式类型转换的代码，他们的工作量将大大减轻，这是一件很好的事情，因为类型转换会丧失类型系统在安全上的优势。）</li></ul></li><li>构造一个生成对象的函数：<ul><li>1.创建一个新的对象。</li><li>2.有选择地定义私有的实例变量和放方法。</li><li>3.给这个新对象扩充方法。</li><li>4.返回那个新对象。</li></ul></li><li>数组的length属性的值是这个数组的最大整数属性名加上1，它不一定等于数组里属性的个数。</li><li>for in 用来遍历数组的所有属性，但遗憾的是，for in 无法保证属性的顺序。</li><li>数组和对象的使用区别：当属性名是小而连续的整数时，你应该使用数组；否则，使用数组。</li><li>排序的稳定性是指排序后的数组中相等值的相对位置没有发生改变，而不稳定性排序则会改变相等值的相对位置。</li></ul><h3 id="方法篇"><a href="#方法篇" class="headerlink" title="方法篇"></a>方法篇</h3><h5 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h5><ul><li>array.concat(item…):产生新的数组，和它类似功能的array.push(item)。</li><li>array.join(separator):把一个array构造成一个字符串。</li><li>array.pop():移除数组的最后一个元素，并返回这个元素。</li><li>array.push(item…):把一个或多个参数item附加到一个数组的尾部。</li><li>array.reverse():反转array里的元素的顺序，并返回array本身。</li><li>array.shift():移除数组array中的第一个元素，并返回该元素。</li><li>array.slice(start,end):对array中的一段做浅复制。</li><li>array.sort(comparefn):对array中的内容进行排序。</li><li>array.splice(start,deleteCount,item…):从array中移除一个或多个元素，并用新的item替换它们。</li><li>array.unshift(item…):像push方法一样，用于把元素添加到数组中，但它是把item插入到array的开始部分，不是尾部。返回array的新的length。</li></ul><h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><ul><li>function.apply(thisArg,argArray):调用function，传递一个会被绑定到this上的对象和一个可选的数组作为参数。</li></ul><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><ul><li>number.toExponential(fractionDigits):把这个number转换成一个指数形式的字符串。</li><li>number.toFixed(fractionDigits):把这个number转换成为一个十进制数形式的字符串。可选择参数控制其小数点后的数字位数。</li><li>number.toPrecision(precision):把这个number转换成一个十进制数形式的字符串。可选择参数控制数字的精度（0~21）。</li><li>number.toString(radix):把这个number转换成字符串。可选择参数控制基数（2~36，默认是10）。</li></ul><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><ul><li>object.hasOwnProperty(name):判断属性是否存在，不会检查原型链中的同名属性。</li></ul><h4 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h4><ul><li>regexp.exec(string):最强大（和最慢），看书理解。</li><li>regexp.test(string):最简单（和最快），匹配就返回true，否则返回false，不要对这个方法使用g标识。</li></ul><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul><li>string.charAt(pos):返回在string中pos位置处的字符。</li><li>string。charCodeAt(pos):返回在string中pos位置的字符的字符码位（以整数形式表示）。</li><li>string.conecat(string…):把其他的字符串连接在一起来构造一个新的字符串。</li><li>string.indexOf(searchString,postion):在string中查找另一个字符串searchString。找到就返回第一个匹配字符的位置，否则返回-1。可选参数position从字符串的哪个位置开始查找。</li><li>string.lastIndexOf(searchString,position):从字符串的末尾开始查找。</li><li>string.lacaleCompare(that):比较两个字符串。</li><li>string.match(regexp):让字符串和一个正则表达式进行匹配。</li><li>string.replace(searchValue,replaceValue):对string进行查找和替换操作，并返回一个新的字符串（如果searchValue不是一个带有g标识的正则表达式那就只会替换第一个）。</li><li>string.search(regexp):接收一个正则表达式作为对象参数返回匹配的首字符位置。</li><li>string.slice(start,end):复制string的一部分来构造一个新的字符串。</li><li>string.split(separator,limit):把这个string分割成片段来创建一个字符串数组。</li><li>string.substring(start,end):和slice方法一样，只是他不能处理负数参数。</li><li>string.toLocaleLowerCase():返回一个新字符串，使用本地化的规则将这个string中所有字母转换成小写格式。</li><li>string.toLacaleUpperCase():返回一个新字符串，使用本地化的规则将这个string中所有字母转换成大写格式。</li><li>string.toLowerCase():返回一个新的字符串，这个string中所有字母都被转换为小写格式。</li><li>string.toUpperCase():返回一个新的字符串，这个strnig中所有字母都被转换为大写格式。</li><li>string.fromCharCode(char…):函数根据一串数字编码返回一个字符串。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h3&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yangkunyi.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
